<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>STICKS</title>
  <style>
    :root{ color-scheme: dark; }

    body{
      margin:0;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      background:#0b0f14;
      color:#e6edf3;
    }

    .wrap{
      max-width: 1320px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 260px 1fr 420px;
      gap:14px;
      align-items:start;
    }

    .gameWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
    }

    canvas{
      width:100%;
      height:auto;
      border:2px solid var(--lvlBorder, #1f2a37);
      border-radius:12px;
      image-rendering: pixelated;
      background: var(--lvlBg, #070a0e);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15), 0 18px 50px rgba(0,0,0,.35);
      display:block;
      aspect-ratio: 1 / 1;
    }

    .panel{
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:12px;
      padding:12px;
    }

    .panelSticky{
      position: sticky;
      top: 14px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      padding-right: 10px;
    }

    .title{
      font-weight:1000;
      letter-spacing:.6px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }

    .subtitle{
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
      margin-top:6px;
    }

    .hr{ height:1px; background:#1f2a37; margin:10px 0; }

    .log{
      height: 600px;
      overflow:auto;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
      line-height:1.45;
    }
    .log .line{ margin: 0 0 8px 0; }
    .log .line:last-child{ margin-bottom:0; }

    .kv{ display:flex; justify-content:space-between; gap:10px; margin:6px 0; align-items:center; }
    .kv span:first-child{ color:#9fb1c6; }
    .big{ font-size:18px; font-weight:1000; }

    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      font-weight:1000;
      font-size:12px;
      user-select:none;
    }

    .playerArcade{
      font-size:22px;
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      text-shadow: 0 0 18px rgba(120,180,255,0.18);
      user-select:none;
    }

    .controlsTop{
      display:grid;
      grid-template-columns: 132px 1fr;
      gap:12px;
      align-items:center;
    }

    .diceBox{
      width:132px;
      height:132px;
      border-radius:16px;
      border:2px solid #2b3a4c;
      background: radial-gradient(120px 120px at 40% 35%, #1a2a3c 0%, #0b1220 70%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .diceGlow{
      position:absolute;
      inset:-40px;
      background: conic-gradient(from 180deg,
        rgba(0,0,0,0),
        rgba(0,0,0,0),
        var(--lvlAccentGlow, rgba(58,167,255,.32)),
        rgba(0,0,0,0)
      );
      opacity:0;
      filter: blur(10px);
      transform: rotate(0deg);
      pointer-events:none;
    }
    .rolling .diceGlow{ opacity:1; animation: spin .32s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .diceFace{
      font-size:52px;
      font-weight:1000;
      line-height:1;
      text-shadow: 0 0 16px var(--lvlAccentShadow, rgba(58,167,255,.25));
      user-select:none;
    }
    .diceLabel{
      margin-top:8px;
      font-size:12px;
      color:#9fb1c6;
      text-align:center;
      line-height:1.25;
      user-select:none;
    }

    .dpadWrap{ margin-top:10px; display:flex; justify-content:center; align-items:center; }
    .dpad{ width:200px; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .dpad button{
      padding:10px 0;
      border-radius:12px;
      color:#e6edf3;
      background: linear-gradient(180deg,#1b2432,#0b1220);
      border:1px solid #2b3a4c;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.10),
        0 8px 18px rgba(0,0,0,.35);
      font-weight:1000;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      text-shadow: 0 0 14px rgba(255,255,255,0.08);
    }
    .dpad button:hover{ filter: brightness(1.08); }
    .dpad button:active{ transform: translateY(1px); }
    .dpad .empty{ visibility:hidden; }

    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-top:10px;
    }

    button{
      cursor:pointer;
      border:0;
      padding:11px 10px;
      border-radius:12px;
      font-weight:1000;
      letter-spacing:.2px;
      user-select:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.08); }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; }

    .btn-roll { background: linear-gradient(180deg,#3aa7ff,#1172ff); color:#061018; }
    .btn-use  { background: linear-gradient(180deg,#39ff95,#08c46b); color:#061018; }
    .btn-new  { background: linear-gradient(180deg,#ffb347,#ff7a18); color:#1a0f00; }
    .btn-clear{ background: linear-gradient(180deg,#ff5a6a,#ff1f3a); color:#200007; }

    .btn-save { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }
    .btn-load { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }

    .btn-music{ background: linear-gradient(180deg,#c27bff,#7a35ff); color:#120018; grid-column: 1 / span 2; }
    .btn-info { background: linear-gradient(180deg,#f3f4f6,#cbd5e1); color:#0b0f14; }

    .titleBtns{ display:flex; align-items:center; gap:8px; }
    .btn-mini{
      padding:8px 10px;
      border-radius:12px;
      font-weight:1000;
      box-shadow:none;
      min-width:44px;
      line-height:1;
    }

    @keyframes flashRoll {
      0%   { box-shadow: 0 0 0 0 rgba(255,255,255,0.0); transform: translateY(0); }
      100% { box-shadow: 0 0 0 3px rgba(255,255,255,0.75); transform: translateY(-1px); }
    }
    .flashRoll{ animation: flashRoll 0.55s ease-in-out infinite alternate; }

    .monsterEvent{
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #ff1f3a;
      background:#1a0509;
      display:flex;
      gap:8px;
      align-items:flex-start;
      font-size:12px;
      line-height:1.35;
    }
    .monsterEventIcon{ font-size:20px; margin-top:2px; }
    .monsterEventTitle{ font-weight:1000; color:#ffb347; margin-bottom:3px; }

    .statsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #1f2a37;
      background:#0b1220;
    }
    .statsGrid .kv{ margin:0; }
    .statsGrid .big{ font-size:16px; }

    .leaderboard{
      margin-top:10px;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
    }
    .leaderRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 6px;
      border-radius:10px;
    }
    .leaderRow:nth-child(odd){ background: rgba(255,255,255,0.03); }
    .leaderName{ font-weight:1000; letter-spacing:.3px; }
    .leaderMeta{ color:#9fb1c6; }
    .gold { color:#ffd166; }
    .silver { color:#cbd5e1; }
    .bronze { color:#ffb347; }

    .battleFeedWrap{
      margin-top:10px;
      border:1px solid #1f2a37;
      border-radius:12px;
      background:#0b1220;
      padding:10px;
    }
    .battleFeedHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
    }
    .battleFeedHeader b{ letter-spacing:.4px; }
    .battleLog{
      max-height: 220px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      border-radius:10px;
      border:1px solid #1f2a37;
      padding:10px;
      background:#070c16;
      font-size:12px;
      line-height:1.45;
    }

    .scrollHint{
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px dashed #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.25;
      text-align:center;
      user-select:none;
    }
    .scrollHint .arrow{
      display:inline-block;
      font-weight:1000;
      margin-left:6px;
      animation: bob 1.1s ease-in-out infinite;
    }
    @keyframes bob{
      0%,100%{ transform: translateY(0); opacity:.75; }
      50%{ transform: translateY(2px); opacity:1; }
    }

    /* ‚úÖ stick figure selector */
    select{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      cursor:pointer;
    }
    select:focus{ box-shadow: 0 0 0 3px rgba(58,167,255,0.18); }

    #infoOverlay,#nameOverlay,#gameOverOverlay,#winOverlay,#pauseOverlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.72);
      z-index:9999;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .modalBox{
      width:min(780px,94vw);
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:16px;
      padding:16px;
      max-height: calc(var(--vh, 1vh) * 92);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    .modalTitle{ font-weight:1000; letter-spacing:.8px; font-size:18px; }
    .modalText{
      color:#cdd9e5;
      font-size:13px;
      line-height:1.45;
      margin-top:8px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 6px;
      white-space: pre-wrap;
    }
    .modalActions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:14px;
      flex-wrap:wrap;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(15,23,32,0.0), rgba(15,23,32,0.88) 30%, rgba(15,23,32,1));
      padding-top: 10px;
    }
    .modalClose{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      box-shadow:none;
    }

    /* ‚úÖ Win/Lose presentation */
    .endBanner{
      margin-top:10px;
      border-radius:14px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      overflow:hidden;
      position:relative;
    }
    .endBanner .bigIcon{
      font-size:34px;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.12));
      animation: pop 0.9s ease-in-out infinite alternate;
      user-select:none;
    }
    @keyframes pop { from{ transform: translateY(0) scale(1); } to{ transform: translateY(-2px) scale(1.04); } }

    .endBanner .endHeadline{
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      font-size:14px;
    }
    .endBanner .endSub{
      color:#9fb1c6;
      font-size:12px;
      margin-top:4px;
      line-height:1.25;
    }

    .fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .fx span{
      position:absolute;
      font-size:14px;
      opacity:0.9;
      animation: drift 1.6s linear forwards;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.10));
      user-select:none;
    }
    @keyframes drift{
      from{ transform: translateY(0) rotate(0deg); opacity:0.95; }
      to{ transform: translateY(140px) rotate(180deg); opacity:0; }
    }

    .winBanner{
      border-color: rgba(194,123,255,0.65);
      background: radial-gradient(340px 140px at 35% 25%, rgba(194,123,255,0.22) 0%, rgba(7,12,22,1) 65%);
    }
    .loseBanner{
      border-color: rgba(255,90,106,0.7);
      background: radial-gradient(340px 140px at 35% 25%, rgba(255,31,58,0.20) 0%, rgba(7,12,22,1) 65%);
    }

    #nameOverlay input{
      flex:1;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      font-size:16px;
      letter-spacing:.6px;
      text-transform: uppercase;
    }
    .saveBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #39ff95;
      background: linear-gradient(180deg,#39ff95,#08c46b);
      color:#061018;
      font-weight:1000;
      box-shadow:none;
    }
    .altBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#f3f4f6,#cbd5e1);
      color:#0b0f14;
      font-weight:1000;
      box-shadow:none;
    }
    .warnBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #ff5a6a;
      background: linear-gradient(180deg,#ff5a6a,#ff1f3a);
      color:#200007;
      font-weight:1000;
      box-shadow:none;
    }
    .hintRow{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
    }

    @media (max-width:1200px){
      .wrap{ grid-template-columns:1fr; }
      .log{ height:220px; }
      .controlsTop{ grid-template-columns:1fr; }
      .diceBox{ width:100%; height:120px; }
      .dpad{ width:100%; max-width:240px; }
      .panelSticky{ position: static; max-height: none; overflow: visible; padding-right:12px; }
    }

    @media (max-width:720px){
      .wrap > .panel:first-child{ display:none; }

      body{
        height: calc(var(--vh, 1vh) * 100);
        overflow:hidden;
      }

      .wrap{
        height: calc(var(--vh, 1vh) * 100);
        max-width:none;
        margin:0;
        padding:10px;
        gap:10px;
        grid-template-columns: 1fr;
        grid-template-rows: 1.35fr 1fr;
        align-items:stretch;
      }

      .gameWrap{
        height:100%;
        min-height:0;
      }

      canvas{
        width:auto;
        height:100%;
        max-width:100%;
        max-height:100%;
      }

      .panel-right{
        height:100%;
        min-height:0;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        display:flex;
        flex-direction:column;
        padding-bottom: calc(env(safe-area-inset-bottom) + 90px);
      }

      .controlsScroll{ order:1; }
      .headerBlock{ order:2; margin-top:10px; }
      .headerBlock .hr{ margin:10px 0 0 0; }

      .controlsTop{
        grid-template-columns: 1fr;
        gap:8px;
        margin-top:2px;
      }
      .controlsTop .subtitle{ display:none; }

      .diceBox{
        width:100%;
        height:84px;
        border-radius:14px;
      }
      .diceFace{ font-size:40px; }
      .diceLabel{ font-size:11px; margin-top:4px; }

      .controlsScroll{
        overflow: visible;
        -webkit-overflow-scrolling: auto;
        min-height:auto;
        padding-right:0;
        flex: 0 0 auto;
      }

      .battleFeedWrap{ display:block; }
    }

    @media (min-width:721px){
      .battleFeedWrap{ display:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="title"><div>Activity</div><span class="badge" id="uiThemeMini">Night Stick</span></div>
      <div class="subtitle">Latest on top. Color = importance.</div>
      <div class="hr"></div>
      <div class="log" id="log"></div>
    </div>

    <div class="gameWrap">
      <canvas id="game"></canvas>
    </div>

    <div class="panel panelSticky panel-right">
      <div class="controlsScroll" id="controlsScroll">
        <div class="controlsTop">
          <div class="diceBox" id="diceBox">
            <div class="diceGlow"></div>
            <div class="diceFace" id="diceFace">‚Äî</div>
            <div class="diceLabel" id="diceLabel">Press Roll</div>
          </div>
          <div class="subtitle">
            <b>Actions</b> = your energy.<br/>
            Spend Actions to <span class="badge">Move</span> or <span class="badge">Pick/Drop</span>.<br/>
            <span style="color:#9fb1c6">Spend Actions before rolling again.</span>
          </div>
        </div>

        <div class="scrollHint" id="scrollHint">
          Swipe up for controls, stats, and battle feed <span class="arrow">‚ñº</span>
        </div>

        <div id="monsterEvent" class="monsterEvent" style="display:none;">
          <div class="monsterEventIcon">üëπ</div>
          <div>
            <div class="monsterEventTitle">Stick Monster Appears!</div>
            <div id="monsterEventText">
              Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a 2√ó stick. Roll 0‚Äì1 and you lose 1 life.
            </div>
          </div>
        </div>

        <div class="dpadWrap" aria-label="D-pad">
          <div class="dpad">
            <button class="empty"></button>
            <button id="btnUp" aria-label="Up">‚ñ≤</button>
            <button class="empty"></button>
            <button id="btnLeft" aria-label="Left">‚óÄ</button>
            <button id="btnDown" aria-label="Down">‚ñº</button>
            <button id="btnRight" aria-label="Right">‚ñ∂</button>
          </div>
        </div>

        <div class="btns">
          <button id="btnRoll" class="btn-roll">üé≤ Roll</button>
          <button id="btnUse" class="btn-use">Pick/Drop</button>
          <button id="btnNew" class="btn-new">New Game</button>
          <button id="btnPause" class="btn-clear">‚è∏ Pause</button>
          <button id="btnMusic" class="btn-music">Music: OFF</button>
        </div>

        <div class="hr"></div>

        <div class="kv"><span>Player</span><span id="uiPlayer" class="playerArcade">PLAYER1</span></div>

        <div class="kv"><span>Stick Figure</span>
          <select id="uiSkin" aria-label="Stick Figure">
            <option value="classic">Classic</option>
            <option value="alien">Alien</option>
            <option value="sally">Sally Stick</option>
            <option value="rick">Rick Stick</option>
            <option value="robot">Robo Stick</option>
          </select>
        </div>

        <div class="statsGrid">
          <div class="kv"><span>Lives</span><span id="uiLives" class="big">3</span></div>
          <div class="kv"><span>Level</span><span id="uiLevel" class="big">1</span></div>
          <div class="kv"><span>Score</span><span id="uiScore" class="big">0</span></div>
          <div class="kv"><span>Actions</span><span id="uiActions" class="big">0</span></div>
          <div class="kv"><span>Mode</span><span id="uiMode" class="big">NORMAL</span></div>
          <div class="kv"><span>Die</span><span id="uiDie" class="big">0‚Äì5</span></div>
          <div class="kv"><span>Carrying</span><span id="uiCarry" class="big">0/3</span></div>
          <div class="kv"><span>Sticks left</span><span id="uiLeft" class="big">0</span></div>
        </div>

        <div class="leaderboard" id="leaderboard"></div>

        <div class="battleFeedWrap" id="battleFeedWrap">
          <div class="battleFeedHeader">
            <b>Battle Feed</b>
            <span class="badge">Latest</span>
          </div>
          <div style="color:#9fb1c6; font-size:12px; margin-bottom:8px;">
            Monster wins, deposits, level-ups, and warnings show up here.
          </div>
          <div class="battleLog" id="battleLog"></div>
        </div>

        <div style="height:10px;"></div>
      </div>

      <div class="headerBlock">
        <div class="title">
          <div>STICKS <span class="badge">v2.40</span></div>
          <div class="titleBtns">
            <button id="btnSave" class="btn-save btn-mini" aria-label="Save Game" title="Save (S)">üíæ</button>
            <button class="btn-info btn-mini" id="btnInfo" title="Info">Info</button>
            <button id="btnLoad" class="btn-load btn-mini" aria-label="Load Game" title="Load (L)">üìÇ</button>
          </div>
        </div>
        <div class="subtitle">Pick up sticks. Feed the hole. Clear the field. Advance levels.</div>
        <div class="hr"></div>
      </div>
    </div>
  </div>

  <div id="infoOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">How to Play (Quick)</div>
      <div class="modalText">
        <div style="margin:8px 0;"><span class="badge">Roll</span> gives Actions. You must spend Actions before rolling again.</div>
        <div style="margin:8px 0;"><span class="badge">Move</span> costs 1 Action per step (Arrow Keys or D-Pad).</div>
        <div style="margin:8px 0;"><span class="badge">Pick/Drop</span> costs 1 Action:
          pick a stick if on one, <b>place 1 carried stick</b> onto an empty tile, or deposit into the hole.
        </div>
        <div style="margin:8px 0;"><span class="badge">Zero</span>:
          if carrying sticks, you drop and they scatter. If carrying none, the hole gets angry and spits out a stick.
        </div>

        <div style="margin:8px 0;"><span class="badge">Bonus Stick</span>:
          a secret Bonus stick pays out in 2 parts:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
            <li><b>If you have Actions left</b> after picking it up, your remaining Actions are <b>doubled</b>.</li>
            <li><b>After Actions hit 0</b>, you get a <b>Bonus Roll</b> (double dice <b>2‚Äì12</b>).</li>
            <li><b>If you hit 0 Actions immediately</b> after picking it up, the <b>Bonus Roll happens right away</b>.</li>
          </ul>
          During Bonus Roll mode: deposits are <b>2√ó</b>. Roll <b>12</b> to earn <b>one extra Bonus roll</b> (after Actions hit 0).
        </div>

        <div style="margin:8px 0;"><span class="badge">Extra Life (Secret Tile)</span>:
          each level hides <b>one secret tile</b>.
          The tile only hints/pulses when you are <b>standing on it</b> while <b>carrying a stick</b>.
          If you <b>drop</b> a stick on that square, you gain <b>+1 life</b> (the stick is used up).
          <b>If you are already at max lives</b>, you get <b>bonus points</b> instead.
        </div>

        <div style="margin:8px 0;"><span class="badge">Tree (Life + Magic Load)</span>:
          the tree appears <b>mid-level</b> sometime between <b>1‚Äì5 minutes</b>, stays <b>15s</b>, then <b>blinks for 15s</b> before disappearing.
          <b>(Tree timer freezes during Stick Monster battles.)</b>
          While standing on it:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
            <li><b>If carrying sticks:</b> press <b>Pick/Drop</b> to feed <b>1 stick</b> for <b>+1 life</b>. <b>If already max lives</b>, that stick becomes <b>bonus points</b>.</li>
            <li><b>If carrying 0 sticks:</b> press <b>Pick/Drop</b> to instantly get a <b>full load</b> (fills to your carry limit for that level).</li>
            <li><b>Tree balance:</b> after you successfully <b>gain a life</b> from the tree, it <b>disappears</b>. If there are <b>no sticks left on the ground</b> and you use the tree to get a <b>full load</b>, it also <b>disappears</b>.</li>
          </ul>
        </div>

        <div style="margin:8px 0;"><span class="badge">Stick Monster</span>:
          some sticks are cursed. When you try to pick one up, a Stick Monster appears.
          Press <b>ROLL</b>: roll <b>2‚Äì5</b> to keep a powered-up stick, roll <b>0‚Äì1</b> and you lose 1 life.
          <div style="margin-top:6px;color:#9fb1c6;">
            <b>Streak Bonus:</b>
            <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
              <li>Each monster win in a row builds a <b>Monster streak</b>.</li>
              <li>The streak persists across levels and only resets when you <b>lose</b> a monster fight (roll 0‚Äì1).</li>
              <li>On your <b>3rd consecutive win</b> you gain <b>+1 life</b> (max 5).</li>
              <li>Monster sticks are normally <b>2√ó</b>. Starting on your <b>4th consecutive win</b>, they scale up: <b>3√ó ‚Üí 4√ó ‚Üí 5√ó ‚Üí ...</b> until you lose.</li>
            </ul>
          </div>
        </div>

        <div style="margin:8px 0; color:#9fb1c6;">Controls: Arrow Keys or D-Pad ‚Ä¢ Space = Pick/Drop ‚Ä¢ Esc or P = Pause</div>
        <div style="margin:10px 0; color:#9fb1c6;"><b>Save/Load:</b> saves only on this device (local browser storage).</div>
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnInfoClose">Close</button>
      </div>
    </div>
  </div>

  <div id="nameOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">ENTER YOUR NAME</div>
      <div class="modalText" style="color:#9fb1c6">Stored only on this device (local browser storage).</div>

      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <input id="nameInput" maxlength="16" placeholder="ENTER NAME"/>
        <button id="nameStartBtn" class="saveBtn">Start</button>
      </div>

      <div class="hintRow" id="savedNameHint" style="display:none;"></div>

      <div class="modalActions" style="justify-content:flex-start;">
        <button id="nameUseSavedBtn" class="altBtn" style="display:none;">Use SAVED</button>
        <button id="nameUseP1Btn" class="warnBtn">Use PLAYER1</button>
      </div>

      <div class="modalText" style="color:#9fb1c6; margin-top:10px;">Press <b>Enter</b> to start ‚Ä¢ <b>Esc</b> uses PLAYER1</div>
    </div>
  </div>

  <div id="pauseOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">PAUSED</div>
      <div class="modalText" style="color:#9fb1c6">
        Game + music are paused.<br/>
        Press <b>Pause</b> again to resume.
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnPauseClose">Resume</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">GAME OVER</div>

      <div class="endBanner loseBanner">
        <div>
          <div class="endHeadline">The sticks won this round</div>
          <div class="endSub">No shame. Just‚Ä¶ stick disrespect.</div>
        </div>
        <div class="bigIcon">üíÄ</div>
        <div class="fx" id="loseFx"></div>
      </div>

      <div class="modalText" id="gameOverText">The sticks won this time.</div>
      <div class="modalActions">
        <button class="modalClose" id="btnGameOverClose">Close</button>
        <button class="modalClose" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>

  <div id="winOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">YOU WIN</div>

      <div class="endBanner winBanner">
        <div>
          <div class="endHeadline">Victory Stick cleared</div>
          <div class="endSub">Fanfare engaged. Ego permitted.</div>
        </div>
        <div class="bigIcon">üèÜ</div>
        <div class="fx" id="winFx"></div>
      </div>

      <div class="modalText" id="winText">You cleared the sticks. The hole is satisfied (for now).</div>
      <div class="modalActions">
        <button class="modalClose" id="btnWinRestart">Play Again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar, { passive:true });
  window.addEventListener('orientationchange', setVhVar, { passive:true });

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (lo, hi) => Math.floor(Math.random() * (hi - lo + 1)) + lo;

  const LS_PLAYER_NAME  = "sticks_playerName_v3";
  const LS_LEADERBOARD  = "sticks_leaderboard_v1";
  const LS_SAVEGAME     = "sticks_savegame_v1";
  const SS_SCROLLED     = "sticks_scrolled_controls_v1";
  const LS_PLAYER_SKIN  = "sticks_playerSkin_v1";

  /* ---- Level Themes + Stick Names ---- */
  const LEVELS = [
    { name:"Night Stick",   bg:"#070a0e", grid:"#0f1720", border:"#1f2a37", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.35)", accentShadow:"rgba(58,167,255,.28)" },
    { name:"Sun Stick",     bg:"#140a03", grid:"#4a3a06", border:"#ffd400", accent:"#ffd400", accentGlow:"rgba(255,212,0,.46)", accentShadow:"rgba(255,212,0,.28)" },
    { name:"Sky Stick",     bg:"#041027", grid:"#0b234a", border:"#1172ff", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.46)", accentShadow:"rgba(58,167,255,.30)" },
    { name:"Fire Stick",    bg:"#1a0509", grid:"#361017", border:"#ff1f3a", accent:"#ff5a6a", accentGlow:"rgba(255,31,58,.46)", accentShadow:"rgba(255,90,106,.30)" },
    { name:"Leaf Stick",    bg:"#04120a", grid:"#0a2414", border:"#08c46b", accent:"#39ff95", accentGlow:"rgba(57,255,149,.44)", accentShadow:"rgba(57,255,149,.28)" },
    { name:"Spell Stick",   bg:"#0c0418", grid:"#1a0b33", border:"#7a35ff", accent:"#c27bff", accentGlow:"rgba(194,123,255,.46)", accentShadow:"rgba(194,123,255,.30)" },

    /* ‚úÖ ICE: neon baby-blue outline + grid, still white-ish background */
    { name:"Ice Stick",     bg:"#f7fbff", grid:"#8be9fd", border:"#7dd3fc", accent:"#ffffff", accentGlow:"rgba(125,211,252,.52)", accentShadow:"rgba(125,211,252,.28)" },

    /* ‚úÖ GLOW: neon-ish orange grid to match outline (Sun Stick vibe, but orange) */
    { name:"Glow Stick",    bg:"#09060f", grid:"#ff7a18", border:"#ff7a18", accent:"#ffb347", accentGlow:"rgba(255,122,24,.46)", accentShadow:"rgba(255,122,24,.28)" },

    /* ‚úÖ VICTORY: neon purple grid like Music button */
    { name:"Victory Stick", bg:"#070315", grid:"#c27bff", border:"#7a35ff", accent:"#c27bff", accentGlow:"rgba(194,123,255,.55)", accentShadow:"rgba(194,123,255,.30)" }
  ];

  const STICK_COLORS = [
    "#ff5a6a","#ff1f3a","#ffb347","#ff7a18","#39ff95","#08c46b",
    "#3aa7ff","#1172ff","#c27bff","#7a35ff","#ffd166","#a8dadc",
    "#95d5b2","#ff9f1c","#b08cff","#f3f4f6"
  ];

  const TILE = 24, GRID_W = 24, GRID_H = 24;
  const CANVAS_W = GRID_W * TILE, CANVAS_H = GRID_H * TILE;

  const LOG_MAX_LINES = 12;

  /* ---- Max life bonus points (when a life reward is blocked) ---- */
  const MAX_LIVES = 5;
  const LIFE_TILE_MAX_POINTS = 12;   // when you "pay" a stick on secret tile but are already max lives
  const TREE_FEED_MAX_POINTS = 8;    // when you "pay" a stick to tree but are already max lives

  /* ---- Music ---- */
  const MUSIC_STEP_MS = 245;
  let musicOn = false;
  let musicTimer = null;
  let musicStep = 0;

  let celebrationUntil = 0;
  let celebrationStep = 0;

  let doomUntil = 0;
  let doomStep = 0;

  const MUSIC_A = [
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.040 },
    { lead:330, bass:98, dur:0.16, gain:0.038 },
    { lead:294, bass:98, dur:0.16, gain:0.038 },
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:392, bass:110, dur:0.16, gain:0.038 },
    { lead:330, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_B = [
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:494, bass:110, dur:0.16, gain:0.038 },
    { lead:523, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:294, bass:98, dur:0.16, gain:0.036 },
    { chord:[247,311,370], bass:92, dur:0.18, gain:0.040 },
    { lead:370, bass:92, dur:0.16, gain:0.038 },
    { lead:330, bass:92, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_CELEB = [
    { chord:[523,659,784], bass:131, dur:0.18, gain:0.052 },
    { lead:784, bass:131, dur:0.14, gain:0.050 },
    { lead:988, bass:131, dur:0.14, gain:0.050 },
    { chord:[659,784,988], bass:147, dur:0.18, gain:0.052 },
    { lead:1175, bass:147, dur:0.14, gain:0.050 },
    { lead:988, bass:147, dur:0.14, gain:0.048 },
    { chord:[587,740,880], bass:110, dur:0.18, gain:0.050 },
    { lead:880, bass:110, dur:0.14, gain:0.048 },
    { lead:988, bass:110, dur:0.14, gain:0.048 },
    { chord:[659,784,988], bass:131, dur:0.18, gain:0.052 },
    { lead:0 }
  ];

  /* ‚úÖ Doom: pac-man-ish "death" vibe (original notes, just that classic falling feel) */
  const MUSIC_DOOM = [
    { lead:988, dur:0.14, gain:0.080, type:"square" },
    { lead:932, dur:0.14, gain:0.080, type:"square" },
    { lead:880, dur:0.14, gain:0.080, type:"square" },
    { lead:784, dur:0.16, gain:0.082, type:"square" },
    { lead:698, dur:0.18, gain:0.082, type:"square" },
    { lead:622, dur:0.20, gain:0.082, type:"square" },
    { lead:554, dur:0.22, gain:0.082, type:"square" },
    { lead:466, dur:0.24, gain:0.082, type:"square" },
    { lead:392, dur:0.28, gain:0.082, type:"square" },
    { lead:0 }
  ];

  function startCelebrationMusic(ms=6500){
    if (!musicOn) return;
    celebrationUntil = Date.now() + ms;
    celebrationStep = 0;
  }
  function startDoomMusic(ms=6500){
    if (!musicOn) return;
    doomUntil = Date.now() + ms;
    doomStep = 0;
  }

  function pickMusicStep(stepIdx){
    const block = Math.floor(stepIdx / 32);
    const useB = (block % 2 === 1);
    const seq = useB ? MUSIC_B : MUSIC_A;
    const s = seq[stepIdx % seq.length];
    if (s && s.lead && Math.random() < 0.10){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickCelebrationStep(){
    const s = MUSIC_CELEB[celebrationStep++ % MUSIC_CELEB.length];
    if (s && s.lead && Math.random() < 0.18){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickDoomStep(){
    const s = MUSIC_DOOM[doomStep++ % MUSIC_DOOM.length];
    return s;
  }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const ui = {
    log: document.getElementById("log"),
    battleLog: document.getElementById("battleLog"),
    themeMini: document.getElementById("uiThemeMini"),
    controlsScroll: document.getElementById("controlsScroll"),
    scrollHint: document.getElementById("scrollHint"),

    player: document.getElementById("uiPlayer"),
    skin: document.getElementById("uiSkin"),

    lives: document.getElementById("uiLives"),
    level: document.getElementById("uiLevel"),
    score: document.getElementById("uiScore"),
    actions: document.getElementById("uiActions"),
    mode: document.getElementById("uiMode"),
    die: document.getElementById("uiDie"),
    carry: document.getElementById("uiCarry"),
    left: document.getElementById("uiLeft"),

    diceBox: document.getElementById("diceBox"),
    diceFace: document.getElementById("diceFace"),
    diceLabel: document.getElementById("diceLabel"),

    btnRoll: document.getElementById("btnRoll"),
    btnUse: document.getElementById("btnUse"),
    btnNew: document.getElementById("btnNew"),
    btnPause: document.getElementById("btnPause"),
    btnMusic: document.getElementById("btnMusic"),

    btnUp: document.getElementById("btnUp"),
    btnDown: document.getElementById("btnDown"),
    btnLeft: document.getElementById("btnLeft"),
    btnRight: document.getElementById("btnRight"),

    btnSave: document.getElementById("btnSave"),
    btnLoad: document.getElementById("btnLoad"),

    infoOverlay: document.getElementById("infoOverlay"),
    btnInfo: document.getElementById("btnInfo"),
    btnInfoClose: document.getElementById("btnInfoClose"),

    nameOverlay: document.getElementById("nameOverlay"),
    nameInput: document.getElementById("nameInput"),
    nameStartBtn: document.getElementById("nameStartBtn"),
    nameUseSavedBtn: document.getElementById("nameUseSavedBtn"),
    nameUseP1Btn: document.getElementById("nameUseP1Btn"),
    savedNameHint: document.getElementById("savedNameHint"),

    pauseOverlay: document.getElementById("pauseOverlay"),
    btnPauseClose: document.getElementById("btnPauseClose"),

    gameOverOverlay: document.getElementById("gameOverOverlay"),
    gameOverText: document.getElementById("gameOverText"),
    btnRestart: document.getElementById("btnRestart"),
    btnGameOverClose: document.getElementById("btnGameOverClose"),

    winOverlay: document.getElementById("winOverlay"),
    winText: document.getElementById("winText"),
    btnWinRestart: document.getElementById("btnWinRestart"),

    leaderboard: document.getElementById("leaderboard"),

    monsterEvent: document.getElementById("monsterEvent"),
    monsterEventText: document.getElementById("monsterEventText"),

    winFx: document.getElementById("winFx"),
    loseFx: document.getElementById("loseFx"),
  };

  const LOG_STYLE = {
    neutral: { color:"#e5e7eb", icon:"" },
    roll:    { color:"#e5e7eb", icon:"üé≤ " },
    place:   { color:"#e5e7eb", icon:"üìç " },
    pickup:  { color:"#e5e7eb", icon:"ü™µ " },
    deposit: { color:"#39ff95", icon:"‚ú® " },
    bonus:   { color:"#c27bff", icon:"üí• " },
    level:   { color:"#ffd166", icon:"üèÜ " },
    warn:    { color:"#ffb347", icon:"‚ö†Ô∏è " },
    bad:     { color:"#ff5a6a", icon:"üíÄ " },
    monster: { color:"#ff1f3a", icon:"üëπ " },
    save:    { color:"#ffd166", icon:"üíæ " },
    load:    { color:"#a8dadc", icon:"üìÇ " },
    win:     { color:"#f3f4f6", icon:"üåü " },
  };

  function prependToLog(el, line){
    if (!el) return;
    el.prepend(line);
    while (el.children.length > LOG_MAX_LINES) el.removeChild(el.lastChild);
  }

  function logEvent(kind, msg){
    const st = LOG_STYLE[kind] || LOG_STYLE.neutral;

    const line1 = document.createElement("div");
    line1.className = "line";
    line1.style.color = st.color;
    line1.textContent = (st.icon || "") + msg;

    const line2 = line1.cloneNode(true);

    prependToLog(ui.log, line1);
    prependToLog(ui.battleLog, line2);
  }

  function loadLeaderboard(){
    try{
      const raw = localStorage.getItem(LS_LEADERBOARD);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveLeaderboard(arr){
    localStorage.setItem(LS_LEADERBOARD, JSON.stringify(arr));
  }
  function upsertLeaderboardEntry(name, score, level){
    const n = (name || "PLAYER1").toUpperCase();
    const lb = loadLeaderboard();
    const filtered = lb.filter(e => (e?.name || "").toUpperCase() !== n);
    filtered.push({ name:n, score: Number(score)||0, level: Number(level)||1 });
    filtered.sort((x,y) => {
      if (y.score !== x.score) return y.score - x.score;
      return y.level - x.level;
    });
    const top3 = filtered.slice(0,3);
    saveLeaderboard(top3);
    renderLeaderboard(top3);
  }
  function renderLeaderboard(lb){
    const rows = (lb && lb.length) ? lb : loadLeaderboard();
    ui.leaderboard.innerHTML = "";
    if (!rows.length){
      ui.leaderboard.innerHTML = `<div style="color:#9fb1c6;">No scores yet. Play a game.</div>`;
      return;
    }
    const medals = ["gold","silver","bronze"];
    rows.forEach((e, idx) => {
      const wrap = document.createElement("div");
      wrap.className = "leaderRow";
      const medalClass = medals[idx] || "";
      wrap.innerHTML = `
        <div>
          <div class="leaderName ${medalClass}">${escapeHtml(e.name || "PLAYER1")}</div>
          <div class="leaderMeta">Lvl ${Number(e.level)||1}</div>
        </div>
        <div class="big">${Number(e.score)||0}</div>
      `;
      ui.leaderboard.appendChild(wrap);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function isPhone(){
    return window.matchMedia && window.matchMedia("(max-width:720px)").matches;
  }
  function updateScrollHint(){
    if (!ui.scrollHint || !ui.controlsScroll) return;
    if (!isPhone()){ ui.scrollHint.style.display = "none"; return; }
    if (sessionStorage.getItem(SS_SCROLLED) === "1"){ ui.scrollHint.style.display = "none"; return; }
    const canScroll = ui.controlsScroll.scrollHeight > (ui.controlsScroll.clientHeight + 6);
    const atTop = ui.controlsScroll.scrollTop <= 2;
    ui.scrollHint.style.display = (canScroll && atTop) ? "block" : "none";
  }
  ui.controlsScroll?.addEventListener("scroll", () => {
    if (!isPhone()) return;
    if (ui.controlsScroll.scrollTop > 20){
      sessionStorage.setItem(SS_SCROLLED, "1");
      updateScrollHint();
    }
  }, { passive:true });
  window.addEventListener("resize", () => setTimeout(updateScrollHint, 60), { passive:true });

  /* ---------- AUDIO ---------- */
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  async function unlockAudio(){
    try{
      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.00001;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.01);
      audioUnlocked = true;
    }catch(_){}
  }
  const unlockOnce = async () => {
    if (audioUnlocked) return;
    await unlockAudio();
  };
  document.addEventListener("touchstart", unlockOnce, { passive:true });
  document.addEventListener("pointerdown", unlockOnce, { passive:true });

  function beep(freq=440, dur=0.08, type="sine", gain=0.08){
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.linearRampToValueAtTime(0, t0 + dur);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }catch(e){}
  }
  function chord(freqs=[440,550], dur=0.12, gain=0.05, type="triangle"){
    freqs.forEach((f)=>beep(f, dur, type, gain));
  }

  function startMusic(){
    ensureAudio();
    if (musicTimer) return;
    musicStep = 0;
    musicTimer = setInterval(() => {
      if (!musicOn) return;

      if (game.pendingMonster) return;

      const now = Date.now();
      const inDoom = now < doomUntil;
      const inCelebration = (!inDoom) && (now < celebrationUntil);

      const step = inDoom ? pickDoomStep() : (inCelebration ? pickCelebrationStep() : pickMusicStep(musicStep++));
      if (!step) return;

      const hasChord = Array.isArray(step.chord) && step.chord.length;
      const hasLead  = step.lead && !hasChord;
      const hasBass  = step.bass;

      if (!hasChord && !hasLead && !hasBass) return;

      const dur  = step.dur  ?? 0.16;
      const gain = step.gain ?? 0.040;
      const oscType = step.type || "triangle";

      if (hasChord){
        chord(step.chord, dur, gain, oscType);
      } else if (hasLead){
        beep(step.lead, dur, oscType, gain);
      }
      if (hasBass){
        beep(step.bass, dur * 1.2, "sine", gain * 0.70);
      }
    }, MUSIC_STEP_MS);
  }
  function stopMusic(){
    if (musicTimer){ clearInterval(musicTimer); musicTimer = null; }
  }

  /* ---- Pause (true pause: stops loop, stops music, freezes timeouts) ---- */
  let paused = false;
  let rafId = null;
  let pauseStartedAt = 0;
  let pausePrevInputLocked = false;
  let pausePrevMusicOn = false;

  const activeTimeouts = new Map(); // id -> { fn, due }
  let pausedTimeouts = [];

  function gameSetTimeout(fn, ms){
    const due = Date.now() + ms;
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.set(id, { fn, due });
    return id;
  }
  function pauseAllGameTimeouts(){
    const now = Date.now();
    pausedTimeouts = [];
    for (const [id, meta] of activeTimeouts.entries()){
      clearTimeout(id);
      pausedTimeouts.push({ fn: meta.fn, ms: Math.max(0, meta.due - now) });
    }
    activeTimeouts.clear();
  }
  function resumeAllGameTimeouts(){
    const list = pausedTimeouts.slice();
    pausedTimeouts = [];
    list.forEach(t => gameSetTimeout(t.fn, t.ms));
  }

  function startLoop(){
    if (rafId) return;
    rafId = requestAnimationFrame(loop);
  }

  function stopMonsterDoom(){
    if (monsterDoomStingTimer){
      clearTimeout(monsterDoomStingTimer);
      monsterDoomStingTimer = null;
    }
  }

  function pauseGame(){
    if (paused) return;

    if (ui.nameOverlay.style.display === "flex") return;

    paused = true;
    pauseStartedAt = Date.now();

    pausePrevInputLocked = game.inputLocked;
    game.inputLocked = true;

    pausePrevMusicOn = musicOn;
    if (musicOn) stopMusic();
    stopMonsterDoom();

    pauseAllGameTimeouts();

    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    ui.pauseOverlay.style.display = "flex";
    ui.btnPause.textContent = "‚ñ∂ Resume";
  }

  function resumeGame(){
    if (!paused) return;

    const now = Date.now();
    const delta = Math.max(0, now - pauseStartedAt);

    if (celebrationUntil) celebrationUntil += delta;
    if (doomUntil) doomUntil += delta;

    paused = false;

    ui.pauseOverlay.style.display = "none";
    ui.btnPause.textContent = "‚è∏ Pause";

    game.inputLocked = pausePrevInputLocked;

    resumeAllGameTimeouts();
    startLoop();

    if (pausePrevMusicOn && musicOn){
      startMusic();
      if (game.pendingMonster) playMonsterDoomSting();
    }
  }

  function togglePause(){
    if (paused) resumeGame();
    else pauseGame();
  }

  /* ---- Stick Monster: doom sting (battle intro) ---- */
  let monsterDoomStingTimer = null;

  function playMonsterDoomSting(){
    if (!musicOn) return;
    ensureAudio();
    stopMonsterDoom();

    const seq = [
      () => { beep(55, 0.22, "sawtooth", 0.10); beep(73.4, 0.20, "sawtooth", 0.08); chord([110,131,165], 0.14, 0.055, "triangle"); },
      () => { beep(49, 0.22, "sawtooth", 0.10); chord([98,117,147], 0.16, 0.055, "triangle"); },
      () => { beep(55, 0.26, "sawtooth", 0.10); chord([110,147,165], 0.14, 0.055, "triangle"); },
      () => { beep(41.2, 0.28, "sawtooth", 0.10); chord([82,98,123], 0.18, 0.055, "triangle"); },
      () => { beep(55, 0.30, "sawtooth", 0.10); chord([110,131,165], 0.18, 0.055, "triangle"); }
    ];

    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (!game.pendingMonster) return;
      if (i >= seq.length) return;
      seq[i++]();
      monsterDoomStingTimer = gameSetTimeout(step, 480);
    };
    step();
  }

  /* ‚úÖ pac-man-ish death sting for monster WIN */
  function playPacmanDeathSting(){
    if (!musicOn) return;
    ensureAudio();
    const notes = [988, 932, 880, 784, 698, 622, 554, 466, 392];
    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (i >= notes.length) return;
      beep(notes[i++], 0.11 + i*0.01, "square", 0.095);
      gameSetTimeout(step, 90);
    };
    step();
  }

  /* ---- SFX ---- */
  function sfxRoll(){ beep(320,0.06,"square",0.06); beep(420,0.07,"square",0.05); }
  function sfxPickup(){ beep(740,0.06,"triangle",0.07); }
  function sfxPlace(){ beep(420,0.07,"triangle",0.05); }
  function sfxDeposit(){ chord([520,660,780],0.14,0.06,"triangle"); }
  function sfxError(){ beep(160,0.08,"sawtooth",0.06); }
  function sfxZeroBad(){ beep(120,0.10,"sawtooth",0.07); beep(90,0.12,"sawtooth",0.06); }
  function sfxBonus(){ chord([660,880],0.16,0.06,"triangle"); }
  function sfxExtraLife(){ chord([523,659,784],0.20,0.06,"triangle"); chord([659,784,988],0.22,0.06,"triangle"); }
  function sfxMonsterHit(){ beep(70,0.16,"sawtooth",0.08); beep(55,0.18,"sawtooth",0.08); }
  function sfxLevelUp(){
    chord([440,660,880],0.18,0.06,"triangle");
    chord([494,740,988],0.18,0.06,"triangle");
    chord([523,784,1046],0.22,0.06,"triangle");
  }
  function sfxWin(){
    chord([523,659,784],0.22,0.07,"triangle");
    chord([659,784,988],0.22,0.07,"triangle");
    chord([784,988,1175],0.26,0.07,"triangle");
  }

  const player = { name: "PLAYER1" };

  function sanitizeName(s){
    return (s || "").trim().replace(/\s+/g," ").slice(0,16);
  }
  function getSavedName(){
    const saved = localStorage.getItem(LS_PLAYER_NAME);
    const name = saved ? sanitizeName(saved).toUpperCase() : "";
    return name || "";
  }
  function setAndStoreName(name){
    const n = (sanitizeName(name) || "PLAYER1").toUpperCase();
    player.name = n;
    localStorage.setItem(LS_PLAYER_NAME, n);
    ui.player.textContent = n;
  }

  function getSavedSkin(){
    const raw = (localStorage.getItem(LS_PLAYER_SKIN) || "").toLowerCase();
    if (raw === "bighead" || raw === "alien") return "alien";
    if (raw === "runner" || raw === "sally") return "sally";
    if (raw === "rick") return "rick";
    if (raw === "robot") return "robot";
    return "classic";
  }
  function setAndStoreSkin(s){
    let val = (s || "classic").toLowerCase();
    if (val === "bighead") val = "alien";
    if (val === "runner") val = "sally";
    const allowed = ["classic","alien","sally","rick","robot"];
    const skin = allowed.includes(val) ? val : "classic";
    game.playerSkin = skin;
    localStorage.setItem(LS_PLAYER_SKIN, skin);
    if (ui.skin) ui.skin.value = skin;
  }

  const game = {
    level: 1,
    lives: 3,
    score: 0,
    actions: 0,

    bonusActive: false,
    bonusExtraRollReady: false,
    bonusPendingRoll: false,
    bonusMovesDoubled: false,

    playerSkin: "classic",

    playerX: 2,
    playerY: 2,
    carry: [],
    sticks: [],
    holeX: 12,
    holeY: 12,

    lifeTileX: -1,
    lifeTileY: -1,
    lifeTileUsed: false,

    treeX: -1,
    treeY: -1,
    treeActive: false,
    treePhase: "hidden",
    treePhaseTimer: 0,
    treeSpawnDelay: 0,
    treeSpawnedThisLevel: false,

    pendingMonster: null,
    monsterWinStreak: 0,

    hudMsg: "",
    hudTimer: 0,
    holePulse: 0,
    holeFlash: 0,
    sparks: [],

    inputLocked: false
  };

  function carryCap(){
    const base = Math.min(6, 3 + Math.floor((game.level - 1) / 3));
    return game.bonusActive ? (base + 2) : base;
  }

  function sticksToSpawnForLevel(level){
    return 6 + (level-1)*3;
  }

  function zeroChance(level){
    return Math.min(0.18, 0.00 + (level-1)*0.015);
  }
  function curseChance(level){
    return Math.min(0.16, 0.08 + (level-1)*0.015);
  }
  function bonusChance(level){
    return Math.min(0.22, 0.10 + (level-1)*0.01);
  }

  function setHud(msg){
    game.hudMsg = msg;
    game.hudTimer = 60;
  }

  function currentLevelTheme(){
    const idx = clamp(game.level - 1, 0, LEVELS.length - 1);
    return LEVELS[idx];
  }

  function applyThemeForLevel(){
    const t = currentLevelTheme();
    if (ui.themeMini) ui.themeMini.textContent = t.name;
    document.documentElement.style.setProperty("--lvlBg", t.bg);
    document.documentElement.style.setProperty("--lvlBorder", t.border);
    document.documentElement.style.setProperty("--lvlAccentGlow", t.accentGlow);
    document.documentElement.style.setProperty("--lvlAccentShadow", t.accentShadow);
  }

  function isOccupiedByStick(x,y){
    return game.sticks.some(s => s.x===x && s.y===y);
  }
  function isHole(x,y){ return x===game.holeX && y===game.holeY; }
  function isLifeTile(x,y){
    return !game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY;
  }
  function isTreeTile(x,y){
    return game.treeActive && x===game.treeX && y===game.treeY;
  }

  function randomEmptyTile(){
    for (let i=0;i<2000;i++){
      const x = randInt(0, GRID_W-1);
      const y = randInt(0, GRID_H-1);
      if ((x===game.playerX && y===game.playerY) || isHole(x,y) || isOccupiedByStick(x,y)) continue;
      if (!game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY) continue;
      if (game.treeActive && x===game.treeX && y===game.treeY) continue;
      return {x,y};
    }
    return {x:0,y:0};
  }

  function spawnHole(){
    if (game.level === 1){
      game.holeX = Math.floor(GRID_W/2);
      game.holeY = Math.floor(GRID_H/2);
      return;
    }
    game.holeX = randInt(6, GRID_W-7);
    game.holeY = randInt(6, GRID_H-7);
  }

  function spawnSticksForLevel(level){
    game.sticks = [];
    const n = sticksToSpawnForLevel(level);
    const cc = curseChance(level);
    const bc = bonusChance(level);

    for (let i=0;i<n;i++){
      const p = randomEmptyTile();
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      const cursed = Math.random() < cc;
      const bonus = !cursed && (Math.random() < bc);
      game.sticks.push({ x:p.x, y:p.y, color, cursed, bonus });
    }
    if (game.sticks.length > 0 && !game.sticks.some(s => s.cursed)){
      const idx = randInt(0, game.sticks.length - 1);
      game.sticks[idx].cursed = true;
      game.sticks[idx].bonus = false;
    }
  }

  function spawnLifeTile(){
    const p = randomEmptyTile();
    game.lifeTileX = p.x;
    game.lifeTileY = p.y;
    game.lifeTileUsed = false;
  }

  function clearTree(){
    game.treeActive = false;
    game.treePhase = "hidden";
    game.treePhaseTimer = 0;
    game.treeX = -1;
    game.treeY = -1;
  }

  function scheduleTreeForLevel(){
    clearTree();
    game.treeSpawnedThisLevel = false;
    game.treeSpawnDelay = 60 * randInt(60, 300); // 1‚Äì5 minutes
  }

  function spawnTreeNow(){
    const p = randomEmptyTile();
    game.treeX = p.x;
    game.treeY = p.y;
    game.treeActive = true;
    game.treePhase = "visible";
    game.treePhaseTimer = 60 * 15;
    game.treeSpawnedThisLevel = true;

    logEvent("bonus","A tree appears... (15s)");
    setHud("TREE APPEARS!");
  }

  function startTreeBlinking(){
    game.treePhase = "blinking";
    game.treePhaseTimer = 60 * 15;
    logEvent("warn","Tree is blinking... hurry!");
    setHud("TREE BLINKING!");
  }

  function endTree(){
    clearTree();
    logEvent("warn","The tree fades away.");
    setHud("TREE GONE");
  }

  function showNameModal(){
    game.inputLocked = true;
    ui.nameOverlay.style.display = "flex";
    ui.nameInput.value = "";
    ui.nameInput.placeholder = "ENTER NAME";

    const saved = getSavedName();
    if (saved && saved !== "PLAYER1"){
      ui.savedNameHint.style.display = "block";
      ui.savedNameHint.textContent = `Saved on this device: ${saved}`;
      ui.nameUseSavedBtn.style.display = "inline-block";
      ui.nameUseSavedBtn.textContent = `Use ${saved}`;
    }else{
      ui.savedNameHint.style.display = "none";
      ui.nameUseSavedBtn.style.display = "none";
    }

    gameSetTimeout(()=>ui.nameInput.focus(), 50);
  }
  function closeNameModal(){
    ui.nameOverlay.style.display = "none";
    game.inputLocked = false;
  }
  function startFromNameInput(){
    const entered = sanitizeName(ui.nameInput.value);
    if (!entered) setAndStoreName("PLAYER1");
    else setAndStoreName(entered);
    closeNameModal();
    newGame(true);
  }

  function resetCoreState(){
    game.level = 1;
    game.lives = 3;
    game.score = 0;
    game.actions = 0;

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    game.carry = [];
    game.sticks = [];
    game.sparks = [];
    game.holePulse = 0;
    game.holeFlash = 0;
    game.hudMsg = "";
    game.hudTimer = 0;

    game.playerX = 2;
    game.playerY = 2;

    game.lifeTileX = -1;
    game.lifeTileY = -1;
    game.lifeTileUsed = false;

    scheduleTreeForLevel();

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    game.monsterWinStreak = 0;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    spawnHole();
    spawnSticksForLevel(game.level);
    spawnLifeTile();

    if (ui.log) ui.log.innerHTML = "";
    if (ui.battleLog) ui.battleLog.innerHTML = "";
    logEvent("neutral","Welcome to STICKS.");
    logEvent("neutral","Roll to begin.");

    setAndStoreSkin(getSavedSkin());

    gameSetTimeout(updateScrollHint, 60);
  }

  function commitScoreToLeaderboard(){
    upsertLeaderboardEntry(player.name, game.score, game.level);
  }

  /* ‚úÖ overlay FX */
  function burstFx(el, emoji, count=26){
    if (!el) return;
    el.innerHTML = "";
    const w = el.clientWidth || 680;
    for (let i=0;i<count;i++){
      const s = document.createElement("span");
      s.textContent = emoji;
      s.style.left = randInt(0, w) + "px";
      s.style.top  = randInt(-20, 30) + "px";
      s.style.animationDuration = (1.2 + Math.random()*0.9) + "s";
      s.style.transform = `translateY(0) rotate(${randInt(0,180)}deg)`;
      el.appendChild(s);
    }
  }

  function winGame(){
    commitScoreToLeaderboard();

    burstFx(ui.winFx, "‚ú®", 34);

    ui.winText.textContent = `YOU WIN ‚Äî ${player.name}\nScore: ${game.score}\n\nThe sticks have been humbled. The hole is satisfied (for now).`;
    ui.winOverlay.style.display = "flex";
    game.inputLocked = true;

    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    setHud("VICTORY STICK!");
    logEvent("win","Victory Stick cleared. You win.");

    // extra fanfare sparks
    spawnSparks(game.holeX, game.holeY, 46, false);
    spawnSparks(game.playerX, game.playerY, 22, false);

    sfxWin();
    startCelebrationMusic(8500);
  }

  function newLevel(){
    if (game.level >= 9){
      winGame();
      updateUI();
      return;
    }

    game.level++;
    applyThemeForLevel();
    spawnHole();
    spawnSticksForLevel(game.level);
    spawnLifeTile();
    scheduleTreeForLevel();

    game.actions = 0;
    game.carry = [];

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    logEvent("level",`Level ${game.level}! (${currentLevelTheme().name})`);
    sfxLevelUp();
    setHud(`LEVEL ${game.level}!`);

    commitScoreToLeaderboard();
    updateUI();
  }

  function newGame(fresh=false){
    if (!fresh){
      showNameModal();
      return;
    }
    resetCoreState();
    applyThemeForLevel();
    updateUI();
    startLoop();
  }

  function canRoll(){
    if (game.inputLocked && !game.pendingMonster) return false;
    if (game.pendingMonster) return true;
    if (game.actions > 0) return false;
    return true;
  }

  function rollNormal(){
    const zc = zeroChance(game.level);
    if (Math.random() < zc) return 0;
    return randInt(1,5);
  }

  function rollBonus2d6(){
    const d1 = randInt(1,6);
    const d2 = randInt(1,6);
    return { total: d1 + d2, d1, d2 };
  }

  function doRoll(){
    if (!canRoll()){
      sfxError();
      setHud("Spend Actions first!");
      return;
    }

    ui.diceBox.classList.add("rolling");
    sfxRoll();

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      if (game.bonusActive){
        const r = rollBonus2d6();
        ui.diceFace.textContent = String(r.total);
        ui.diceLabel.textContent = `BONUS üé≤üé≤ (${r.d1}+${r.d2})`;

        game.bonusPendingRoll = false;
        game.bonusMovesDoubled = false;

        game.actions = r.total;
        logEvent("bonus",`Bonus roll: ${r.total}`);
        if (r.total === 12){
          game.bonusExtraRollReady = true;
          logEvent("bonus","Jackpot 12! Extra Bonus roll earned.");
          setHud("12! Extra Bonus roll earned!");
        } else {
          game.bonusExtraRollReady = false;
        }
      } else {
        const r = rollNormal();
        ui.diceFace.textContent = String(r);
        ui.diceLabel.textContent = `Normal üé≤ (0‚Äì5)`;

        if (r === 0){
          logEvent("bad","Rolled 0!");
          sfxZeroBad();
          handleZeroPenalty();
          game.actions = 0;
        } else {
          game.actions = r;
          logEvent("roll",`Rolled ${r}.`);
        }
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
    }, 260);
  }

  function scatterPositionAround(x,y, radius){
    for (let i=0;i<200;i++){
      const nx = clamp(x + randInt(-radius, radius), 0, GRID_W-1);
      const ny = clamp(y + randInt(-radius, radius), 0, GRID_H-1);
      if (isHole(nx,ny)) continue;
      if (isOccupiedByStick(nx,ny)) continue;
      if (nx===game.playerX && ny===game.playerY) continue;
      if (isLifeTile(nx,ny)) continue;
      if (isTreeTile(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    return randomEmptyTile();
  }

  function handleZeroPenalty(){
    if (game.carry.length > 0){
      const dropped = game.carry.splice(0, game.carry.length);
      dropped.forEach(st => {
        const p = scatterPositionAround(game.playerX, game.playerY, 3);
        game.sticks.push({ x:p.x, y:p.y, color: st.color, cursed:false, bonus:false });
      });
      logEvent("bad",`Zero! Dropped ${dropped.length} stick(s).`);
      setHud(`Zero! Dropped ${dropped.length}!`);
    } else {
      const p = scatterPositionAround(game.holeX, game.holeY, 3);
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      game.sticks.push({ x:p.x, y:p.y, color, cursed:false, bonus:false });
      logEvent("bad","Zero! Hole spits out a stick.");
      setHud("Hole spits out a stick!");
    }
    game.holeFlash = 1.0;
  }

  function onBonusStickPickup(){
    game.bonusPendingRoll = true;

    if (game.actions > 0){
      const before = game.actions;
      game.actions *= 2;
      game.bonusMovesDoubled = true;

      logEvent("bonus",`BONUS STICK! Actions doubled: ${before} ‚Üí ${game.actions}.`);
      setHud(`BONUS! ${before}‚Üí${game.actions} (Roll later)`);
      sfxBonus();
      updateUI();
      return;
    }

    game.bonusMovesDoubled = false;
    game.bonusActive = true;

    logEvent("bonus","BONUS STICK! No Actions left ‚Äî Bonus roll now!");
    setHud("BONUS ROLL NOW!");
    sfxBonus();
    updateUI();

    doRoll();
  }

  function promptBonusRollReady(){
    game.bonusActive = true;
    game.bonusMovesDoubled = false;

    ui.diceFace.textContent = "‚Äî";
    ui.diceLabel.textContent = "BONUS READY (2‚Äì12)";
    ui.btnRoll.classList.add("flashRoll");

    logEvent("bonus","Bonus roll ready! Press ROLL.");
    setHud("BONUS ROLL READY!");
    sfxBonus();
    updateUI();
  }

  function exitBonusIfDone(){
    if (game.actions === 0 && !game.bonusExtraRollReady){
      if (game.bonusActive){
        game.bonusActive = false;
        ui.btnRoll.classList.remove("flashRoll");
        logEvent("neutral","Bonus ended.");
        setHud("Bonus ended.");
      }
    }
  }

  function spendAction(){
    if (game.pendingMonster){
      sfxError();
      setHud("Fight the monster first! Press ROLL.");
      return false;
    }
    if (game.actions <= 0){
      sfxError();
      setHud("No Actions. Roll!");
      return false;
    }
    game.actions--;

    if (game.actions === 0){
      if (game.bonusPendingRoll && !game.bonusActive){
        promptBonusRollReady();
      } else {
        exitBonusIfDone();
      }
    }

    updateUI();
    return true;
  }

  function monsterStickValueForStreak(streak){
    if (streak <= 3) return 2;
    return Math.min(12, (streak - 1));
  }

  function resolveMonsterRoll(){
    const pending = game.pendingMonster;
    if (!pending) return;
    const index = pending.index;
    game.pendingMonster = null;

    ui.diceBox.classList.add("rolling");
    sfxRoll();
    logEvent("monster","Monster Stick! Rolling (0‚Äì5)...");

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      const roll = randInt(0,5);
      ui.diceFace.textContent = String(roll);
      ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";

      const s = game.sticks[index];
      stopMonsterDoom();

      if (roll <= 1){
        if (s && s.cursed){
          game.sticks.splice(index,1);
        }
        game.lives = Math.max(0, game.lives - 1);
        spawnSparks(game.playerX, game.playerY, 18, true);

        game.monsterWinStreak = 0;

        logEvent("monster","Monster wins! Lost 1 life. (Streak reset)");
        setHud("MONSTER WINS! -1 LIFE");

        // ‚úÖ new vibe: pac-man-ish death sting (instead of old doom)
        playPacmanDeathSting();

        if (game.lives <= 0){
          ui.monsterEvent.style.display = "none";
          ui.btnRoll.classList.remove("flashRoll");
          updateUI();
          game.inputLocked = false;
          game.pendingMonster = null;
          gameOver();
          return;
        }
      } else {
        game.monsterWinStreak++;
        const streak = game.monsterWinStreak;
        const mult = monsterStickValueForStreak(streak);

        if (s){
          game.sticks.splice(index,1);
          game.carry.push({ color: s.color, value: mult, fromMonster:true, streakAtWin: streak });
        }

        logEvent("bonus",`You beat the monster! Stick is worth ${mult}√ó. (Streak ${streak})`);
        setHud(`MONSTER BEATEN! ${mult}√ó STICK`);
        sfxPickup();
        startCelebrationMusic(6500);

        if (streak === 3){
          if (game.lives < MAX_LIVES){
            game.lives++;
            logEvent("bonus","3√ó Monster streak! +1 life.");
            setHud("+1 LIFE (3√ó STREAK)");
            sfxExtraLife();
            startCelebrationMusic(7500);
          } else {
            logEvent("bonus","3√ó Monster streak (already max lives).");
            setHud("3√ó STREAK (MAX LIVES)");
            startCelebrationMusic(6500);
          }
        }
      }

      ui.monsterEvent.style.display = "none";
      ui.btnRoll.classList.remove("flashRoll");
      game.inputLocked = false;
      updateUI();
      gameSetTimeout(updateScrollHint, 30);
    }, 260);
  }

  function move(dx,dy){
    if (game.inputLocked) return;
    if (!spendAction()) return;
    game.playerX = clamp(game.playerX + dx, 0, GRID_W-1);
    game.playerY = clamp(game.playerY + dy, 0, GRID_H-1);
    beep(220,0.03,"triangle",0.02);
    updateUI();
  }

  function pickOrDrop(){
    if (game.inputLocked) return;
    if (!spendAction()) return;

    if (isTreeTile(game.playerX, game.playerY)){
      // ‚úÖ Tree magic load (only disappears if NO ground sticks)
      if (game.carry.length === 0){
        const cap = carryCap();
        for (let i=0;i<cap;i++){
          const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
          game.carry.push({ color, value:1, fromMagic:true });
        }
        logEvent("bonus",`Tree magic! Instantly filled to ${cap}.`);
        setHud(`TREE LOAD (${cap})`);
        sfxPickup();

        // ‚úÖ NEW: if there are NO sticks left on the ground, tree goes away after giving full load
        if (game.sticks.length === 0){
          endTree();
        }

        updateUI();
        return;
      }

      // ‚úÖ feed tree: consume 1 carried stick
      game.carry.pop();

      if (game.lives < MAX_LIVES){
        game.lives++;
        logEvent("bonus","Fed the tree. +1 life.");
        setHud("+1 LIFE (TREE)");
        sfxExtraLife();
        startCelebrationMusic(6500);
      } else {
        // ‚úÖ NEW: max lives => bonus points since the life is blocked
        game.score += TREE_FEED_MAX_POINTS;
        logEvent("bonus",`Fed the tree (max lives). +${TREE_FEED_MAX_POINTS} points.`);
        setHud(`TREE FED (+${TREE_FEED_MAX_POINTS})`);
        sfxPickup();
        commitScoreToLeaderboard();
      }

      // ‚úÖ NEW: Tree disappears after you successfully feed it for a life (or points).
      endTree();

      // ‚úÖ If feeding the tree used the *last stick overall*, advance immediately
      if (game.sticks.length === 0 && game.carry.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
        return;
      }

      updateUI();
      return;
    }

    if (isHole(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        sfxError(); setHud("Nothing to deposit."); return;
      }
      const n = game.carry.length;
      let pts = 0;
      for (const st of game.carry){
        let v = st.value || 1;
        if (game.bonusActive) v *= 2;
        pts += v;
      }
      game.score += pts;
      game.carry = [];

      logEvent("deposit",`Deposited ${n} stick(s) (+${pts}).`);
      sfxDeposit();
      setHud(`+${pts} deposited!`);

      game.holePulse = 1.0;
      spawnSparks(game.holeX, game.holeY, 28);

      commitScoreToLeaderboard();

      if (game.sticks.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
      } else {
        updateUI();
      }
      return;
    }

    const idx = game.sticks.findIndex(s => s.x===game.playerX && s.y===game.playerY);
    if (idx >= 0){
      if (game.carry.length >= carryCap()){
        sfxError();
        const cap = carryCap();
        setHud(`MAX STICKS (${cap})`);
        logEvent("warn",`MAX STICKS (${cap}).`);
        return;
      }

      const s = game.sticks[idx];

      if (s.cursed){
        game.pendingMonster = { index: idx };
        game.inputLocked = true;

        logEvent("monster","Monster Stick! Press ROLL (0‚Äì5) to fight.");
        setHud("MONSTER STICK! PRESS ROLL");

        ui.diceFace.textContent = "?";
        ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";
        ui.monsterEventText.textContent =
          `Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a powered stick. Roll 0‚Äì1 and you lose 1 life. (Win streak carries across levels; resets only on a loss.)`;
        ui.monsterEvent.style.display = "flex";
        ui.btnRoll.classList.add("flashRoll");

        sfxMonsterHit();
        playMonsterDoomSting();
        updateUI();
        gameSetTimeout(updateScrollHint, 30);
        return;
      }

      game.sticks.splice(idx,1);
      game.carry.push({ color:s.color, value:1 });

      sfxPickup();

      if (s.bonus){
        onBonusStickPickup();
      }

      const cap = carryCap();
      if (game.carry.length === cap){
        logEvent("warn",`MAX LOAD (${cap}).`);
        setHud(`MAX LOAD (${cap})`);
      } else {
        logEvent("pickup",`Picked up a stick. (${game.carry.length}/${cap})`);
        setHud(`Picked up (${game.carry.length}/${cap})`);
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
      return;
    }

    if (game.carry.length > 0){
      if (isOccupiedByStick(game.playerX, game.playerY)){
        sfxError(); setHud("Tile already has a stick."); return;
      }

      if (isLifeTile(game.playerX, game.playerY)){
        game.carry.pop();
        game.lifeTileUsed = true;

        if (game.lives < MAX_LIVES){
          game.lives++;
          logEvent("bonus","Secret life tile! +1 life.");
          setHud("+1 LIFE");
          sfxExtraLife();
          startCelebrationMusic(6500);
        } else {
          // ‚úÖ NEW: max lives => bonus points
          game.score += LIFE_TILE_MAX_POINTS;
          logEvent("bonus",`Life tile found (max lives). +${LIFE_TILE_MAX_POINTS} points.`);
          setHud(`LIFE TILE (+${LIFE_TILE_MAX_POINTS})`);
          sfxPickup();
          commitScoreToLeaderboard();
        }

        spawnSparks(game.playerX, game.playerY, 18, false);
        updateUI();
        return;
      }

      const st = game.carry.pop();
      game.sticks.push({ x:game.playerX, y:game.playerY, color:st.color, cursed:false, bonus:false });
      sfxPlace();
      logEvent("place","Placed 1 stick.");
      setHud("Placed 1 stick.");
      updateUI();
      return;
    }

    sfxError();
    setHud("No stick here.");
  }

  function gameOver(){
    commitScoreToLeaderboard();

    burstFx(ui.loseFx, "ü™µ", 30);

    const taunts = [
      "The Stick Monster claps slowly. Loudly. Rudely.",
      "The sticks whisper: 'Skill issue.'",
      "The monster does a little dance. It‚Äôs disrespectful.",
      "The hole sighs. The monster cackles."
    ];
    const t = taunts[randInt(0, taunts.length-1)];

    ui.gameOverText.textContent = `GAME OVER ‚Äî ${player.name}\nScore: ${game.score} ‚Ä¢ Level: ${game.level}\n\n${t}`;
    ui.gameOverOverlay.style.display = "flex";
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();
    game.inputLocked = true;

    logEvent("bad", `Game Over. ${t}`);
    setHud("GAME OVER");

    // ‚úÖ extra visual punch
    spawnSparks(game.playerX, game.playerY, 26, true);
    spawnSparks(game.holeX, game.holeY, 16, true);

    // keep doom bed for game over (now pac-man-ish)
    startDoomMusic(8500);
  }

  function spawnSparks(gx,gy,count=18, evil=false){
    const cx = gx*TILE + TILE/2;
    const cy = gy*TILE + TILE/2;
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      game.sparks.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 24 + Math.random()*20, evil });
    }
  }

  function updateRollButtonState(){
    ui.btnRoll.disabled = (game.inputLocked && !game.pendingMonster) || (game.actions !== 0 && !game.pendingMonster);
  }

  function updateUI(){
    ui.player.textContent = player.name;
    ui.lives.textContent = String(game.lives);
    ui.level.textContent = String(game.level);
    ui.score.textContent = String(game.score);
    ui.actions.textContent = String(game.actions);

    const cap = carryCap();
    ui.carry.textContent = `${game.carry.length}/${cap}`;
    ui.left.textContent = String(game.sticks.length);

    let mode = "NORMAL";
    if (game.bonusActive) mode = game.bonusExtraRollReady ? "BONUS+" : "BONUS";
    else if (game.bonusPendingRoll) mode = "BONUS (PENDING)";
    ui.mode.textContent = mode;

    ui.die.textContent = game.bonusActive ? "2‚Äì12" : "0‚Äì5";

    updateRollButtonState();
  }

  function canSaveLoad(){
    if (ui.infoOverlay.style.display === "flex") return false;
    if (ui.nameOverlay.style.display === "flex") return false;
    if (ui.gameOverOverlay.style.display === "flex") return false;
    if (ui.winOverlay.style.display === "flex") return false;
    if (ui.pauseOverlay.style.display === "flex") return false;
    if (game.pendingMonster) return false;
    return true;
  }

  function serializeGame(){
    return {
      v: 2,
      when: Date.now(),
      playerName: player.name,
      playerSkin: game.playerSkin,
      game: {
        level: game.level,
        lives: game.lives,
        score: game.score,
        actions: game.actions,

        bonusActive: game.bonusActive,
        bonusExtraRollReady: game.bonusExtraRollReady,
        bonusPendingRoll: game.bonusPendingRoll,
        bonusMovesDoubled: game.bonusMovesDoubled,

        playerX: game.playerX,
        playerY: game.playerY,
        carry: game.carry,
        sticks: game.sticks,
        holeX: game.holeX,
        holeY: game.holeY,
        lifeTileX: game.lifeTileX,
        lifeTileY: game.lifeTileY,
        lifeTileUsed: game.lifeTileUsed,

        treeX: game.treeX,
        treeY: game.treeY,
        treeActive: game.treeActive,
        treePhase: game.treePhase,
        treePhaseTimer: game.treePhaseTimer,
        treeSpawnDelay: game.treeSpawnDelay,
        treeSpawnedThisLevel: game.treeSpawnedThisLevel,

        monsterWinStreak: game.monsterWinStreak,

        hudMsg: "",
        hudTimer: 0,
        holePulse: 0,
        holeFlash: 0
      }
    };
  }

  function applySerialized(obj){
    if (!obj || !obj.game) return false;

    setAndStoreName(obj.playerName || "PLAYER1");
    setAndStoreSkin(obj.playerSkin || getSavedSkin());

    const g = obj.game;
    game.level = clamp(Number(g.level)||1, 1, 9);
    game.lives = clamp(Number(g.lives)||3, 0, MAX_LIVES);
    game.score = Math.max(0, Number(g.score)||0);
    game.actions = Math.max(0, Number(g.actions)||0);

    game.bonusActive = !!g.bonusActive;
    game.bonusExtraRollReady = !!g.bonusExtraRollReady;
    game.bonusPendingRoll = !!g.bonusPendingRoll;
    game.bonusMovesDoubled = !!g.bonusMovesDoubled;

    game.playerX = clamp(Number(g.playerX)||2, 0, GRID_W-1);
    game.playerY = clamp(Number(g.playerY)||2, 0, GRID_H-1);

    game.carry = Array.isArray(g.carry) ? g.carry.slice(0, 12) : [];
    game.sticks = Array.isArray(g.sticks) ? g.sticks.map(s => ({
      x: clamp(Number(s.x)||0, 0, GRID_W-1),
      y: clamp(Number(s.y)||0, 0, GRID_H-1),
      color: String(s.color || "#f3f4f6"),
      cursed: !!s.cursed,
      bonus: !!s.bonus
    })) : [];

    game.holeX = clamp(Number(g.holeX)||12, 0, GRID_W-1);
    game.holeY = clamp(Number(g.holeY)||12, 0, GRID_H-1);

    game.lifeTileX = clamp(Number(g.lifeTileX)||-1, -1, GRID_W-1);
    game.lifeTileY = clamp(Number(g.lifeTileY)||-1, -1, GRID_W-1);
    game.lifeTileUsed = !!g.lifeTileUsed;

    game.treeX = clamp(Number(g.treeX)||-1, -1, GRID_W-1);
    game.treeY = clamp(Number(g.treeY)||-1, -1, GRID_W-1);
    game.treeActive = !!g.treeActive;
    game.treePhase = String(g.treePhase || (game.treeActive ? "visible" : "hidden"));
    game.treePhaseTimer = Math.max(0, Number(g.treePhaseTimer)||0);
    game.treeSpawnDelay = Math.max(0, Number(g.treeSpawnDelay)||0);
    game.treeSpawnedThisLevel = !!g.treeSpawnedThisLevel;

    game.monsterWinStreak = Math.max(0, Number(g.monsterWinStreak)||0);

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    game.inputLocked = false;
    applyThemeForLevel();
    updateUI();
    setHud("Game loaded!");
    return true;
  }

  function saveGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't save right now.");
      logEvent("warn","Can't save during overlays or monster encounter.");
      return;
    }
    try{
      localStorage.setItem(LS_SAVEGAME, JSON.stringify(serializeGame()));
      logEvent("save","Game saved (this device).");
      setHud("GAME SAVED");
      chord([262,330,392],0.16,0.05,"triangle");
    }catch(_){
      sfxError();
      setHud("Save failed.");
    }
  }

  function loadGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't load right now.");
      logEvent("warn","Can't load during overlays or monster encounter.");
      return;
    }
    try{
      const raw = localStorage.getItem(LS_SAVEGAME);
      if (!raw){
        sfxError();
        setHud("No saved game.");
        logEvent("load","No saved game found.");
        return;
      }
      const obj = JSON.parse(raw);
      const ok = applySerialized(obj);
      if (ok){
        logEvent("load","Game loaded.");
        chord([294,370,440],0.16,0.05,"triangle");
      } else {
        sfxError();
        setHud("Load failed.");
      }
    }catch(_){
      sfxError();
      setHud("Load failed.");
    }
  }

  /* ---- Drawing ---- */
  function drawGrid(theme){
    ctx.fillStyle = theme.bg;
    ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

    // base grid stroke
    ctx.strokeStyle = theme.grid;
    ctx.lineWidth = 1;

    // opacity tuning
    if (theme.name === "Ice Stick") ctx.globalAlpha = 0.58;
    else if (theme.name === "Glow Stick" || theme.name === "Victory Stick") ctx.globalAlpha = 0.62;
    else ctx.globalAlpha = 0.55;

    // ‚úÖ neon glow pass for Glow/Victory/Ice
    const wantsNeon = (theme.name === "Glow Stick" || theme.name === "Victory Stick" || theme.name === "Ice Stick");
    if (wantsNeon){
      ctx.save();
      ctx.shadowColor = theme.grid;
      ctx.shadowBlur = (theme.name === "Ice Stick") ? 6 : 10;
      ctx.globalAlpha = (theme.name === "Ice Stick") ? 0.16 : 0.18;
      ctx.lineWidth = 2;
      for (let x=0;x<=GRID_W;x++){
        ctx.beginPath();
        ctx.moveTo(x*TILE + 0.5, 0);
        ctx.lineTo(x*TILE + 0.5, CANVAS_H);
        ctx.stroke();
      }
      for (let y=0;y<=GRID_H;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*TILE + 0.5);
        ctx.lineTo(CANVAS_W, y*TILE + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    // crisp pass
    for (let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE + 0.5, 0);
      ctx.lineTo(x*TILE + 0.5, CANVAS_H);
      ctx.stroke();
    }
    for (let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE + 0.5);
      ctx.lineTo(CANVAS_W, y*TILE + 0.5);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawHole(theme){
    const cx = game.holeX*TILE + TILE/2;
    const cy = game.holeY*TILE + TILE/2;

    if (game.holePulse > 0) game.holePulse = Math.max(0, game.holePulse - 0.03);
    if (game.holeFlash > 0) game.holeFlash = Math.max(0, game.holeFlash - 0.04);

    const pulse = game.holePulse;
    const flash = game.holeFlash;

    ctx.save();

    if (pulse > 0){
      ctx.globalAlpha = 0.20 + pulse*0.55;
      ctx.fillStyle = theme.accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + pulse*12, 0, Math.PI*2);
      ctx.fill();
    }

    if (flash > 0){
      ctx.globalAlpha = 0.25 + flash*0.55;
      ctx.fillStyle = "#ff1f3a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + flash*10, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;
    ctx.lineWidth = 3;
    ctx.strokeStyle = (theme.name === "Ice Stick") ? "#1f2a37" : "#f3f4f6";

    ctx.beginPath();
    ctx.arc(cx, cy, 16 + pulse*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.fillStyle = "#000000";
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    ctx.arc(cx, cy, 8 + pulse*2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawLifeHint(theme){
    if (game.lifeTileUsed) return;
    if (game.carry.length <= 0) return;
    if (game.playerX !== game.lifeTileX || game.playerY !== game.lifeTileY) return;

    const x = game.lifeTileX*TILE;
    const y = game.lifeTileY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*4) + 1) / 2;

    ctx.save();
    ctx.globalAlpha = 0.15 + osc*0.25;
    ctx.strokeStyle = theme.accent;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x+3, y+3, TILE-6, TILE-6);
    ctx.stroke();
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawTree(theme){
    if (!game.treeActive) return;

    if (game.treePhase === "blinking"){
      const blinkOn = (Math.floor(game.treePhaseTimer / 10) % 2) === 0;
      if (!blinkOn) return;
    }

    const x = game.treeX*TILE;
    const y = game.treeY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*5) + 1) / 2;

    ctx.save();

    ctx.globalAlpha = 0.10 + osc*0.18;
    ctx.strokeStyle = "#39ff95";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x + TILE/2, y + TILE/2, 10 + osc*3, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#a16207";
    ctx.fillRect(x + 11, y + 12, 2, 7);
    ctx.fillRect(x + 10, y + 14, 4, 5);

    ctx.fillStyle = "#22c55e";
    ctx.fillRect(x + 8,  y + 8,  8, 2);
    ctx.fillRect(x + 7,  y + 10, 10, 2);
    ctx.fillRect(x + 8,  y + 12, 8, 2);

    ctx.globalAlpha = 0.35 + osc*0.35;
    ctx.fillStyle = theme.accent;
    ctx.fillRect(x + 6, y + 6, 1, 1);
    ctx.fillRect(x + 17, y + 7, 1, 1);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawStick(s){
    const x = s.x*TILE;
    const y = s.y*TILE;
    ctx.save();
    ctx.translate(x + TILE/2, y + TILE/2);

    if (currentLevelTheme().name === "Ice Stick"){
      ctx.shadowColor = "rgba(0,0,0,0.25)";
      ctx.shadowBlur = 6;
    }

    ctx.strokeStyle = s.color;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(-6, -8);
    ctx.lineTo(7, 9);
    ctx.stroke();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-4, -6);
    ctx.lineTo(5, 7);
    ctx.stroke();
    ctx.globalAlpha = 1;

    if (s.bonus){
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#ffd166";
      ctx.beginPath();
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function roundRect(c, x, y, w, h, r){
    c.beginPath();
    c.moveTo(x+r, y);
    c.arcTo(x+w, y, x+w, y+h, r);
    c.arcTo(x+w, y+h, x, y+h, r);
    c.arcTo(x, y+h, x, y, r);
    c.arcTo(x, y, x+w, y, r);
    c.closePath();
  }

  function drawPlayer(){
    const cx = game.playerX*TILE + TILE/2;
    const cy = game.playerY*TILE + TILE/2;

    ctx.save();
    ctx.translate(cx, cy);

    const theme = currentLevelTheme();
    const strokeBase = (theme.name === "Ice Stick") ? "#0b0f14" : "#f3f4f6";
    ctx.strokeStyle = strokeBase;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";

    const skin = game.playerSkin || "classic";

    const drawCarryDots = () => {
      const cap = carryCap();
      const carried = game.carry.length;
      const slots = Math.min(6, cap);
      const startX = -((slots-1)*4)/2;
      const isFull = carried >= cap;

      for (let i=0;i<slots;i++){
        ctx.beginPath();
        const filled = i < carried;
        if (isFull){
          ctx.fillStyle = filled ? "#ff1f3a" : "rgba(255,31,58,0.25)";
        } else {
          ctx.fillStyle = filled ? "#ffd166" : "rgba(243,244,246,0.18)";
        }
        ctx.arc(startX + i*4, 17, 1.5, 0, Math.PI*2);
        ctx.fill();
      }
    };

    const drawClassicBody = () => {
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    };

    if (skin === "alien"){
      ctx.beginPath();
      ctx.arc(0, -7, 7, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, -14);
      ctx.lineTo(-6, -19);
      ctx.moveTo(3, -14);
      ctx.lineTo(6, -19);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = "#ffd166";
      ctx.arc(-6, -20, 1.6, 0, Math.PI*2);
      ctx.arc(6, -20, 1.6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = strokeBase;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 3);
      ctx.lineTo(7, 1);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "sally"){
      ctx.beginPath();
      ctx.arc(0, -8, 4.5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(-7, 9);
      ctx.lineTo(7, 9);
      ctx.closePath();
      ctx.fillStyle = strokeBase;
      ctx.globalAlpha = 0.16;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = strokeBase;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(-11, 4);
      ctx.moveTo(7, 2);
      ctx.lineTo(11, 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, 9);
      ctx.lineTo(-6, 13);
      ctx.moveTo(3, 9);
      ctx.lineTo(6, 13);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rick"){
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-4, -11);
      ctx.lineTo(-2, -14);
      ctx.moveTo(-1, -11);
      ctx.lineTo(1, -15);
      ctx.moveTo(2, -11);
      ctx.lineTo(4, -14);
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(-4, -9, 3, 3);
      ctx.rect(1, -9, 3, 3);
      ctx.moveTo(-1, -7.5);
      ctx.lineTo(1, -7.5);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "robot"){
      ctx.beginPath();
      ctx.rect(-5, -12, 10, 10);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, -12);
      ctx.lineTo(0, -16);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(0, -17, 1.2, 0, Math.PI*2);
      ctx.fillStyle = "#ffd166";
      ctx.fill();

      ctx.strokeStyle = strokeBase;

      ctx.beginPath();
      ctx.moveTo(0, -2);
      ctx.lineTo(0, 10);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(7, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 10);
      ctx.lineTo(-6, 16);
      ctx.moveTo(0, 10);
      ctx.lineTo(6, 16);
      ctx.stroke();

      drawCarryDots();
    }
    else {
      drawClassicBody();
    }

    if (game.bonusActive){
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "#ffd166";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 2, 16, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawSparks(){
    for (let i=game.sparks.length-1;i>=0;i--){
      const p = game.sparks[i];
      p.x += p.vx; p.y += p.vy;
      p.vx *= 0.96; p.vy *= 0.96;
      p.life -= 1;

      ctx.globalAlpha = Math.max(0, p.life/44);
      ctx.fillStyle = p.evil ? "#ff1f3a" : "#39ff95";
      ctx.fillRect(p.x, p.y, 2, 2);

      if (p.life <= 0) game.sparks.splice(i,1);
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(){
    if (game.hudTimer > 0){
      game.hudTimer--;
      const t = game.hudTimer;

      ctx.save();
      ctx.globalAlpha = Math.min(1, t/14);

      ctx.fillStyle = "rgba(11,18,32,0.85)";
      ctx.strokeStyle = "#2b3a4c";
      ctx.lineWidth = 2;

      const w = Math.min(420, 18 + game.hudMsg.length*10);
      const x = CANVAS_W/2 - w/2;
      const y = 14;

      roundRect(ctx, x, y, w, 34, 10);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = "#e6edf3";
      ctx.font = "bold 14px ui-monospace, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(game.hudMsg, CANVAS_W/2, y+17);

      ctx.restore();
    }
  }

  function loop(){
    const freezeTree = !!game.pendingMonster;

    if (!freezeTree){
      if (!game.treeSpawnedThisLevel && !game.treeActive){
        game.treeSpawnDelay = Math.max(0, game.treeSpawnDelay - 1);
        if (game.treeSpawnDelay === 0){
          spawnTreeNow();
        }
      }

      if (game.treeActive){
        game.treePhaseTimer = Math.max(0, game.treePhaseTimer - 1);
        if (game.treePhaseTimer === 0){
          if (game.treePhase === "visible"){
            startTreeBlinking();
          } else if (game.treePhase === "blinking"){
            endTree();
          }
        }
      }
    }

    // ‚úÖ Victory level pulse now purple (not white)
    if (game.level === 9){
      const t = (performance.now()||Date.now())/1000;
      const pulse = (Math.sin(t*2.2)+1)/2;
      const border = `rgba(122,53,255,${0.70 + pulse*0.30})`;
      document.documentElement.style.setProperty("--lvlBorder", border);
      document.documentElement.style.setProperty("--lvlAccentGlow", `rgba(194,123,255,${0.34 + pulse*0.30})`);
      document.documentElement.style.setProperty("--lvlAccentShadow", `rgba(194,123,255,${0.18 + pulse*0.18})`);
    }

    const theme = currentLevelTheme();
    drawGrid(theme);
    drawHole(theme);
    drawLifeHint(theme);
    drawTree(theme);
    for (const s of game.sticks) drawStick(s);
    drawPlayer();
    drawSparks();
    drawHUD();

    rafId = requestAnimationFrame(loop);
  }

  function keyHandler(e){
    const inInfo  = ui.infoOverlay.style.display === "flex";
    const inName  = ui.nameOverlay.style.display === "flex";
    const inOver  = ui.gameOverOverlay.style.display === "flex";
    const inWin   = ui.winOverlay.style.display === "flex";
    const inPause = ui.pauseOverlay.style.display === "flex";

    if (inPause){
      if (e.key === "Escape" || e.key === "Enter" || e.key === " "){
        e.preventDefault();
        resumeGame();
      }
      return;
    }

    if (inName){
      if (e.key === "Enter"){ e.preventDefault(); startFromNameInput(); }
      else if (e.key === "Escape"){
        e.preventDefault();
        setAndStoreName("PLAYER1");
        closeNameModal();
        newGame(true);
      }
      return;
    }

    if (!inInfo && !inOver && !inWin && (e.key === "Escape" || e.key.toLowerCase() === "p")){
      e.preventDefault();
      togglePause();
      return;
    }

    if (inInfo || inOver || inWin) return;

    if (game.pendingMonster){
      if (e.key === "Enter" || e.key === " "){
        e.preventDefault();
        resolveMonsterRoll();
      }
      return;
    }

    if (game.inputLocked) return;

    if (e.key === "ArrowUp"){ e.preventDefault(); move(0,-1); }
    else if (e.key === "ArrowDown"){ e.preventDefault(); move(0,1); }
    else if (e.key === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if (e.key === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if (e.key === " "){ e.preventDefault(); pickOrDrop(); }
    else if (e.key.toLowerCase() === "s"){ e.preventDefault(); saveGame(); }
    else if (e.key.toLowerCase() === "l"){ e.preventDefault(); loadGame(); }
  }
  document.addEventListener("keydown", keyHandler);

  /* ---- Button handlers ---- */
  ui.btnRoll.addEventListener("click", async () => {
    await unlockAudio();
    if (paused) return;
    if (game.pendingMonster){ resolveMonsterRoll(); return; }
    if (game.bonusActive) ui.btnRoll.classList.remove("flashRoll");
    doRoll();
  });

  ui.btnUse.addEventListener("click", async () => { await unlockAudio(); if (paused) return; pickOrDrop(); });
  ui.btnNew.addEventListener("click", async () => { await unlockAudio(); if (paused) return; showNameModal(); });

  ui.btnPause.addEventListener("click", async () => {
    await unlockAudio();
    togglePause();
  });
  ui.btnPauseClose.addEventListener("click", async () => {
    await unlockAudio();
    if (paused) resumeGame();
  });

  ui.btnMusic.addEventListener("click", async () => {
    await unlockAudio();
    if (paused) return;

    musicOn = !musicOn;
    ui.btnMusic.textContent = `Music: ${musicOn ? "ON" : "OFF"}`;

    if (musicOn){
      startMusic();
      logEvent("neutral","Music ON.");
      setHud("MUSIC ON");
    } else {
      stopMusic();
      celebrationUntil = 0;
      doomUntil = 0;
      logEvent("neutral","Music OFF.");
      setHud("MUSIC OFF");
    }
  });

  ui.btnInfo.addEventListener("click", async () => {
    await unlockAudio();
    if (paused) return;
    ui.infoOverlay.style.display = "flex";
  });
  ui.btnInfoClose.addEventListener("click", async () => {
    await unlockAudio();
    ui.infoOverlay.style.display = "none";
  });

  ui.nameStartBtn.addEventListener("click", async () => { await unlockAudio(); startFromNameInput(); });
  ui.nameUseP1Btn.addEventListener("click", async () => {
    await unlockAudio();
    setAndStoreName("PLAYER1");
    closeNameModal();
    newGame(true);
  });
  ui.nameUseSavedBtn.addEventListener("click", async () => {
    await unlockAudio();
    const saved = getSavedName() || "PLAYER1";
    setAndStoreName(saved);
    closeNameModal();
    newGame(true);
  });

  ui.btnRestart.addEventListener("click", async () => {
    await unlockAudio();
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    showNameModal();
  });
  ui.btnGameOverClose.addEventListener("click", async () => {
    await unlockAudio();
    ui.gameOverOverlay.style.display = "none";
    // stays locked until restart/new game, by design
  });

  ui.btnWinRestart.addEventListener("click", async () => {
    await unlockAudio();
    ui.winOverlay.style.display = "none";
    game.inputLocked = false;
    showNameModal();
  });

  ui.btnSave.addEventListener("click", async () => { await unlockAudio(); if (paused) return; saveGame(); });
  ui.btnLoad.addEventListener("click", async () => { await unlockAudio(); if (paused) return; loadGame(); });

  ui.btnUp.addEventListener("click", async () => { await unlockAudio(); if (paused) return; move(0,-1); });
  ui.btnDown.addEventListener("click", async () => { await unlockAudio(); if (paused) return; move(0,1); });
  ui.btnLeft.addEventListener("click", async () => { await unlockAudio(); if (paused) return; move(-1,0); });
  ui.btnRight.addEventListener("click", async () => { await unlockAudio(); if (paused) return; move(1,0); });

  ui.skin.addEventListener("change", () => {
    setAndStoreSkin(ui.skin.value);
    setHud("SKIN SET");
    logEvent("neutral", `Stick figure: ${ui.skin.value.toUpperCase()}`);
  });

  // click outside overlay closes info only (not name/pause/gameover/win)
  ui.infoOverlay.addEventListener("click", (e) => {
    if (e.target === ui.infoOverlay) ui.infoOverlay.style.display = "none";
  });

  // init
  renderLeaderboard(loadLeaderboard());
  setAndStoreSkin(getSavedSkin());

  // get the board drawn immediately, then ask for name on open (front-end start)
  resetCoreState();
  applyThemeForLevel();
  updateUI();
  startLoop();
  showNameModal();

})();
</script>
</body>
</html>
