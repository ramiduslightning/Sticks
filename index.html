<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>STICKS</title>
  <style>
    :root{ color-scheme: dark; }

    body{
      margin:0;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      background:#0b0f14;
      color:#e6edf3;
    }

    .wrap{
      max-width: 1320px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 260px 1fr 420px;
      gap:14px;
      align-items:start;
    }

    .gameWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
    }

    canvas{
      width:100%;
      height:auto;
      border:2px solid var(--lvlBorder, #1f2a37);
      border-radius:12px;
      image-rendering: pixelated;
      background: var(--lvlBg, #070a0e);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15), 0 18px 50px rgba(0,0,0,.35);
      display:block;
      aspect-ratio: 1 / 1;
    }

    .panel{
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:12px;
      padding:12px;
    }

    .panelSticky{
      position: sticky;
      top: 14px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      padding-right: 10px;
    }

    .title{
      font-weight:1000;
      letter-spacing:.6px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }

    .subtitle{
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
      margin-top:6px;
    }

    .hr{ height:1px; background:#1f2a37; margin:10px 0; }

    .log{
      height: 600px;
      overflow:auto;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
      line-height:1.45;
    }
    .log .line{ margin: 0 0 8px 0; }
    .log .line:last-child{ margin-bottom:0; }

    .kv{ display:flex; justify-content:space-between; gap:10px; margin:6px 0; align-items:center; }
    .kv span:first-child{ color:#9fb1c6; }
    .big{ font-size:18px; font-weight:1000; }

    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      font-weight:1000;
      font-size:12px;
      user-select:none;
    }

    .playerArcade{
      font-size:22px;
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      text-shadow: 0 0 18px rgba(120,180,255,0.18);
      user-select:none;
    }

    .controlsTop{
      display:grid;
      grid-template-columns: 132px 1fr;
      gap:12px;
      align-items:center;
    }

    .diceBox{
      width:132px;
      height:132px;
      border-radius:16px;
      border:2px solid #2b3a4c;
      background: radial-gradient(120px 120px at 40% 35%, #1a2a3c 0%, #0b1220 70%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .diceGlow{
      position:absolute;
      inset:-40px;
      background: conic-gradient(from 180deg,
        rgba(0,0,0,0),
        rgba(0,0,0,0),
        var(--lvlAccentGlow, rgba(58,167,255,.32)),
        rgba(0,0,0,0)
      );
      opacity:0;
      filter: blur(10px);
      transform: rotate(0deg);
      pointer-events:none;
    }
    .rolling .diceGlow{ opacity:1; animation: spin .32s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .diceFace{
      font-size:52px;
      font-weight:1000;
      line-height:1;
      text-shadow: 0 0 16px var(--lvlAccentShadow, rgba(58,167,255,.25));
      user-select:none;
    }
    .diceLabel{
      margin-top:8px;
      font-size:12px;
      color:#9fb1c6;
      text-align:center;
      line-height:1.25;
      user-select:none;
    }

    .dpadWrap{ margin-top:10px; display:flex; justify-content:center; align-items:center; }
    .dpad{ width:200px; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .dpad button{
      padding:10px 0;
      border-radius:12px;
      color:#e6edf3;
      background: linear-gradient(180deg,#1b2432,#0b1220);
      border:1px solid #2b3a4c;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.10),
        0 8px 18px rgba(0,0,0,.35);
      font-weight:1000;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      text-shadow: 0 0 14px rgba(255,255,255,0.08);
    }
    .dpad button:hover{ filter: brightness(1.08); }
    .dpad button:active{ transform: translateY(1px); }
    .dpad .empty{ visibility:hidden; }

    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-top:10px;
    }

    button{
      cursor:pointer;
      border:0;
      padding:11px 10px;
      border-radius:12px;
      font-weight:1000;
      letter-spacing:.2px;
      user-select:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.08); }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; }

    .btn-roll { background: linear-gradient(180deg,#3aa7ff,#1172ff); color:#061018; }
    .btn-roll.ready-to-roll {
      animation: glowRoll 2s ease-in-out infinite;
      position: relative;
    }
    @keyframes glowRoll {
      0%, 100% { box-shadow: 0 0 0 1px rgba(58,167,255,0.5), 0 0 8px rgba(58,167,255,0.3), 0 6px 18px rgba(0,0,0,.25); }
      50% { box-shadow: 0 0 0 1px rgba(58,167,255,0.9), 0 0 16px rgba(58,167,255,0.6), 0 6px 20px rgba(0,0,0,.3); }
    }
    .btn-use  { background: linear-gradient(180deg,#39ff95,#08c46b); color:#061018; }
    .btn-new  { background: linear-gradient(180deg,#ffb347,#ff7a18); color:#1a0f00; }
    .btn-clear{ background: linear-gradient(180deg,#ff5a6a,#ff1f3a); color:#200007; }

    .btn-save { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }
    .btn-load { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }

    .btn-music{ background: linear-gradient(180deg,#c27bff,#7a35ff); color:#120018; grid-column: 1 / span 2; }
    .btn-info { background: linear-gradient(180deg,#f3f4f6,#cbd5e1); color:#0b0f14; }

    .titleBtns{ display:flex; align-items:center; gap:8px; }
    .btn-mini{
      padding:8px 10px;
      border-radius:12px;
      font-weight:1000;
      box-shadow:none;
      min-width:44px;
      line-height:1;
    }

    @keyframes flashRoll {
      0%   { box-shadow: 0 0 0 0 rgba(255,255,255,0.0); transform: translateY(0); }
      100% { box-shadow: 0 0 0 3px rgba(255,255,255,0.75); transform: translateY(-1px); }
    }
    .flashRoll{ animation: flashRoll 0.55s ease-in-out infinite alternate; }

    .monsterEvent{
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #ff1f3a;
      background:#1a0509;
      display:flex;
      gap:8px;
      align-items:flex-start;
      font-size:12px;
      line-height:1.35;
    }
    .monsterEventIcon{ font-size:20px; margin-top:2px; }
    .monsterEventTitle{ font-weight:1000; color:#ffb347; margin-bottom:3px; }

    .statsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #1f2a37;
      background:#0b1220;
    }
    .statsGrid .kv{ margin:0; }
    .statsGrid .big{ font-size:16px; }

    .leaderboard{
      margin-top:10px;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
    }
    .leaderRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 6px;
      border-radius:10px;
    }
    .leaderRow:nth-child(odd){ background: rgba(255,255,255,0.03); }
    .leaderName{ font-weight:1000; letter-spacing:.3px; }
    .leaderMeta{ color:#9fb1c6; }
    .gold { color:#ffd166; }
    .silver { color:#cbd5e1; }
    .bronze { color:#ffb347; }

    .battleFeedWrap{
      margin-top:10px;
      border:1px solid #1f2a37;
      border-radius:12px;
      background:#0b1220;
      padding:10px;
    }
    .battleFeedHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
    }
    .battleFeedHeader b{ letter-spacing:.4px; }
    .battleLog{
      max-height: 220px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      border-radius:10px;
      border:1px solid #1f2a37;
      padding:10px;
      background:#070c16;
      font-size:12px;
      line-height:1.45;
    }

    .scrollHint{
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px dashed #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.25;
      text-align:center;
      user-select:none;
    }
    .scrollHint .arrow{
      display:inline-block;
      font-weight:1000;
      margin-left:6px;
      animation: bob 1.1s ease-in-out infinite;
    }
    @keyframes bob{
      0%,100%{ transform: translateY(0); opacity:.75; }
      50%{ transform: translateY(2px); opacity:1; }
    }

    /* ‚úÖ stick figure selector */
    select{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      cursor:pointer;
    }
    select:focus{ box-shadow: 0 0 0 3px rgba(58,167,255,0.18); }

    #infoOverlay,#nameOverlay,#gameOverOverlay,#winOverlay,#pauseOverlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.72);
      z-index:9999;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .modalBox{
      width:min(780px,94vw);
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:16px;
      padding:16px;
      max-height: calc(var(--vh, 1vh) * 92);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    .modalTitle{ font-weight:1000; letter-spacing:.8px; font-size:18px; }
    .modalText{
      color:#cdd9e5;
      font-size:13px;
      line-height:1.45;
      margin-top:8px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 6px;
      white-space: pre-wrap;
    }
    .modalActions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:14px;
      flex-wrap:wrap;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(15,23,32,0.0), rgba(15,23,32,0.88) 30%, rgba(15,23,32,1));
      padding-top: 10px;
    }
    .modalClose{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      box-shadow:none;
    }

    /* ‚úÖ Win/Lose presentation */
    .endBanner{
      margin-top:10px;
      border-radius:14px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      overflow:hidden;
      position:relative;
    }
    .endBanner .bigIcon{
      font-size:34px;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.12));
      animation: pop 0.9s ease-in-out infinite alternate;
      user-select:none;
    }
    @keyframes pop { from{ transform: translateY(0) scale(1); } to{ transform: translateY(-2px) scale(1.04); } }

    .endBanner .endHeadline{
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      font-size:14px;
    }
    .endBanner .endSub{
      color:#9fb1c6;
      font-size:12px;
      margin-top:4px;
      line-height:1.25;
    }

    .fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .fx span{
      position:absolute;
      font-size:14px;
      opacity:0.9;
      animation: drift 1.6s linear forwards;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.10));
      user-select:none;
    }
    @keyframes drift{
      from{ transform: translateY(0) rotate(0deg); opacity:0.95; }
      to{ transform: translateY(140px) rotate(180deg); opacity:0; }
    }

    .winBanner{
      border-color: rgba(194,123,255,0.65);
      background: radial-gradient(340px 140px at 35% 25%, rgba(194,123,255,0.22) 0%, rgba(7,12,22,1) 65%);
    }
    .loseBanner{
      border-color: rgba(255,90,106,0.7);
      background: radial-gradient(340px 140px at 35% 25%, rgba(255,31,58,0.20) 0%, rgba(7,12,22,1) 65%);
    }

    #nameOverlay input{
      flex:1;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      font-size:16px;
      letter-spacing:.6px;
      text-transform: uppercase;
    }
    .saveBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #39ff95;
      background: linear-gradient(180deg,#39ff95,#08c46b);
      color:#061018;
      font-weight:1000;
      box-shadow:none;
    }
    .altBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#f3f4f6,#cbd5e1);
      color:#0b0f14;
      font-weight:1000;
      box-shadow:none;
    }
    .warnBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #ff5a6a;
      background: linear-gradient(180deg,#ff5a6a,#ff1f3a);
      color:#200007;
      font-weight:1000;
      box-shadow:none;
    }
    .hintRow{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
    }

    @media (max-width:1200px){
      .wrap{ grid-template-columns:1fr; }
      .log{ height:220px; }
      .controlsTop{ grid-template-columns:1fr; }
      .diceBox{ width:100%; height:120px; }
      .dpad{ width:100%; max-width:240px; }
      .panelSticky{ position: static; max-height: none; overflow: visible; padding-right:12px; }
    }

    @media (max-width:720px){
      .wrap > .panel:first-child{ display:none; }

      body{
        height: calc(var(--vh, 1vh) * 100);
        overflow:hidden;
      }

      .wrap{
        height: calc(var(--vh, 1vh) * 100);
        max-width:none;
        margin:0;
        padding:10px;
        gap:10px;
        grid-template-columns: 1fr;
        grid-template-rows: 1.35fr 1fr;
        align-items:stretch;
      }

      .gameWrap{
        height:100%;
        min-height:0;
      }

      canvas{
        width:auto;
        height:100%;
        max-width:100%;
        max-height:100%;
      }

      .panel-right{
        height:100%;
        min-height:0;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        display:flex;
        flex-direction:column;
        padding-bottom: calc(env(safe-area-inset-bottom) + 90px);
      }

      .controlsScroll{ order:1; }
      .headerBlock{ order:2; margin-top:10px; }
      .headerBlock .hr{ margin:10px 0 0 0; }

      .controlsTop{
        grid-template-columns: 1fr;
        gap:8px;
        margin-top:2px;
      }
      .controlsTop .subtitle{ display:none; }

      .diceBox{
        width:100%;
        height:84px;
        border-radius:14px;
      }
      .diceFace{ font-size:40px; }
      .diceLabel{ font-size:11px; margin-top:4px; }

      .controlsScroll{
        overflow: visible;
        -webkit-overflow-scrolling: auto;
        min-height:auto;
        padding-right:0;
        flex: 0 0 auto;
      }

      .battleFeedWrap{ display:block; }
    }

    @media (min-width:721px){
      .battleFeedWrap{ display:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="title"><div>Activity</div><span class="badge" id="uiThemeMini">Night Stick</span></div>
      <div class="subtitle">Latest on top. Color = importance.</div>
      <div class="hr"></div>
      <div class="log" id="log"></div>
    </div>

    <div class="gameWrap">
      <canvas id="game"></canvas>
    </div>

    <div class="panel panelSticky panel-right">
      <div class="controlsScroll" id="controlsScroll">
        <div class="controlsTop">
          <div class="diceBox" id="diceBox">
            <div class="diceGlow"></div>
            <div class="diceFace" id="diceFace">‚Äî</div>
            <div class="diceLabel" id="diceLabel">Press Roll</div>
          </div>
          <div class="subtitle">
            <b>Actions</b> = your energy.<br/>
            Spend Actions to <span class="badge">Move</span> or <span class="badge">Pick/Drop</span>.<br/>
            <span style="color:#9fb1c6">Spend Actions before rolling again.</span>
          </div>
        </div>

        <div class="scrollHint" id="scrollHint">
          Swipe up for controls, stats, and battle feed <span class="arrow">‚ñº</span>
        </div>

        <div id="monsterEvent" class="monsterEvent" style="display:none;">
          <div class="monsterEventIcon">üëπ</div>
          <div>
            <div class="monsterEventTitle">Stick Monster Appears!</div>
            <div id="monsterEventText">
              Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a 2√ó stick. Roll 0‚Äì1 and you lose 1 life.
            </div>
          </div>
        </div>

        <div class="dpadWrap" aria-label="D-pad">
          <div class="dpad">
            <button class="empty"></button>
            <button id="btnUp" aria-label="Up">‚ñ≤</button>
            <button class="empty"></button>
            <button id="btnLeft" aria-label="Left">‚óÄ</button>
            <button id="btnDown" aria-label="Down">‚ñº</button>
            <button id="btnRight" aria-label="Right">‚ñ∂</button>
          </div>
        </div>

        <div class="btns">
          <button id="btnRoll" class="btn-roll">üé≤ Roll</button>
          <button id="btnUse" class="btn-use">Pick/Drop</button>
          <button id="btnNew" class="btn-new">New Game</button>
          <button id="btnPause" class="btn-clear">‚è∏ Pause</button>
          <button id="btnMusic" class="btn-music">Music: OFF</button>
        </div>

        <div class="hr"></div>

        <div class="kv"><span>Player</span><span id="uiPlayer" class="playerArcade">PLAYER1</span></div>

        <div class="kv"><span>Stick Figure</span>
          <select id="uiSkin" aria-label="Stick Figure">
            <option value="classic">Classic</option>
            <option value="alien">Alien Stick</option>
            <option value="sally">Sally Stick</option>
            <option value="rick">Rick Stick</option>
            <option value="robot">Robo Stick</option>
            <option value="rex">Rex Stick</option>
          </select>
        </div>

        <div class="statsGrid">
          <div class="kv"><span>Lives</span><span id="uiLives" class="big">3</span></div>
          <div class="kv"><span>Level</span><span id="uiLevel" class="big">1</span></div>
          <div class="kv"><span>Score</span><span id="uiScore" class="big">0</span></div>
          <div class="kv"><span>Actions</span><span id="uiActions" class="big">0</span></div>
          <div class="kv"><span>Mode</span><span id="uiMode" class="big">NORMAL</span></div>
          <div class="kv"><span>Die</span><span id="uiDie" class="big">0‚Äì5</span></div>
          <div class="kv"><span>Carrying</span><span id="uiCarry" class="big">0/3</span></div>
          <div class="kv"><span>Sticks left</span><span id="uiLeft" class="big">0</span></div>
        </div>

        <div class="leaderboard" id="leaderboard"></div>

        <div class="battleFeedWrap" id="battleFeedWrap">
          <div class="battleFeedHeader">
            <b>Battle Feed</b>
            <span class="badge">Latest</span>
          </div>
          <div style="color:#9fb1c6; font-size:12px; margin-bottom:8px;">
            Monster wins, deposits, level-ups, and warnings show up here.
          </div>
          <div class="battleLog" id="battleLog"></div>
        </div>

        <div style="height:10px;"></div>
      </div>

      <div class="headerBlock">
        <div class="title">
          <div>STICKS <span class="badge">v2.41</span></div>
          <div class="titleBtns">
            <button id="btnSave" class="btn-save btn-mini" aria-label="Save Game" title="Save (S)">üíæ</button>
            <button class="btn-info btn-mini" id="btnInfo" title="Info">Info</button>
            <button id="btnLoad" class="btn-load btn-mini" aria-label="Load Game" title="Load (L)">üìÇ</button>
          </div>
        </div>
        <div class="subtitle">Pick up sticks. Feed the hole. Clear the field. Advance levels.</div>
        <div style="text-align:center; margin:10px 0; padding:10px 0; border-top:1px solid #1f2a37;">
          <div style="font-size:11px; color:#9fb1c6; line-height:1.5;">
            <div style="font-weight:700; letter-spacing:0.5px; margin-bottom:2px;">RAMIDUS, INC.</div>
            <div style="font-size:10px;">A Casey T. Duncan Enterprise</div>
          </div>
        </div>
        <div class="hr"></div>
      </div>
    </div>
  </div>

  <div id="infoOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">How to Play</div>
      <div class="modalText">
        <!-- Intro -->
        <div style="margin:14px 0 12px 0; font-size:14px; color:#cdd9e5; line-height:1.5;">
          <b>THE BASICS:</b> Collect sticks and deposit them in the hole to score points. Roll the dice to get actions, spend actions to move and interact, survive 10 levels of increasing difficulty!
        </div>

        <div class="hr"></div>

        <!-- Dice Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üé≤ THE DICE</b></div>
        <div style="margin:6px 0; line-height:1.5;">Each roll gives you <b>0-5 actions</b> (standard 6-sided die, but 0 instead of 6).</div>
        <div style="margin:6px 0; line-height:1.5;"><span class="badge">Roll 0</span> If carrying sticks, you drop them and they scatter. If carrying none, the hole spits out a stick nearby.</div>
        <div style="margin:6px 0 10px 0; line-height:1.5;">You must <b>spend all actions</b> before rolling again.</div>

        <div class="hr"></div>

        <!-- Actions Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéÆ ACTIONS</b></div>
        <div style="margin:6px 0; line-height:1.5;"><span class="badge">Move</span> Costs 1 action per tile (Arrow Keys or D-Pad)</div>
        <div style="margin:6px 0 10px 0; line-height:1.5;"><span class="badge">Pick/Drop</span> Costs 1 action:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Pick up a stick if standing on one</li>
            <li style="margin:3px 0;">Drop one stick onto an empty tile</li>
            <li style="margin:3px 0;">Deposit all carried sticks into the hole for points</li>
          </ul>
        </div>

        <div class="hr"></div>

        <!-- Special Features Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéÅ SPECIAL FEATURES</b></div>
        
        <div style="margin:10px 0;"><span class="badge">Bonus Sticks</span> (Yellow glow - multiple per level)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Look for sticks with a <b>subtle yellow glow</b> around them</li>
            <li style="margin:3px 0;">When picked up, your remaining actions are <b>doubled</b></li>
            <li style="margin:3px 0;">When actions hit 0, get a <b>Bonus Roll</b> (2-12 with double dice)</li>
            <li style="margin:3px 0;">During Bonus mode, deposits are worth <b>2√ó</b> points</li>
            <li style="margin:3px 0;">Roll 12 for another bonus roll!</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Secret Life Tile</span> (Pulses when you stand on it with sticks)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Drop a stick on this square to gain <b>+1 life</b></li>
            <li style="margin:3px 0;">If already at max lives, get bonus points instead</li>
            <li style="margin:3px 0;">One per level - find it!</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Power Sticks</span> (Rare special pickups)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;"><b>Speed:</b> Next 10 moves are free (no action cost)</li>
            <li style="margin:3px 0;"><b>Shield:</b> 30 seconds of invincibility to hazards</li>
            <li style="margin:3px 0;"><b>Vision:</b> Reveals secret life tile for 30 seconds</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Mystery Tree</span> (Appears randomly during levels)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Standing on tree with sticks? Feed 1 stick for <b>+1 life</b></li>
            <li style="margin:3px 0;">Standing on tree with no sticks? Get a <b>full load</b> instantly</li>
            <li style="margin:3px 0;">Tree disappears after granting a life or full load</li>
          </ul>
        </div>

        <div style="margin:10px 0 12px 0;"><span class="badge">Stick Monster</span> (Cursed sticks)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Some sticks are cursed! Picking one triggers a monster battle</li>
            <li style="margin:3px 0;">Roll 2-5 = WIN (keep a powered-up 2√ó stick)</li>
            <li style="margin:3px 0;">Roll 0-1 = LOSE (lose 1 life)</li>
            <li style="margin:3px 0;"><b>Streak bonus:</b> Win 3 in a row for +1 life. Keep winning for 3√ó, 4√ó, 5√ó sticks!</li>
          </ul>
        </div>

        <div class="hr"></div>

        <!-- Goal Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéØ GOAL</b></div>
        <div style="margin:6px 0; line-height:1.5;">Progress through <b>10 themed levels</b>, each with unique hazards. Collect sticks, survive, and rack up the highest score!</div>
        <div style="margin:6px 0 12px 0; line-height:1.5; color:#9fb1c6;"><b>Zero in the Hole:</b> Roll a zero while standing in hole and get extra points.</div>

        <div class="hr"></div>

        <!-- Controls -->
        <div style="margin:10px 0; color:#9fb1c6; font-size:12px; line-height:1.6;">
          <b>Controls:</b> Arrow Keys or D-Pad to move ‚Ä¢ Space = Pick/Drop ‚Ä¢ Esc or P = Pause<br/>
          <b>Save/Load:</b> Progress saves automatically on this device
        </div>
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnInfoClose">Close</button>
      </div>
    </div>
  </div>

  <div id="nameOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">ENTER YOUR NAME</div>
      <div class="modalText" style="color:#9fb1c6">Stored only on this device (local browser storage).</div>

      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <input id="nameInput" maxlength="16" placeholder="ENTER NAME"/>
        <button id="nameStartBtn" class="saveBtn">Start</button>
      </div>

      <div class="hintRow" id="savedNameHint" style="display:none;"></div>

      <div class="modalActions" style="justify-content:flex-start;">
        <button id="nameUseSavedBtn" class="altBtn" style="display:none;">Use SAVED</button>
        <button id="nameUseP1Btn" class="warnBtn">Use PLAYER1</button>
      </div>

      <div class="modalText" style="color:#9fb1c6; margin-top:10px;">Press <b>Enter</b> to start ‚Ä¢ <b>Esc</b> uses PLAYER1</div>
    </div>
  </div>

  <div id="pauseOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">PAUSED</div>
      <div class="modalText" style="color:#9fb1c6">
        Game + music are paused.<br/>
        Press <b>Pause</b> again to resume.
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnPauseClose">Resume</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">GAME OVER</div>

      <div class="endBanner loseBanner">
        <div>
          <div class="endHeadline">The sticks won this round</div>
          <div class="endSub">No shame. Just‚Ä¶ stick disrespect.</div>
        </div>
        <div class="bigIcon">üíÄ</div>
        <div class="fx" id="loseFx"></div>
      </div>

      <div class="modalText" id="gameOverText">The sticks won this time.</div>
      <div class="modalActions">
        <button class="modalClose" id="btnGameOverClose">Close</button>
        <button class="modalClose" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>

  <div id="winOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">YOU WIN</div>

      <div class="endBanner winBanner">
        <div>
          <div class="endHeadline">Victory Stick cleared</div>
          <div class="endSub">Fanfare engaged. Ego permitted.</div>
        </div>
        <div class="bigIcon">üèÜ</div>
        <div class="fx" id="winFx"></div>
      </div>

      <div class="modalText" id="winText">You cleared the sticks. The hole is satisfied (for now).</div>
      <div class="modalActions">
        <button class="modalClose" id="btnWinRestart">Play Again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar, { passive:true });
  window.addEventListener('orientationchange', setVhVar, { passive:true });

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (lo, hi) => Math.floor(Math.random() * (hi - lo + 1)) + lo;

  const LS_PLAYER_NAME  = "sticks_playerName_v3";
  const LS_LEADERBOARD  = "sticks_leaderboard_v1";
  const LS_SAVEGAME     = "sticks_savegame_v1";
  const SS_SCROLLED     = "sticks_scrolled_controls_v1";
  const LS_PLAYER_SKIN  = "sticks_playerSkin_v1";

  /* ---- Level Themes + Stick Names ---- */
  const LEVELS = [
    { name:"Night Stick",   bg:"#070a0e", grid:"#0f1720", border:"#1f2a37", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.35)", accentShadow:"rgba(58,167,255,.28)" },
    { name:"Sun Stick",     bg:"#140a03", grid:"#4a3a06", border:"#ffd400", accent:"#ffd400", accentGlow:"rgba(255,212,0,.46)", accentShadow:"rgba(255,212,0,.28)" },
    { name:"Sky Stick",     bg:"#041027", grid:"#0b234a", border:"#1172ff", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.46)", accentShadow:"rgba(58,167,255,.30)" },
    { name:"Fire Stick",    bg:"#1a0509", grid:"#361017", border:"#ff1f3a", accent:"#ff5a6a", accentGlow:"rgba(255,31,58,.46)", accentShadow:"rgba(255,90,106,.30)" },
    { name:"Ice Stick",     bg:"#d4f1ff", grid:"#001f3f", border:"#001f3f", accent:"#ffffff", accentGlow:"rgba(56,189,248,.42)", accentShadow:"rgba(56,189,248,.22)" },
    { name:"Glow Stick",    bg:"#09060f", grid:"#ffb347", border:"#ff7a18", accent:"#ffb347", accentGlow:"rgba(255,122,24,.46)", accentShadow:"rgba(255,122,24,.22)" },
    { name:"Spell Stick",   bg:"#0d0010", grid:"#4a0a3a", border:"#ff1493", accent:"#ff1493", accentGlow:"rgba(255,20,147,.46)", accentShadow:"rgba(255,20,147,.30)" },
    { name:"Sea Stick",     bg:"#001a33", grid:"#003d5c", border:"#0077be", accent:"#00bfff", accentGlow:"rgba(0,191,255,.46)", accentShadow:"rgba(0,191,255,.30)" },
    { name:"Spider Stick",  bg:"#0d0a12", grid:"#1a1520", border:"#2d2335", accent:"#8b5cf6", accentGlow:"rgba(139,92,246,.46)", accentShadow:"rgba(139,92,246,.30)" },
    { name:"Snake Stick",   bg:"#04120a", grid:"#0a2414", border:"#08c46b", accent:"#39ff95", accentGlow:"rgba(57,255,149,.44)", accentShadow:"rgba(57,255,149,.28)" },
    { name:"Victory Stick", bg:"#070315", grid:"#c27bff", border:"#7a35ff", accent:"#c27bff", accentGlow:"rgba(194,123,255,.55)", accentShadow:"rgba(194,123,255,.30)" }
  ];

  const STICK_COLORS = [
    "#ff5a6a","#ff1f3a","#ffb347","#ff7a18","#39ff95","#08c46b",
    "#3aa7ff","#1172ff","#c27bff","#7a35ff","#ffd166","#a8dadc",
    "#95d5b2","#ff9f1c","#b08cff","#f3f4f6"
  ];

  const TILE = 24, GRID_W = 24, GRID_H = 24;
  const CANVAS_W = GRID_W * TILE, CANVAS_H = GRID_H * TILE;

  // Snowflakes for Ice Stick theme
  let snowflakes = [];
  
  function initSnowflakes(){
    snowflakes = [];
    for (let i = 0; i < 40; i++){
      snowflakes.push({
        x: Math.random() * CANVAS_W,
        y: Math.random() * CANVAS_H,
        size: 1.5 + Math.random() * 2.5,
        speed: 0.8 + Math.random() * 1.2,
        drift: (Math.random() - 0.5) * 0.6
      });
    }
  }
  
  function updateSnowflakes(){
    for (let flake of snowflakes){
      flake.y += flake.speed;
      flake.x += flake.drift;
      if (flake.y > CANVAS_H){
        flake.y = -5;
        flake.x = Math.random() * CANVAS_W;
      }
      if (flake.x < 0) flake.x = CANVAS_W;
      if (flake.x > CANVAS_W) flake.x = 0;
    }
  }
  
  function drawSnowflakes(){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.shadowColor = "rgba(200,230,255,0.4)";
    ctx.shadowBlur = 3;
    for (let flake of snowflakes){
      ctx.beginPath();
      ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }



  // Fire hazards for Fire Stick theme
  let fireTiles = [];
  let fireWarningTimer = 0;
  const FIRE_WARNING_TIME = 150; // 2 seconds warning
  
  function initFireTiles(){
    fireTiles = [];
    // Create 8-12 random fire tiles
    const numFires = randInt(8, 12);
    for (let i = 0; i < numFires; i++){
      const x = randInt(0, GRID_W - 1);
      const y = randInt(0, GRID_H - 1);
      fireTiles.push({
        x, y,
        intensity: Math.random() // for animation
      });
    }
  }
  
  let fireCrackleInterval = null;
  let fireRespawnTimer = 0;
  
  function updateFireTiles(){
    // Animate fire intensity
    for (let fire of fireTiles){
      fire.intensity = (fire.intensity + 0.08) % (Math.PI * 2);
    }
    
    // Random respawn (pop up in new locations)
    fireRespawnTimer++;
    if (fireRespawnTimer >= randInt(300, 480)){ // 5-8 seconds
      fireRespawnTimer = 0;
      // Move 2-4 random fire tiles
      const numToMove = randInt(2, 4);
      for (let i = 0; i < numToMove && i < fireTiles.length; i++){
        const fire = fireTiles[randInt(0, fireTiles.length - 1)];
        fire.x = randInt(0, GRID_W - 1);
        fire.y = randInt(0, GRID_H - 1);
        spawnSparks(fire.x, fire.y, 12, false);
      }
      // No sound - just visual sparks (was too cheesy)
    }
    
    // Check if player is on fire tile
    const onFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFire){
      fireWarningTimer++;
      
      // Start continuous crackling sound
      if (!fireCrackleInterval){
        fireCrackleInterval = setInterval(() => {
          if (fireTiles.some(f => f.x === game.playerX && f.y === game.playerY)){
            // Fire crackling
            beep(100 + Math.random() * 80, 0.08, "sawtooth", 0.05);
          }
        }, 300);
      }
      
      if (fireWarningTimer >= FIRE_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          fireWarningTimer = 0;
        } else if (activeShield > 0){
          fireWarningTimer = 0;
          logEvent("info", "Shield protected you from fire!");
          setHud("SHIELD SAVED YOU!");
        } else {
          game.lives--;
          fireWarningTimer = 0;
          logEvent("bad", "Burned by fire! -1 life");
          beep(100, 0.15, "sawtooth", 0.1);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
        }
      } else if (fireWarningTimer === 60){
        logEvent("warn", "Fire burning! Move or lose a life!");
        setHud("BURNING!");
      }
    } else {
      fireWarningTimer = 0;
      if (fireCrackleInterval){
        clearInterval(fireCrackleInterval);
        fireCrackleInterval = null;
      }
    }
  }
  
  function drawFireTiles(){
    ctx.save();
    for (let fire of fireTiles){
      const x = fire.x * TILE + TILE / 2;
      const y = fire.y * TILE + TILE / 2;
      
      // Multiple flame flickers for realistic effect
      const flicker1 = Math.sin(fire.intensity) * 0.4 + 0.6;
      const flicker2 = Math.sin(fire.intensity * 1.7 + 1) * 0.3 + 0.7;
      const flicker3 = Math.sin(fire.intensity * 2.3 + 2) * 0.35 + 0.65;
      
      // Large base glow
      const glowGrad = ctx.createRadialGradient(x, y + 2, 0, x, y + 2, TILE / 2 + 6);
      glowGrad.addColorStop(0, 'rgba(255,180,0,' + (0.6 * flicker1) + ')');
      glowGrad.addColorStop(0.4, 'rgba(255,100,20,' + (0.4 * flicker2) + ')');
      glowGrad.addColorStop(1, 'rgba(255,31,58,0)');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(x, y + 2, TILE / 2 + 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main flame body (tall, dancing shape)
      const flameHeight = 10 + flicker1 * 4;
      const flameGrad = ctx.createLinearGradient(x, y + 4, x, y - flameHeight);
      flameGrad.addColorStop(0, 'rgba(255,100,0,' + (0.9 * flicker2) + ')');
      flameGrad.addColorStop(0.3, 'rgba(255,150,0,' + (0.85 * flicker1) + ')');
      flameGrad.addColorStop(0.6, 'rgba(255,200,50,' + (0.7 * flicker3) + ')');
      flameGrad.addColorStop(1, 'rgba(255,220,100,0)');
      
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.moveTo(x - 6 * flicker1, y + 4);
      ctx.bezierCurveTo(x - 5, y, x - 3 * flicker2, y - flameHeight * 0.7, x - 2, y - flameHeight);
      ctx.bezierCurveTo(x - 1, y - flameHeight - 2, x + 1, y - flameHeight - 2, x + 2, y - flameHeight);
      ctx.bezierCurveTo(x + 3 * flicker3, y - flameHeight * 0.7, x + 5, y, x + 6 * flicker1, y + 4);
      ctx.closePath();
      ctx.fill();
      
      // Hot white core
      ctx.fillStyle = 'rgba(255,255,200,' + (0.8 * flicker2) + ')';
      ctx.beginPath();
      ctx.ellipse(x, y, 3 * flicker1, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Flickering tips
      const tipFlicker = Math.sin(fire.intensity * 3) * 0.5 + 0.5;
      ctx.fillStyle = 'rgba(255,200,50,' + (0.6 * tipFlicker) + ')';
      ctx.beginPath();
      ctx.arc(x - 2 * flicker2, y - flameHeight * 0.8, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 2 * flicker3, y - flameHeight * 0.9, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw warning indicator if player is on fire
    if (fireWarningTimer > 0){
      const playerOnFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFire){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(fireWarningTimer * 0.3) * 0.5 + 0.5;
        
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#ff1f3a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }


  // ================================================================
  // WIND TILES - Sky Stick
  // ================================================================
  let windTiles = [];
  let windWarningTimer = 0;
  let windGustTimer = 0;
  const WIND_WARNING_TIME = 300; // 5 seconds
  
  function initWindTiles(){
    windTiles = [];
    const num = randInt(6, 10);
    for (let i = 0; i < num; i++){
      windTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        intensity: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateWindTiles(){
    for (let w of windTiles) {
      w.intensity = (w.intensity + 0.12) % (Math.PI * 2);
    }
    
    // Random wind gusts that push player
    windGustTimer++;
    if (windGustTimer >= randInt(180, 360)){ // Every 3-6 seconds
      windGustTimer = 0;
      if (!game.inputLocked && game.actions > 0){
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        const newX = clamp(game.playerX + dir.dx, 0, GRID_W - 1);
        const newY = clamp(game.playerY + dir.dy, 0, GRID_H - 1);
        
        // Don't push into hole
        if (newX !== game.holeX || newY !== game.holeY){
          game.playerX = newX;
          game.playerY = newY;
          beep(250, 0.08, "triangle", 0.05);
          logEvent("info", "Wind gust pushed you!");
          setHud("WIND GUST!");
          spawnSparks(game.playerX, game.playerY, 12, false);
        }
      }
    }
    
    const onWind = windTiles.some(w => w.x === game.playerX && w.y === game.playerY);
    if (onWind){
      windWarningTimer++;
      if (windWarningTimer >= WIND_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          windWarningTimer = 0;
        } else if (activeShield > 0){
          windWarningTimer = 0;
          logEvent("info", "Shield blocked wind!");
          setHud("SHIELD!");
        } else if (game.carry.length > 0){
          const lost = game.carry.length;
          game.carry = [];
          windWarningTimer = 0;
          logEvent("bad", `Wind stole ${lost} sticks!`);
          setHud("WIND STOLE STICKS!");
          spawnSparks(game.playerX, game.playerY, 22, true);
          updateUI();
        } else {
          windWarningTimer = 0;
        }
      } else if (windWarningTimer === 60 || windWarningTimer === 180){
        beep(200, 0.12, "triangle", 0.06);
        logEvent("warn", "Wind trap! Move!");
        setHud("WIND!");
      }
    } else {
      windWarningTimer = 0;
    }
  }
  
  function drawWindTiles(){
    ctx.save();
    for (let w of windTiles){
      const x = w.x * TILE + TILE / 2;
      const y = w.y * TILE + TILE / 2;
      const spin = w.intensity;
      const pulse = Math.sin(spin * 2) * 0.3 + 0.7;
      
      // Swirling base
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      grad.addColorStop(0, 'rgba(200,220,255,' + (0.3 * pulse) + ')');
      grad.addColorStop(1, 'rgba(100,140,200,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Swirl lines
      ctx.strokeStyle = 'rgba(180,200,240,' + (0.5 * pulse) + ')';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++){
        const offset = (spin + i * Math.PI * 0.66) % (Math.PI * 2);
        const radius = 4 + i * 2;
        ctx.beginPath();
        ctx.arc(x, y, radius, offset, offset + Math.PI * 0.8);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // ================================================================
  // SNAKES - Snake Stick (chase and drain!)
  // ================================================================
  let snakes = [];
  let snakeMoveTimer = 0;
  let snakeAttacking = false;
  let snakeAttackTimer = 0;
  const SNAKE_MOVE_INTERVAL = 150; // 2.5 seconds
  const SNAKE_DRAIN_INTERVAL = 180; // 3 seconds
  
  function initSnakes(){
    snakes = [];
    const num = randInt(3, 5);
    for (let i = 0; i < num; i++){
      let x, y, attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY) ||
        Math.abs(x - game.playerX) + Math.abs(y - game.playerY) < 5
      ));
      snakes.push({ x, y, slither: Math.random() * Math.PI * 2 });
    }
  }
  
  function updateSnakes(){
    if (game.pendingMonster) return;
    
    // Animate slithering
    for (let s of snakes) {
      s.slither = (s.slither + 0.15) % (Math.PI * 2);
    }
    
    // Handle draining if attached
    if (snakeAttacking){
      snakeAttackTimer--;
      if (snakeAttackTimer <= 0){
        snakeAttackTimer = SNAKE_DRAIN_INTERVAL;
        
        if (game.carry.length > 0){
          game.carry.pop();
          logEvent("bad", "Snake drained a stick!");
          setHud("DRAINED!");
          beep(150, 0.08, "sawtooth", 0.04);
          spawnSparks(game.playerX, game.playerY, 15, true);
          updateUI();
        } else {
          // No sticks - take life and disappear
          game.lives--;
          logEvent("bad", "Snake bite! -1 life");
          setHud("SNAKE BITE!");
          beep(100, 0.12, "sawtooth", 0.08);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          
          // Remove the snake
          for (let i = snakes.length - 1; i >= 0; i--){
            if (snakes[i].x === game.playerX && snakes[i].y === game.playerY){
              snakes.splice(i, 1);
              break;
            }
          }
          snakeAttacking = false;
        }
      }
      
      // Check if player moved away
      const stillOn = snakes.some(s => s.x === game.playerX && s.y === game.playerY);
      if (!stillOn){
        snakeAttacking = false;
        logEvent("info", "Escaped snake!");
      }
    }
    
    // Move snakes toward player
    snakeMoveTimer++;
    if (snakeMoveTimer >= SNAKE_MOVE_INTERVAL){
      snakeMoveTimer = 0;
      
      for (let i = snakes.length - 1; i >= 0; i--){
        const s = snakes[i];
        
        // Check if caught player (HOLE IS SACRED)
        if (s.x === game.playerX && s.y === game.playerY &&
            !(game.playerX === game.holeX && game.playerY === game.holeY)){
          if (activeShield > 0){
            logEvent("info", "Shield blocked snake!");
            setHud("SHIELD!");
            snakes.splice(i, 1);
          } else if (!snakeAttacking){
            snakeAttacking = true;
            snakeAttackTimer = SNAKE_DRAIN_INTERVAL;
            logEvent("warn", "Snake attached! Draining sticks!");
            setHud("SNAKE DRAINING!");
            beep(150, 0.1, "sawtooth", 0.06);
          }
          continue;
        }
        
        // Chase player
        const dx = game.playerX - s.x;
        const dy = game.playerY - s.y;
        if (Math.abs(dx) > Math.abs(dy)){
          s.x += dx > 0 ? 1 : -1;
        } else if (Math.abs(dy) > 0){
          s.y += dy > 0 ? 1 : -1;
        }
        s.x = clamp(s.x, 0, GRID_W - 1);
        s.y = clamp(s.y, 0, GRID_H - 1);
      }
    }
  }
  
  function drawSnakes(){
    ctx.save();
    for (let s of snakes){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const so = Math.sin(s.slither);
      const sp = Math.sin(s.slither + Math.PI * 0.5);
      
      // Dark body outline
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x - 14, y + so * 2);
      ctx.bezierCurveTo(x - 10, y - so * 3, x - 5, y + sp * 2, x, y);
      ctx.bezierCurveTo(x + 5, y - sp * 2, x + 10, y + so * 3, x + 14, y - so * 2);
      ctx.stroke();
      
      // Green body
      ctx.strokeStyle = '#39ff95';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(x - 14, y + so * 2);
      ctx.bezierCurveTo(x - 10, y - so * 3, x - 5, y + sp * 2, x, y);
      ctx.bezierCurveTo(x + 5, y - sp * 2, x + 10, y + so * 3, x + 14, y - so * 2);
      ctx.stroke();
      
      // Head
      ctx.save();
      ctx.translate(x + 14, y - so * 2);
      ctx.fillStyle = '#39ff95';
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(5, 0);
      ctx.lineTo(0, 4);
      ctx.lineTo(-3, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Red eyes
      ctx.fillStyle = '#ff1f3a';
      ctx.beginPath();
      ctx.arc(1, -1.5, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1, 1.5, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Tongue (flicks)
      if (Math.sin(s.slither * 3) > 0.3){
        ctx.strokeStyle = '#ff5a6a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(7, -1.5);
        ctx.moveTo(5, 0);
        ctx.lineTo(7, 1.5);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  }

  // ================================================================
  // FREEZE ZONES - Ice Stick
  // ================================================================
  let freezeTiles = [];
  let freezeWarningTimer = 0;
  const FREEZE_WARNING_TIME = 150; // 2.5 seconds like fire
  
  function initFreezeTiles(){
    freezeTiles = [];
    const num = randInt(10, 14);
    for (let i = 0; i < num; i++){
      freezeTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        shimmer: Math.random() * Math.PI * 2
      });
    }
  }
  
  let freezeChimeInterval = null;
  let windSoundInterval = null;
  
  function updateFreezeTiles(){
    // Animate shimmer + slow drift
    for (let f of freezeTiles){
      f.shimmer = (f.shimmer + 0.08) % (Math.PI * 2);
      
      // Slow drift
      if (!f.driftTimer) f.driftTimer = randInt(120, 180);
      f.driftTimer--;
      if (f.driftTimer <= 0){
        f.driftTimer = randInt(120, 180); // 2-3 seconds
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        f.x = clamp(f.x + dir.dx, 0, GRID_W - 1);
        f.y = clamp(f.y + dir.dy, 0, GRID_H - 1);
      }
    }
    
    const onFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFreeze){
      freezeWarningTimer++;
      
      // Start continuous chime
      if (!freezeChimeInterval){
        freezeChimeInterval = setInterval(() => {
          if (freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY)){
            // LOUD ice warning
            beep(900, 0.15, "sine", 0.10);
          }
        }, 350);
      }
      
      if (freezeWarningTimer >= FREEZE_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          freezeWarningTimer = 0;
        } else if (activeShield > 0){
          freezeWarningTimer = 0;
          logEvent("info", "Shield blocked freeze!");
          setHud("SHIELD!");
        } else {
          game.lives--;
          freezeWarningTimer = 0;
          logEvent("bad", "Frozen! -1 life");
          setHud("FROZEN!");
          beep(400, 0.12, "sine", 0.08);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
        }
      } else if (freezeWarningTimer === 60){
        logEvent("warn", "Freezing! Move!");
        setHud("FREEZING!");
      }
    } else {
      freezeWarningTimer = 0;
      if (freezeChimeInterval){
        clearInterval(freezeChimeInterval);
        freezeChimeInterval = null;
      }
    }
  }
  
  function startIceWindSound(){
    if (!windSoundInterval){
      // Removed wind sound - was too distracting
      windSoundInterval = true; // Just mark as started
    }
  }
  
  function stopIceWindSound(){
    if (windSoundInterval){
      clearInterval(windSoundInterval);
      windSoundInterval = null;
    }
  }
  
  function drawFreezeTiles(){
    ctx.save();
    for (let f of freezeTiles){
      const x = f.x * TILE + TILE / 2;
      const y = f.y * TILE + TILE / 2;
      const pulse = Math.sin(f.shimmer) * 0.5 + 0.5;
      
      // Icy base glow
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      grad.addColorStop(0, 'rgba(200,230,255,' + (0.6 + pulse * 0.2) + ')');
      grad.addColorStop(1, 'rgba(100,180,230,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Ice crystal spikes (6 directions)
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.7 + pulse * 0.3) + ')';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 4 + pulse * 4;
      for (let i = 0; i < 6; i++){
        const angle = (Math.PI / 3) * i + f.shimmer;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      
      // Center crystal
      ctx.fillStyle = 'rgba(200,230,255,' + (0.8 + pulse * 0.2) + ')';
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Warning indicator
    if (freezeWarningTimer > 0){
      const playerOnFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFreeze){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(freezeWarningTimer * 0.3) * 0.5 + 0.5;
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }

  // ================================================================
  // SHADOW MONSTERS - Glow Stick (roaming killers!)
  // ================================================================
  let shadowMonsters = [];
  
  function initShadowMonsters(){
    shadowMonsters = [];
    const num = randInt(1, 3);
    for (let i = 0; i < num; i++){
      let x, y, attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY)
      ));
      shadowMonsters.push({
        x, y,
        pulse: Math.random() * Math.PI * 2,
        moveTimer: randInt(60, 120)
      });
    }
  }
  
  function updateShadowMonsters(){
    if (game.pendingMonster) return;
    
    for (let i = shadowMonsters.length - 1; i >= 0; i--){
      const m = shadowMonsters[i];
      m.pulse = (m.pulse + 0.1) % (Math.PI * 2);
      
      m.moveTimer--;
      if (m.moveTimer <= 0){
        m.moveTimer = randInt(60, 120);
        
        // 60% chance to chase player, 40% random movement
        if (Math.random() < 0.6){
          // Chase player
          const dx = game.playerX - m.x;
          const dy = game.playerY - m.y;
          if (Math.abs(dx) > Math.abs(dy)){
            m.x = clamp(m.x + Math.sign(dx), 0, GRID_W - 1);
          } else {
            m.y = clamp(m.y + Math.sign(dy), 0, GRID_H - 1);
          }
        } else {
          // Random roaming
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          m.x = clamp(m.x + dir.dx, 0, GRID_W - 1);
          m.y = clamp(m.y + dir.dy, 0, GRID_H - 1);
        }
      }
      
      if (m.x === game.playerX && m.y === game.playerY &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield blocked shadow!");
          setHud("SHIELD!");
          shadowMonsters.splice(i, 1);
        } else {
          game.lives--;
          logEvent("bad", "Shadow monster! -1 life");
          setHud("SHADOW KILL!");
          // Scary death sound
          beep(100, 0.15, "sawtooth", 0.12);
          setTimeout(() => beep(60, 0.20, "sawtooth", 0.15), 80);
          setTimeout(() => beep(40, 0.25, "sawtooth", 0.18), 160);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          shadowMonsters.splice(i, 1);
        }
      }
    }
  }
  
  function drawShadowMonsters(){
    ctx.save();
    for (let m of shadowMonsters){
      const x = m.x * TILE + TILE / 2;
      const y = m.y * TILE + TILE / 2;
      const pulse = Math.sin(m.pulse) * 0.5 + 0.5;
      
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, 10);
      grad.addColorStop(0, 'rgba(80,40,0,0.8)');
      grad.addColorStop(1, 'rgba(40,20,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.fillStyle = '#ffb347';
      ctx.shadowColor = '#ffb347';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(x - 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ================================================================
  // SNOWMAN - Ice Stick chasing enemy
  // ================================================================
  let snowman = null;
  
  function initSnowman(){
    let x, y;
    do {
      x = randInt(0, GRID_W - 1);
      y = randInt(0, GRID_H - 1);
    } while ((x === game.playerX && y === game.playerY) || (x === game.holeX && y === game.holeY));
    snowman = { x, y, moveTimer: 90, bobTimer: 0 };
  }
  
  function updateSnowman(){
    if (!snowman || game.pendingMonster) return;
    snowman.bobTimer = (snowman.bobTimer + 0.1) % (Math.PI * 2);
    snowman.moveTimer--;
    if (snowman.moveTimer <= 0){
      snowman.moveTimer = 90;
      const dx = game.playerX - snowman.x;
      const dy = game.playerY - snowman.y;
      if (Math.abs(dx) > Math.abs(dy)){
        snowman.x = clamp(snowman.x + Math.sign(dx), 0, GRID_W - 1);
      } else {
        snowman.y = clamp(snowman.y + Math.sign(dy), 0, GRID_H - 1);
      }
    }
    if (snowman.x === game.playerX && snowman.y === game.playerY && !(game.playerX === game.holeX && game.playerY === game.holeY)){
      if (activeShield > 0){
        logEvent("info", "Shield melted snowman!");
        setHud("SHIELD!");
        snowman = null;
        initSnowman();
      } else if (game.carry.length > 0){
        const stolen = game.carry.length;
        game.carry = [];
        logEvent("bad", "Snowman stole " + stolen + " sticks!");
        setHud("SNOWMAN!");
        beep(300, 0.12, "sine", 0.08);
        spawnSparks(game.playerX, game.playerY, 18, true);
        updateUI();
        snowman = null;
        initSnowman();
      } else {
        game.lives--;
        logEvent("bad", "Frozen by snowman! -1 life");
        setHud("SNOWMAN!");
        
        // Dramatic frozen death sound - descending doom
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = "triangle";
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
        gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.6);
        
        spawnSparks(game.playerX, game.playerY, 30, true);
        if (game.lives <= 0) gameOver();
        else updateUI();
        snowman = null;
        initSnowman();
      }
    }
  }
  
  function drawSnowman(){
    if (!snowman) return;
    const x = snowman.x * TILE + TILE / 2;
    const y = snowman.y * TILE + TILE / 2;
    const bob = Math.sin(snowman.bobTimer) * 1.5;
    ctx.save();
    ctx.translate(x, y + bob);
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = "#001f3f";
    ctx.beginPath();
    ctx.ellipse(0, 15, 9, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#d0e8ff";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 6, 7.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -3, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -10.5, 4.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#1a1a1a";
    ctx.beginPath();
    ctx.arc(-2.2, -11.2, 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(2.2, -11.2, 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ff6b35";
    ctx.beginPath();
    ctx.moveTo(0, -9.7);
    ctx.lineTo(3.8, -9);
    ctx.lineTo(0, -8.2);
    ctx.fill();
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-5.2, -1.5);
    ctx.lineTo(-9, -4.5);
    ctx.moveTo(5.2, -1.5);
    ctx.lineTo(9, -4.5);
    ctx.stroke();
    ctx.restore();
  }

  // ================================================================
  // SPIDER WEBS - Spider Stick (sticky traps)
  // ================================================================
  let spiderWebs = [];
  
  function initSpiderWebs(){
    spiderWebs = [];
    const num = randInt(4, 6);
    for (let i = 0; i < num; i++){
      spiderWebs.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        pulse: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSpiderWebs(){
    for (let i = spiderWebs.length - 1; i >= 0; i--){
      const web = spiderWebs[i];
      web.pulse = (web.pulse + 0.05) % (Math.PI * 2);
      
      if (web.x === game.playerX && web.y === game.playerY && 
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield broke through web!");
          setHud("SHIELD!");
          spiderWebs.splice(i, 1); // Remove web
        } else if (!game.webbed){
          // Lose all remaining actions immediately
          const lostActions = game.actions;
          game.actions = 0;
          game.webbed = true;
          
          if (lostActions > 0){
            logEvent("bad", `TRAPPED IN WEB! Lost ${lostActions} actions. Next roll will be halved!`);
            setHud("WEB TRAP!");
            beep(200, 0.10, "sawtooth", 0.06);
          } else {
            logEvent("bad", "Stuck in web! Next roll will be halved!");
            setHud("WEBBED!");
            beep(200, 0.10, "sawtooth", 0.06);
          }
          
          // REMOVE the web after it traps you (single use)
          spiderWebs.splice(i, 1);
          
          updateUI();
        }
      }
    }
  }
  
  function drawSpiderWebs(){
    for (let web of spiderWebs){
      const x = web.x * TILE + TILE / 2;
      const y = web.y * TILE + TILE / 2;
      const pulse = Math.sin(web.pulse) * 0.3 + 0.7;
      
      ctx.save();
      ctx.globalAlpha = 0.4 + pulse * 0.2;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.5;
      
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI * 2 / 8) * i;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
        ctx.stroke();
      }
      
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.restore();
    }
  }
  
  // ================================================================
  // SPIDERS - Spider Stick (fast chasers)
  // ================================================================
  let spiders = [];
  
  function initSpiders(){
    spiders = [];
    const num = randInt(2, 3);
    for (let i = 0; i < num; i++){
      let x, y;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
      } while ((x === game.playerX && y === game.playerY) || 
               (x === game.holeX && y === game.holeY) ||
               (snowman && x === snowman.x && y === snowman.y));
      spiders.push({ x, y, moveTimer: 90, legTimer: 0 });
    }
  }
  
  function updateSpiders(){
    if (game.pendingMonster) return;
    
    for (let i = spiders.length - 1; i >= 0; i--){
      const spider = spiders[i];
      spider.legTimer = (spider.legTimer + 0.2) % (Math.PI * 2);
      spider.moveTimer--;
      
      if (spider.moveTimer <= 0){
        spider.moveTimer = 90;
        const dx = game.playerX - spider.x;
        const dy = game.playerY - spider.y;
        if (Math.abs(dx) > Math.abs(dy)){
          spider.x = clamp(spider.x + Math.sign(dx), 0, GRID_W - 1);
        } else {
          spider.y = clamp(spider.y + Math.sign(dy), 0, GRID_W - 1);
        }
      }
      
      if (spider.x === game.playerX && spider.y === game.playerY &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield crushed spider!");
          setHud("SHIELD!");
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        } else if (game.carry.length > 0){
          const stolen = game.carry.length;
          game.carry = [];
          logEvent("bad", "Spider wrapped " + stolen + " sticks!");
          setHud("SPIDER!");
          
          // Spider wrapping sound - quick descending buzz
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(600, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.25);
          gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
          osc.start(audioCtx.currentTime);
          osc.stop(audioCtx.currentTime + 0.25);
          
          spawnSparks(game.playerX, game.playerY, 25, true);
          updateUI();
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        } else {
          game.lives--;
          logEvent("bad", "Spider bite! -1 life");
          setHud("SPIDER BITE!");
          
          // Dramatic spider death sound - multi-tone doom chord
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          
          // Low ominous tone
          const osc1 = audioCtx.createOscillator();
          const gain1 = audioCtx.createGain();
          osc1.connect(gain1);
          gain1.connect(audioCtx.destination);
          osc1.type = "sawtooth";
          osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
          osc1.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.5);
          gain1.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
          
          // Mid creepy tone
          const osc2 = audioCtx.createOscillator();
          const gain2 = audioCtx.createGain();
          osc2.connect(gain2);
          gain2.connect(audioCtx.destination);
          osc2.type = "square";
          osc2.frequency.setValueAtTime(200, audioCtx.currentTime);
          osc2.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
          gain2.gain.setValueAtTime(0.15, audioCtx.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
          
          // High screech
          const osc3 = audioCtx.createOscillator();
          const gain3 = audioCtx.createGain();
          osc3.connect(gain3);
          gain3.connect(audioCtx.destination);
          osc3.type = "sine";
          osc3.frequency.setValueAtTime(800, audioCtx.currentTime);
          osc3.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
          gain3.gain.setValueAtTime(0.12, audioCtx.currentTime);
          gain3.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
          
          osc1.start(audioCtx.currentTime);
          osc1.stop(audioCtx.currentTime + 0.5);
          osc2.start(audioCtx.currentTime);
          osc2.stop(audioCtx.currentTime + 0.5);
          osc3.start(audioCtx.currentTime);
          osc3.stop(audioCtx.currentTime + 0.3);
          
          spawnSparks(game.playerX, game.playerY, 30, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        }
      }
    }
  }
  
  function drawSpiders(){
    for (let spider of spiders){
      const x = spider.x * TILE + TILE / 2;
      const y = spider.y * TILE + TILE / 2;
      const legWave = Math.sin(spider.legTimer);
      
      ctx.save();
      ctx.translate(x, y);
      
      // 8 animated legs (4 pairs)
      ctx.strokeStyle = "#f0f0f0";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      for (let i = 0; i < 4; i++){
        // Alternate leg movement for walking effect
        const leftPhase = legWave + (i * Math.PI / 2);
        const rightPhase = legWave + (i * Math.PI / 2) + Math.PI;
        const leftWiggle = Math.sin(leftPhase) * 2;
        const rightWiggle = Math.sin(rightPhase) * 2;
        
        // Left legs (bent at joint)
        ctx.beginPath();
        ctx.moveTo(-3, -1 + i);
        ctx.lineTo(-6, -3 + i * 2 + leftWiggle);
        ctx.lineTo(-10, -1 + i * 2.5);
        ctx.stroke();
        
        // Right legs (bent at joint)
        ctx.beginPath();
        ctx.moveTo(3, -1 + i);
        ctx.lineTo(6, -3 + i * 2 + rightWiggle);
        ctx.lineTo(10, -1 + i * 2.5);
        ctx.stroke();
      }
      
      // Body (round, hairy spider)
      ctx.fillStyle = "#1a0d24";
      ctx.strokeStyle = "#8b5cf6";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Add some hair texture
      ctx.strokeStyle = "#4c1d95";
      ctx.lineWidth = 1;
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI * 2 / 8) * i;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 3, Math.sin(angle) * 3);
        ctx.lineTo(Math.cos(angle) * 5, Math.sin(angle) * 5);
        ctx.stroke();
      }
      
      // Head (smaller segment)
      ctx.fillStyle = "#2d1a3d";
      ctx.strokeStyle = "#8b5cf6";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, -6, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Multiple red eyes (spider-like)
      ctx.fillStyle = "#ff0000";
      ctx.shadowColor = "#ff0000";
      ctx.shadowBlur = 3;
      // Top eyes
      ctx.beginPath();
      ctx.arc(-1.5, -7, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1.5, -7, 0.8, 0, Math.PI * 2);
      ctx.fill();
      // Bottom eyes (smaller)
      ctx.beginPath();
      ctx.arc(-1, -5.5, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1, -5.5, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      ctx.restore();
    }
  }
  
  // ================================================================
  // SKUNKS + STINK CLOUDS - Skunk Stick
  // ================================================================
  let skunks = [];
  let stinkClouds = [];
  
  function initSkunks(){
    skunks = [];
    const num = randInt(2, 3);
    for (let i = 0; i < num; i++){
      let x, y;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
      } while ((x === game.playerX && y === game.playerY) || 
               (x === game.holeX && y === game.holeY));
      skunks.push({ x, y, moveTimer: 80, sprayTimer: 180, waddle: 0 });
    }
  }
  
  function updateSkunks(){
    if (game.pendingMonster) return;
    
    for (let skunk of skunks){
      skunk.waddle = (skunk.waddle + 0.15) % (Math.PI * 2);
      skunk.moveTimer--;
      skunk.sprayTimer--;
      
      if (skunk.moveTimer <= 0){
        skunk.moveTimer = 80;
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        skunk.x = clamp(skunk.x + dir.dx, 0, GRID_W - 1);
        skunk.y = clamp(skunk.y + dir.dy, 0, GRID_H - 1);
      }
      
      const dx = Math.abs(skunk.x - game.playerX);
      const dy = Math.abs(skunk.y - game.playerY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 4 && skunk.sprayTimer <= 0){
        skunk.sprayTimer = 180;
        stinkClouds.push({
          x: skunk.x, y: skunk.y,
          radius: 0, maxRadius: 3,
          lifetime: 300, pulse: 0, damageTimer: 0
        });
        logEvent("info", "Skunk sprayed! Avoid the cloud!");
        setHud("SKUNK SPRAY!");
        beep(150, 0.08, "sawtooth", 0.05);
      }
    }
    
    for (let i = stinkClouds.length - 1; i >= 0; i--){
      const cloud = stinkClouds[i];
      cloud.pulse = (cloud.pulse + 0.1) % (Math.PI * 2);
      cloud.lifetime--;
      
      if (cloud.radius < cloud.maxRadius){
        cloud.radius += 0.15;
      }
      
      const dx = Math.abs(cloud.x - game.playerX);
      const dy = Math.abs(cloud.y - game.playerY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < cloud.radius && !(game.playerX === game.holeX && game.playerY === game.holeY)){
        cloud.damageTimer++;
        if (cloud.damageTimer % 30 === 0){
          beep(300, 0.06, "sine", 0.04);
        }
        if (cloud.damageTimer > 180){
          if (activeShield > 0){
            logEvent("info", "Shield blocked stink!");
            setHud("SHIELD!");
          } else {
            game.lives--;
            logEvent("bad", "Poisoned by stink! -1 life");
            setHud("POISONED!");
            beep(250, 0.15, "sine", 0.10);
            spawnSparks(game.playerX, game.playerY, 22, true);
            if (game.lives <= 0) gameOver();
            else updateUI();
          }
          cloud.damageTimer = 0;
        }
      } else {
        cloud.damageTimer = 0;
      }
      
      if (cloud.lifetime <= 0){
        stinkClouds.splice(i, 1);
      }
    }
  }
  
  function drawSkunks(){
    for (let skunk of skunks){
      const x = skunk.x * TILE + TILE / 2;
      const y = skunk.y * TILE + TILE / 2;
      const waddle = Math.sin(skunk.waddle) * 1;
      
      ctx.save();
      ctx.translate(x, y + waddle);
      
      // Tail (big and fluffy, held up)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.ellipse(-2, -8, 4, 6, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // White stripe on tail
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(-2, -8, 2, 5, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Body (fat oval)
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.ellipse(0, 1, 7, 4.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Two white stripes from head to tail (classic skunk pattern)
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.moveTo(-2, -2);
      ctx.lineTo(-3, 1);
      ctx.lineTo(-2.5, 4);
      ctx.lineTo(-1.5, 4);
      ctx.lineTo(-1, 1);
      ctx.lineTo(-1.5, -2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(2, -2);
      ctx.lineTo(3, 1);
      ctx.lineTo(2.5, 4);
      ctx.lineTo(1.5, 4);
      ctx.lineTo(1, 1);
      ctx.lineTo(1.5, -2);
      ctx.fill();
      
      // Head (small, pointed)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.arc(6, -1, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // White face stripe
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.moveTo(6, -3);
      ctx.lineTo(5.5, 1);
      ctx.lineTo(6.5, 1);
      ctx.lineTo(6, -3);
      ctx.fill();
      
      // Nose
      ctx.fillStyle = "#ff69b4";
      ctx.beginPath();
      ctx.arc(8, -1, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes (small black dots)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.arc(7, -2, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(7, 0, 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Feet (tiny)
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(-4, 3, 2, 1);
      ctx.fillRect(2, 3, 2, 1);
      
      ctx.restore();
    }
  }
  
  function drawStinkClouds(){
    for (let cloud of stinkClouds){
      const x = cloud.x * TILE + TILE / 2;
      const y = cloud.y * TILE + TILE / 2;
      const pulse = Math.sin(cloud.pulse) * 0.2 + 0.8;
      const radius = cloud.radius * TILE;
      
      ctx.save();
      
      // Multiple overlapping smoke puffs for realistic smog
      const puffs = 8;
      for (let i = 0; i < puffs; i++){
        const angle = (Math.PI * 2 / puffs) * i + cloud.pulse;
        const dist = (radius * 0.4) + Math.sin(cloud.pulse + i) * (radius * 0.2);
        const puffX = x + Math.cos(angle) * dist;
        const puffY = y + Math.sin(angle) * dist;
        const puffSize = radius * 0.5 + Math.sin(cloud.pulse * 2 + i) * (radius * 0.1);
        
        ctx.globalAlpha = 0.15 + pulse * 0.1;
        const grad = ctx.createRadialGradient(puffX, puffY, 0, puffX, puffY, puffSize);
        grad.addColorStop(0, 'rgba(150,200,30,0.6)');
        grad.addColorStop(0.4, 'rgba(132,204,22,0.4)');
        grad.addColorStop(1, 'rgba(100,150,10,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Center dense cloud
      ctx.globalAlpha = 0.25 + pulse * 0.15;
      const centerGrad = ctx.createRadialGradient(x, y, 0, x, y, radius * 0.6);
      centerGrad.addColorStop(0, 'rgba(180,220,40,0.7)');
      centerGrad.addColorStop(0.5, 'rgba(132,204,22,0.5)');
      centerGrad.addColorStop(1, 'rgba(100,150,10,0)');
      ctx.fillStyle = centerGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Add some swirly wisps
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = "#a8d944";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      for (let i = 0; i < 3; i++){
        const angle = (Math.PI * 2 / 3) * i + cloud.pulse * 0.5;
        ctx.beginPath();
        ctx.arc(x + Math.cos(angle) * radius * 0.3, 
                y + Math.sin(angle) * radius * 0.3, 
                radius * 0.4, angle, angle + Math.PI);
        ctx.stroke();
      }
      
      ctx.restore();
    }
  }

  // ================================================================
  // SHARKS - Sea Stick (Frogger-style lane patrol!)
  // ================================================================
  let sharks = [];
  let bubbles = [];
  
  function initSharks(){
    sharks = [];
    const numLanes = 5;
    const laneHeight = Math.floor(GRID_H / numLanes);
    
    for (let i = 0; i < 5; i++){
      const lane = Math.floor(Math.random() * numLanes);
      const y = lane * laneHeight + Math.floor(laneHeight / 2);
      const direction = Math.random() > 0.5 ? 1 : -1;
      const x = direction > 0 ? randInt(0, 5) : randInt(GRID_W - 5, GRID_W - 1);
      
      sharks.push({
        x, y,
        direction,
        speed: 0.08 + Math.random() * 0.06,
        lane,
        wiggle: Math.random() * Math.PI * 2
      });
    }
    
    // Init bubbles
    bubbles = [];
    for (let i = 0; i < 15; i++){
      bubbles.push({
        x: Math.random() * CANVAS_W,
        y: Math.random() * CANVAS_H,
        size: 1 + Math.random() * 2,
        speed: 0.3 + Math.random() * 0.5
      });
    }
  }
  
  function updateSharks(){
    if (game.pendingMonster) return;
    
    for (let i = sharks.length - 1; i >= 0; i--){
      const s = sharks[i];
      s.wiggle = (s.wiggle + 0.1) % (Math.PI * 2);
      
      s.x += s.direction * s.speed;
      
      if (s.direction > 0 && s.x > GRID_W + 2){
        s.x = -2;
      } else if (s.direction < 0 && s.x < -2){
        s.x = GRID_W + 2;
      }
      
      // Check collision (HOLE IS SACRED) - must be on exact same tile
      const dx = Math.abs(s.x - game.playerX);
      const dy = Math.abs(s.y - game.playerY);
      if (dx < 0.8 && dy < 0.8 &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield blocked shark!");
          setHud("SHIELD!");
          sharks.splice(i, 1); // Remove shark after shield block
        } else {
          game.lives--;
          logEvent("bad", "Shark attack! -1 life");
          setHud("SHARK BITE!");
          
          // Dramatic shark attack sound - deep underwater doom
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          
          // Deep rumbling bass (shark approaching)
          const bass = audioCtx.createOscillator();
          const bassGain = audioCtx.createGain();
          bass.connect(bassGain);
          bassGain.connect(audioCtx.destination);
          bass.type = "sawtooth";
          bass.frequency.setValueAtTime(60, audioCtx.currentTime);
          bass.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.6);
          bassGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
          bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
          
          // Bite crunch (harsh impact)
          const crunch = audioCtx.createOscillator();
          const crunchGain = audioCtx.createGain();
          crunch.connect(crunchGain);
          crunchGain.connect(audioCtx.destination);
          crunch.type = "square";
          crunch.frequency.setValueAtTime(150, audioCtx.currentTime + 0.15);
          crunch.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.35);
          crunchGain.gain.setValueAtTime(0.2, audioCtx.currentTime + 0.15);
          crunchGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
          
          // High screech (fear/pain)
          const screech = audioCtx.createOscillator();
          const screechGain = audioCtx.createGain();
          screech.connect(screechGain);
          screechGain.connect(audioCtx.destination);
          screech.type = "sine";
          screech.frequency.setValueAtTime(900, audioCtx.currentTime + 0.15);
          screech.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.45);
          screechGain.gain.setValueAtTime(0.15, audioCtx.currentTime + 0.15);
          screechGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.45);
          
          bass.start(audioCtx.currentTime);
          bass.stop(audioCtx.currentTime + 0.6);
          crunch.start(audioCtx.currentTime + 0.15);
          crunch.stop(audioCtx.currentTime + 0.35);
          screech.start(audioCtx.currentTime + 0.15);
          screech.stop(audioCtx.currentTime + 0.45);
          
          spawnSparks(game.playerX, game.playerY, 35, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          
          // Give brief invincibility (1 second) after hit
          game.inputLocked = true;
          setTimeout(() => { game.inputLocked = false; }, 1000);
          
          // Remove this shark after hitting
          sharks.splice(i, 1);
        }
      }
    }
    
    // Update bubbles
    for (let b of bubbles){
      b.y -= b.speed;
      if (b.y < -10){
        b.y = CANVAS_H + 10;
        b.x = Math.random() * CANVAS_W;
      }
    }
  }
  
  function drawSharks(){
    ctx.save();
    
    // Water overlay
    ctx.globalAlpha = 0.15;
    const waterGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    waterGrad.addColorStop(0, 'rgba(0,100,200,0.3)');
    waterGrad.addColorStop(1, 'rgba(0,50,150,0.5)');
    ctx.fillStyle = waterGrad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.globalAlpha = 1;
    
    // Bubbles
    ctx.fillStyle = 'rgba(200,230,255,0.4)';
    for (let b of bubbles){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Sharks
    for (let s of sharks){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const wiggle = Math.sin(s.wiggle) * 2;
      
      ctx.save();
      ctx.translate(x, y + wiggle);
      if (s.direction < 0) ctx.scale(-1, 1);
      
      // Body
      ctx.fillStyle = '#4a6b8a';
      ctx.beginPath();
      ctx.ellipse(0, 0, 14, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Fin
      ctx.fillStyle = '#3a5b7a';
      ctx.beginPath();
      ctx.moveTo(-2, -6);
      ctx.lineTo(2, -10);
      ctx.lineTo(4, -6);
      ctx.fill();
      
      // Tail
      ctx.beginPath();
      ctx.moveTo(-14, 0);
      ctx.lineTo(-18, -4);
      ctx.lineTo(-16, 0);
      ctx.lineTo(-18, 4);
      ctx.fill();
      
      // Eye
      ctx.fillStyle = '#ff3333';
      ctx.beginPath();
      ctx.arc(8, -2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Teeth
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(10, 1);
      ctx.lineTo(12, 3);
      ctx.moveTo(8, 1);
      ctx.lineTo(10, 3);
      ctx.stroke();
      
      ctx.restore();
    }
    
    ctx.restore();
  }

  // ================================================================
  // SUN BURSTS - Sun Stick (steal sticks!)
  // ================================================================
  let sunBurstTiles = [];
  let sunBurstWarningTimer = 0;
  const SUNBURST_WARNING_TIME = 150; // 2.5 seconds
  
  function initSunBursts(){
    sunBurstTiles = [];
    const num = randInt(3, 4);
    for (let i = 0; i < num; i++){
      sunBurstTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        pulse: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSunBursts(){
    for (let b of sunBurstTiles){
      b.pulse = (b.pulse + 0.08) % (Math.PI * 2);
    }
    
    const onBurst = sunBurstTiles.some(b => b.x === game.playerX && b.y === game.playerY);
    if (onBurst){
      sunBurstWarningTimer++;
      if (sunBurstWarningTimer >= SUNBURST_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          sunBurstWarningTimer = 0;
        } else if (activeShield > 0){
          sunBurstWarningTimer = 0;
          logEvent("info", "Shield blocked sun burst!");
          setHud("SHIELD!");
        } else if (game.carry.length > 0){
          const lost = game.carry.length;
          game.carry = [];
          sunBurstWarningTimer = 0;
          logEvent("bad", `Sun burst stole ${lost} sticks!`);
          setHud("SUN BURST!");
          beep(500, 0.12, "sine", 0.08);
          spawnSparks(game.playerX, game.playerY, 22, true);
          updateUI();
        } else {
          sunBurstWarningTimer = 0;
        }
      } else if (sunBurstWarningTimer === 60 || sunBurstWarningTimer === 120){
        beep(450, 0.1, "sine", 0.06);
        logEvent("warn", "Sun burst! Move!");
        setHud("SUN BURST!");
      }
    } else {
      sunBurstWarningTimer = 0;
    }
  }
  
  function drawSunBursts(){
    ctx.save();
    for (let b of sunBurstTiles){
      const x = b.x * TILE + TILE / 2;
      const y = b.y * TILE + TILE / 2;
      const pulse = Math.sin(b.pulse) * 0.5 + 0.5;
      
      // Glowing burst
      ctx.globalAlpha = 0.3 + pulse * 0.4;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 6);
      grad.addColorStop(0, 'rgba(255,212,0,0.8)');
      grad.addColorStop(1, 'rgba(255,180,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Rays
      ctx.globalAlpha = 0.6 + pulse * 0.4;
      ctx.strokeStyle = '#ffd400';
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI / 4) * i + b.pulse;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
        ctx.stroke();
      }
    }
    
    // Warning indicator
    if (sunBurstWarningTimer > 0){
      const onBurst = sunBurstTiles.some(b => b.x === game.playerX && b.y === game.playerY);
      if (onBurst){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(sunBurstWarningTimer * 0.3) * 0.5 + 0.5;
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#ffd400';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Special power-up sticks
  let activeSpeedBoost = 0; // Remaining free moves
  let activeShield = 0; // Remaining shield time in frames (1800 = 30 seconds)
  let visionRevealed = false; // Whether vision stick revealed the secret
  let visionTimer = 0; // How long vision effect lasts (1800 = 30 seconds)
  
  function pickupSpecialStick(type){
    if (type === "speed"){
      activeSpeedBoost = 10;
      logEvent("bonus", "SPEED STICK! Next 10 moves are free!");
      setHud("SPEED BOOST!");
      playSpeedStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "shield"){
      activeShield = 1800; // 30 seconds
      logEvent("bonus", "SHIELD STICK! 30 sec immunity!");
      setHud("SHIELD ACTIVE!");
      playShieldStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "vision"){
      visionRevealed = true;
      visionTimer = 1800; // 30 seconds
      logEvent("bonus", "VISION STICK! 30 sec reveal!");
      setHud("VISION ACTIVATED!");
      playVisionStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    }
  }
  
  function updateSpecialEffects(){
    if (activeShield > 0) activeShield--;
    if (visionTimer > 0){
      visionTimer--;
      if (visionTimer <= 0) visionRevealed = false;
    }
  }
  
  function drawSpecialEffects(){
    // Draw shield indicator around player
    if (activeShield > 0){
      const px = game.playerX * TILE + TILE / 2;
      const py = game.playerY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
      
      ctx.save();
      ctx.strokeStyle = '#3aa7ff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      ctx.shadowColor = '#3aa7ff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(px, py, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw vision effect - pulsing glow on secret square
    if (visionRevealed && !game.lifeTileUsed){
      const sx = game.lifeTileX * TILE + TILE / 2;
      const sy = game.lifeTileY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 150) * 0.5 + 0.5;
      
      ctx.save();
      ctx.globalAlpha = 0.3 + pulse * 0.4;
      const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, TILE);
      gradient.addColorStop(0, 'rgba(255,212,0,0.8)');
      gradient.addColorStop(1, 'rgba(255,212,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(game.lifeTileX * TILE, game.lifeTileY * TILE, TILE, TILE);
      ctx.restore();
    }
  }


  // Level-specific hazards
  let darkTiles = [];
  let darkTileTimer = 0;
  let teleportTiles = [];
  let teleportMoveTimer = 0;
  let holeFlashTimer = 0;
  let holeMoveTimer = 0;
  
  function initLevelHazards(){
    windGustTimer = 0;
    darkTiles = [];
    darkTileTimer = 0;
    teleportTiles = [];
    
    const theme = currentLevelTheme().name;
    
    // Sky Stick: No setup needed, wind happens randomly
    
    // Glow Stick: Create tiles that can go dark
    if (theme === "Glow Stick"){
      darkTileTimer = randInt(180, 420); // 3-7 seconds until first dark
    }
    
    // Spell Stick: Create 5-8 MOVING teleport tiles + moving hole
    if (theme === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900); // 10-15 seconds
      holeFlashTimer = 0;
    }
  }
  
  function updateLevelHazards(){
    const theme = currentLevelTheme().name;
    
    // Sky Stick: Random wind gusts
    if (theme === "Sky Stick"){
      windGustTimer++;
      if (windGustTimer >= randInt(180, 360)){ // Every 3-6 seconds
        windGustTimer = 0;
        if (!game.inputLocked && game.actions > 0){
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          const newX = clamp(game.playerX + dir.dx, 0, GRID_W - 1);
          const newY = clamp(game.playerY + dir.dy, 0, GRID_H - 1);
          
          // Don't push into hole
          if (newX !== game.holeX || newY !== game.holeY){
            game.playerX = newX;
            game.playerY = newY;
        
            logEvent("info", "Wind gust pushed you!");
            setHud("WIND GUST!");
            spawnSparks(game.playerX, game.playerY, 12, false);
          }
        }
      }
    }
    
    // Glow Stick: Tiles go dark periodically
    if (theme === "Glow Stick"){
      if (darkTiles.length === 0){
        darkTileTimer--;
        if (darkTileTimer <= 0){
          // Create 4-8 dark tiles
          const numDark = randInt(4, 8);
          for (let i = 0; i < numDark; i++){
            darkTiles.push({
              x: randInt(0, GRID_W - 1),
              y: randInt(0, GRID_H - 1),
              life: 180 + randInt(0, 120) // 3-5 seconds
            });
          }
          logEvent("info", "Some tiles went dark!");
        }
      } else {
        // Update existing dark tiles
        for (let i = darkTiles.length - 1; i >= 0; i--){
          darkTiles[i].life--;
          if (darkTiles[i].life <= 0){
            darkTiles.splice(i, 1);
          }
        }
        if (darkTiles.length === 0){
          darkTileTimer = randInt(180, 420); // Reset timer
        }
      }
    }
    
    // Spell Stick: MOVING teleport tiles + MOVING hole
    if (theme === "Spell Stick"){
      // Animate and move teleport tiles
      for (let tile of teleportTiles){
        tile.glow = (tile.glow + 0.08) % (Math.PI * 2);
        
        // Move teleports
        tile.moveTimer--;
        if (tile.moveTimer <= 0){
          tile.moveTimer = randInt(180, 360); // 3-6 seconds
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          tile.x = clamp(tile.x + dir.dx, 0, GRID_W - 1);
          tile.y = clamp(tile.y + dir.dy, 0, GRID_H - 1);
        }
      }
      
      // Check if player stepped on teleport (flash warning 1 sec before)
      const onTeleport = teleportTiles.find(t => t.x === game.playerX && t.y === game.playerY);
      if (onTeleport && !onTeleport.flashWarning){
        onTeleport.flashWarning = 60; // 1 second warning
      }
      if (onTeleport && onTeleport.flashWarning > 0){
        onTeleport.flashWarning--;
        if (onTeleport.flashWarning === 0){
          // Teleport!
          let newX, newY;
          do {
            newX = randInt(0, GRID_W - 1);
            newY = randInt(0, GRID_H - 1);
          } while ((newX === game.holeX && newY === game.holeY) || 
                   (newX === game.playerX && newY === game.playerY));
          
          spawnSparks(game.playerX, game.playerY, 18, false);
          game.playerX = newX;
          game.playerY = newY;
          spawnSparks(game.playerX, game.playerY, 18, false);
          logEvent("info", "Teleported!");
          setHud("TELEPORT!");
          beep(550, 0.1, "sine", 0.08);
          delete onTeleport.flashWarning;
        }
      }
      
      // Moving hole
      holeMoveTimer--;
      if (holeMoveTimer <= 180 && holeMoveTimer > 0){
        // Flash warning (last 3 seconds)
        holeFlashTimer++;
      }
      if (holeMoveTimer <= 0){
        // Move hole!
        let newHoleX, newHoleY;
        do {
          newHoleX = randInt(0, GRID_W - 1);
          newHoleY = randInt(0, GRID_H - 1);
        } while (newHoleX === game.holeX && newHoleY === game.holeY);
        
        spawnSparks(game.holeX, game.holeY, 24, false);
        game.holeX = newHoleX;
        game.holeY = newHoleY;
        spawnSparks(game.holeX, game.holeY, 24, false);
        holeMoveTimer = randInt(600, 900);
        holeFlashTimer = 0;
        logEvent("info", "Hole teleported!");
        setHud("HOLE MOVED!");
      }
    }
  }
  
  function drawLevelHazards(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    // Draw dark tiles for Glow Stick
    if (theme === "Glow Stick" && darkTiles.length > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      for (let tile of darkTiles){
        ctx.fillRect(tile.x * TILE, tile.y * TILE, TILE, TILE);
      }
    }
    
    // Draw teleport tiles for Spell Stick
    if (theme === "Spell Stick" && teleportTiles.length > 0){
      for (let tile of teleportTiles){
        const x = tile.x * TILE + TILE / 2;
        const y = tile.y * TILE + TILE / 2;
        const pulse = Math.sin(tile.glow) * 0.5 + 0.5;
        
        // Teleport glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
        gradient.addColorStop(0, 'rgba(255,105,255,' + (0.4 + pulse * 0.3) + ')');
        gradient.addColorStop(1, 'rgba(255,105,255,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Teleport symbol (spiral)
        ctx.strokeStyle = 'rgba(255,105,255,' + (0.6 + pulse * 0.4) + ')';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < Math.PI * 4; i += 0.3){
          const r = (i / (Math.PI * 4)) * 6;
          const px = x + Math.cos(i + tile.glow) * r;
          const py = y + Math.sin(i + tile.glow) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }
    
    ctx.restore();
  }


  // Theme-specific ambient particles
  let ambientParticles = [];
  
  function initAmbientParticles(){
    ambientParticles = [];
    const theme = currentLevelTheme().name;
    
    // Sun Stick: Light rays
    if (theme === "Sun Stick"){
      for (let i = 0; i < 5; i++){
        ambientParticles.push({
          type: 'sunray',
          x: randInt(0, CANVAS_W),
          y: -20,
          angle: Math.random() * 0.4 - 0.2,
          speed: 0.3 + Math.random() * 0.3,
          opacity: Math.random() * 0.3 + 0.1
        });
      }
    }
    
    // Snake Stick: No particles (snakes are the hazard)
    
    // Victory Stick: Stars/sparkles
    if (theme === "Victory Stick"){
      for (let i = 0; i < 25; i++){
        ambientParticles.push({
          type: 'star',
          x: Math.random() * CANVAS_W,
          y: Math.random() * CANVAS_H,
          size: 1 + Math.random() * 2,
          twinkle: Math.random() * Math.PI * 2,
          twinkleSpeed: 0.05 + Math.random() * 0.05
        });
      }
    }
  }
  
  let shootingStarTimer = randInt(180, 360);
  
  // Night Stick: Glowing 5-point stars on grid
  let starGridTiles = [];
  let playerGlowTimer = 0;
  
  function initStarGrid(){
    starGridTiles = [];
    const numStars = randInt(8, 12);
    for (let i = 0; i < numStars; i++){
      starGridTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        twinkle: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateStarGrid(){
    for (let s of starGridTiles){
      s.twinkle = (s.twinkle + 0.05) % (Math.PI * 2);
      
      // Check if player touched star
      if (s.x === game.playerX && s.y === game.playerY){
        playerGlowTimer = 180; // 3 seconds glow
        spawnSparks(game.playerX, game.playerY, 12, false);
        beep(800, 0.08, "sine", 0.05);
      }
    }
    
    if (playerGlowTimer > 0) playerGlowTimer--;
  }
  
  function drawStarGrid(){
    ctx.save();
    
    // Draw stars on grid
    for (let s of starGridTiles){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const twinkle = Math.sin(s.twinkle) * 0.5 + 0.5;
      
      // Glow
      ctx.globalAlpha = 0.2 + twinkle * 0.3;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2);
      grad.addColorStop(0, 'rgba(255,220,100,0.6)');
      grad.addColorStop(1, 'rgba(255,220,100,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2, 0, Math.PI * 2);
      ctx.fill();
      
      // 5-point star
      ctx.globalAlpha = 0.7 + twinkle * 0.3;
      ctx.fillStyle = '#ffd166';
      ctx.shadowColor = '#ffd166';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      const size = 4;
      for (let i = 0; i < 5; i++){
        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
        const px = x + Math.cos(angle) * size;
        const py = y + Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
        
        const innerAngle = angle + Math.PI / 5;
        const ipx = x + Math.cos(innerAngle) * (size * 0.4);
        const ipy = y + Math.sin(innerAngle) * (size * 0.4);
        ctx.lineTo(ipx, ipy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  function drawPlayerGlow(){
    if (playerGlowTimer <= 0) return;
    
    const px = game.playerX * TILE + TILE / 2;
    const py = game.playerY * TILE + TILE / 2;
    const pulse = Math.sin(playerGlowTimer * 0.2) * 0.5 + 0.5;
    
    ctx.save();
    ctx.globalAlpha = 0.3 + pulse * 0.4;
    const grad = ctx.createRadialGradient(px, py, 0, px, py, TILE);
    grad.addColorStop(0, 'rgba(255,220,100,0.8)');
    grad.addColorStop(1, 'rgba(255,220,100,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(px, py, TILE, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha = 1;
  } // 3-6 seconds (more frequent!)
  
  function updateAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    // Shooting stars for Night Stick
    if (theme === "Night Stick"){
      shootingStarTimer--;
      if (shootingStarTimer <= 0){
        shootingStarTimer = randInt(600, 1200);
        ambientParticles.push({
          type: 'shootingStar',
          x: Math.random() * CANVAS_W,
          y: Math.random() * (CANVAS_H / 2),
          vx: 2 + Math.random() * 2,
          vy: 0.8 + Math.random() * 1,
          life: 60 + Math.random() * 40
        });
      }
    }
    
    // Remove dead shooting stars
    ambientParticles = ambientParticles.filter(p => p.type !== 'shootingStar' || p.life > 0);
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        p.y += p.speed;
        if (p.y > CANVAS_H + 50){
          p.y = -50;
          p.x = randInt(0, CANVAS_W);
        }
      } else if (p.type === 'star'){
        p.twinkle += p.twinkleSpeed;
      } else if (p.type === 'shootingStar'){
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
      }
    }
  }
  
  function drawAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    // Remove dead shooting stars
    ambientParticles = ambientParticles.filter(p => p.type !== 'shootingStar' || p.life > 0);
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.globalAlpha = p.opacity * 0.3;
        
        // Wide beam shape (not stick-like)
        const gradient = ctx.createLinearGradient(0, 0, 0, 60);
        gradient.addColorStop(0, 'rgba(255,212,0,0.6)');
        gradient.addColorStop(1, 'rgba(255,212,0,0)');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.lineTo(-4, 60);
        ctx.lineTo(4, 60);
        ctx.lineTo(8, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      } else if (p.type === 'star'){
        const twinkle = Math.sin(p.twinkle) * 0.5 + 0.5;
        ctx.globalAlpha = 0.3 + twinkle * 0.5;
        ctx.fillStyle = '#c27bff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Star points
        if (twinkle > 0.5){
          ctx.strokeStyle = '#c27bff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(p.x - p.size * 2, p.y);
          ctx.lineTo(p.x + p.size * 2, p.y);
          ctx.moveTo(p.x, p.y - p.size * 2);
          ctx.lineTo(p.x, p.y + p.size * 2);
          ctx.stroke();
        }
      } else if (p.type === 'shootingStar'){
        const alpha = p.life / 60;
        ctx.globalAlpha = alpha * 0.9;
        
        // Shooting star trail
        const grad = ctx.createLinearGradient(p.x, p.y, p.x - p.vx * 5, p.y - p.vy * 5);
        grad.addColorStop(0, 'rgba(255,255,200,0.9)');
        grad.addColorStop(1, 'rgba(200,220,255,0)');
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - p.vx * 5, p.y - p.vy * 5);
        ctx.stroke();
        
        // Star head
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  // Ice frost effect on screen edges
  function drawIceFrost(){
    if (currentLevelTheme().name !== "Ice Stick") return;
    
    ctx.save();
    
    // Top frost
    const topGrad = ctx.createLinearGradient(0, 0, 0, 40);
    topGrad.addColorStop(0, 'rgba(200,230,255,0.2)');
    topGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = topGrad;
    ctx.fillRect(0, 0, CANVAS_W, 40);
    
    // Bottom frost
    const botGrad = ctx.createLinearGradient(0, CANVAS_H - 40, 0, CANVAS_H);
    botGrad.addColorStop(0, 'rgba(200,230,255,0)');
    botGrad.addColorStop(1, 'rgba(200,230,255,0.2)');
    ctx.fillStyle = botGrad;
    ctx.fillRect(0, CANVAS_H - 40, CANVAS_W, 40);
    
    // Left frost
    const leftGrad = ctx.createLinearGradient(0, 0, 40, 0);
    leftGrad.addColorStop(0, 'rgba(200,230,255,0.15)');
    leftGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = leftGrad;
    ctx.fillRect(0, 0, 40, CANVAS_H);
    
    // Right frost
    const rightGrad = ctx.createLinearGradient(CANVAS_W - 40, 0, CANVAS_W, 0);
    rightGrad.addColorStop(0, 'rgba(200,230,255,0)');
    rightGrad.addColorStop(1, 'rgba(200,230,255,0.15)');
    ctx.fillStyle = rightGrad;
    ctx.fillRect(CANVAS_W - 40, 0, 40, CANVAS_H);
    
    ctx.restore();
  }



  



  // Draw a custom stick monster instead of emoji
  function drawStickMonster(x, y, anger){
    ctx.save();
    ctx.translate(x, y);
    
    // Monster is made of evil sticks!
    const shake = Math.sin(Date.now() / 100) * (anger * 2);
    
    // Body - jagged sticks forming a scary shape
    ctx.strokeStyle = '#ff1f3a';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.shadowColor = '#ff1f3a';
    ctx.shadowBlur = 8;
    
    // Main body sticks (X shape)
    ctx.beginPath();
    ctx.moveTo(-12 + shake, -12);
    ctx.lineTo(12 - shake, 12);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(12 - shake, -12);
    ctx.lineTo(-12 + shake, 12);
    ctx.stroke();
    
    // Extra angry sticks pointing out
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-15, 0);
    ctx.lineTo(-22 + shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(22 - shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(3, -22 - shake);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 15);
    ctx.lineTo(-3, 22 + shake);
    ctx.stroke();
    
    // Glowing evil eyes
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff5a6a';
    ctx.beginPath();
    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Evil eye pupils
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#1a0005';
    ctx.beginPath();
    ctx.arc(-5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Angry mouth (jagged)
    ctx.strokeStyle = '#ff5a6a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-6, 4);
    ctx.lineTo(-3, 7);
    ctx.lineTo(0, 4);
    ctx.lineTo(3, 7);
    ctx.lineTo(6, 4);
    ctx.stroke();
    
    ctx.restore();
  }

  // Hole fading for higher levels (7+)
  let holeFadeTimer = 0;
  let holeFadeInterval = 200;
  let holeVisible = true;

  const LOG_MAX_LINES = 12;

  /* ---- Max life bonus points (when a life reward is blocked) ---- */
  const MAX_LIVES = 5;
  const LIFE_TILE_MAX_POINTS = 12;
  const TREE_FEED_MAX_POINTS = 8;

  /* ---- Music ---- */
  const MUSIC_STEP_MS = 245;
  let musicOn = false;
  let musicTimer = null;
  let musicStep = 0;

  let celebrationUntil = 0;
  let celebrationStep = 0;

  let doomUntil = 0;
  let doomStep = 0;

  const MUSIC_A = [
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.040 },
    { lead:330, bass:98, dur:0.16, gain:0.038 },
    { lead:294, bass:98, dur:0.16, gain:0.038 },
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:392, bass:110, dur:0.16, gain:0.038 },
    { lead:330, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_B = [
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:494, bass:110, dur:0.16, gain:0.038 },
    { lead:523, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:294, bass:98, dur:0.16, gain:0.036 },
    { chord:[247,311,370], bass:92, dur:0.18, gain:0.040 },
    { lead:370, bass:92, dur:0.16, gain:0.038 },
    { lead:330, bass:92, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_CELEB = [
    { chord:[523,659,784], bass:131, dur:0.18, gain:0.052 },
    { lead:784, bass:131, dur:0.14, gain:0.050 },
    { lead:988, bass:131, dur:0.14, gain:0.050 },
    { chord:[659,784,988], bass:147, dur:0.18, gain:0.052 },
    { lead:1175, bass:147, dur:0.14, gain:0.050 },
    { lead:988, bass:147, dur:0.14, gain:0.048 },
    { chord:[587,740,880], bass:110, dur:0.18, gain:0.050 },
    { lead:880, bass:110, dur:0.14, gain:0.048 },
    { lead:988, bass:110, dur:0.14, gain:0.048 },
    { chord:[659,784,988], bass:131, dur:0.18, gain:0.052 },
    { lead:0 }
  ];

  const MUSIC_DOOM = [
    { lead:988, dur:0.14, gain:0.080, type:"square" },
    { lead:932, dur:0.14, gain:0.080, type:"square" },
    { lead:880, dur:0.14, gain:0.080, type:"square" },
    { lead:784, dur:0.16, gain:0.082, type:"square" },
    { lead:698, dur:0.18, gain:0.082, type:"square" },
    { lead:622, dur:0.20, gain:0.082, type:"square" },
    { lead:554, dur:0.22, gain:0.082, type:"square" },
    { lead:466, dur:0.24, gain:0.082, type:"square" },
    { lead:392, dur:0.28, gain:0.082, type:"square" },
    { lead:0 }
  ];

  function startCelebrationMusic(ms=6500){
    if (!musicOn) return;
    celebrationUntil = Date.now() + ms;
    celebrationStep = 0;
  }
  function startDoomMusic(ms=6500){
    if (!musicOn) return;
    doomUntil = Date.now() + ms;
    doomStep = 0;
  }

  function pickMusicStep(stepIdx){
    const block = Math.floor(stepIdx / 32);
    const useB = (block % 2 === 1);
    const seq = useB ? MUSIC_B : MUSIC_A;
    const s = seq[stepIdx % seq.length];
    if (s && s.lead && Math.random() < 0.10){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickCelebrationStep(){
    const s = MUSIC_CELEB[celebrationStep++ % MUSIC_CELEB.length];
    if (s && s.lead && Math.random() < 0.18){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickDoomStep(){
    const s = MUSIC_DOOM[doomStep++ % MUSIC_DOOM.length];
    return s;
  }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const ui = {
    log: document.getElementById("log"),
    battleLog: document.getElementById("battleLog"),
    themeMini: document.getElementById("uiThemeMini"),
    controlsScroll: document.getElementById("controlsScroll"),
    scrollHint: document.getElementById("scrollHint"),

    player: document.getElementById("uiPlayer"),
    skin: document.getElementById("uiSkin"),

    lives: document.getElementById("uiLives"),
    level: document.getElementById("uiLevel"),
    score: document.getElementById("uiScore"),
    actions: document.getElementById("uiActions"),
    mode: document.getElementById("uiMode"),
    die: document.getElementById("uiDie"),
    carry: document.getElementById("uiCarry"),
    left: document.getElementById("uiLeft"),

    diceBox: document.getElementById("diceBox"),
    diceFace: document.getElementById("diceFace"),
    diceLabel: document.getElementById("diceLabel"),

    btnRoll: document.getElementById("btnRoll"),
    btnUse: document.getElementById("btnUse"),
    btnNew: document.getElementById("btnNew"),
    btnPause: document.getElementById("btnPause"),
    btnMusic: document.getElementById("btnMusic"),

    btnUp: document.getElementById("btnUp"),
    btnDown: document.getElementById("btnDown"),
    btnLeft: document.getElementById("btnLeft"),
    btnRight: document.getElementById("btnRight"),

    btnSave: document.getElementById("btnSave"),
    btnLoad: document.getElementById("btnLoad"),

    infoOverlay: document.getElementById("infoOverlay"),
    btnInfo: document.getElementById("btnInfo"),
    btnInfoClose: document.getElementById("btnInfoClose"),

    nameOverlay: document.getElementById("nameOverlay"),
    nameInput: document.getElementById("nameInput"),
    nameStartBtn: document.getElementById("nameStartBtn"),
    nameUseSavedBtn: document.getElementById("nameUseSavedBtn"),
    nameUseP1Btn: document.getElementById("nameUseP1Btn"),
    savedNameHint: document.getElementById("savedNameHint"),

    pauseOverlay: document.getElementById("pauseOverlay"),
    btnPauseClose: document.getElementById("btnPauseClose"),

    gameOverOverlay: document.getElementById("gameOverOverlay"),
    gameOverText: document.getElementById("gameOverText"),
    btnRestart: document.getElementById("btnRestart"),
    btnGameOverClose: document.getElementById("btnGameOverClose"),

    winOverlay: document.getElementById("winOverlay"),
    winText: document.getElementById("winText"),
    btnWinRestart: document.getElementById("btnWinRestart"),

    leaderboard: document.getElementById("leaderboard"),

    monsterEvent: document.getElementById("monsterEvent"),
    monsterEventText: document.getElementById("monsterEventText"),

    winFx: document.getElementById("winFx"),
    loseFx: document.getElementById("loseFx"),
  };

  const LOG_STYLE = {
    neutral: { color:"#e5e7eb", icon:"" },
    roll:    { color:"#e5e7eb", icon:"üé≤ " },
    place:   { color:"#e5e7eb", icon:"üìç " },
    pickup:  { color:"#e5e7eb", icon:"ü™µ " },
    deposit: { color:"#39ff95", icon:"‚ú® " },
    bonus:   { color:"#c27bff", icon:"üí• " },
    level:   { color:"#ffd166", icon:"üèÜ " },
    warn:    { color:"#ffb347", icon:"‚ö†Ô∏è " },
    bad:     { color:"#ff5a6a", icon:"üíÄ " },
    monster: { color:"#ff1f3a", icon:"üëπ " },
    save:    { color:"#ffd166", icon:"üíæ " },
    load:    { color:"#a8dadc", icon:"üìÇ " },
    win:     { color:"#f3f4f6", icon:"üåü " },
  };

  function prependToLog(el, line){
    if (!el) return;
    el.prepend(line);
    while (el.children.length > LOG_MAX_LINES) el.removeChild(el.lastChild);
  }

  function logEvent(kind, msg){
    const st = LOG_STYLE[kind] || LOG_STYLE.neutral;

    const line1 = document.createElement("div");
    line1.className = "line";
    line1.style.color = st.color;
    line1.textContent = (st.icon || "") + msg;

    const line2 = line1.cloneNode(true);

    prependToLog(ui.log, line1);
    prependToLog(ui.battleLog, line2);
  }

  function loadLeaderboard(){
    try{
      const raw = localStorage.getItem(LS_LEADERBOARD);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveLeaderboard(arr){
    localStorage.setItem(LS_LEADERBOARD, JSON.stringify(arr));
  }
  function upsertLeaderboardEntry(name, score, level){
    const n = (name || "PLAYER1").toUpperCase();
    const lb = loadLeaderboard();
    const filtered = lb.filter(e => (e?.name || "").toUpperCase() !== n);
    filtered.push({ name:n, score: Number(score)||0, level: Number(level)||1 });
    filtered.sort((x,y) => {
      if (y.score !== x.score) return y.score - x.score;
      return y.level - x.level;
    });
    const top3 = filtered.slice(0,3);
    saveLeaderboard(top3);
    renderLeaderboard(top3);
  }
  function renderLeaderboard(lb){
    const rows = (lb && lb.length) ? lb : loadLeaderboard();
    ui.leaderboard.innerHTML = "";
    if (!rows.length){
      ui.leaderboard.innerHTML = `<div style="color:#9fb1c6;">No scores yet. Play a game.</div>`;
      return;
    }
    const medals = ["gold","silver","bronze"];
    rows.forEach((e, idx) => {
      const wrap = document.createElement("div");
      wrap.className = "leaderRow";
      const medalClass = medals[idx] || "";
      wrap.innerHTML = `
        <div>
          <div class="leaderName ${medalClass}">${escapeHtml(e.name || "PLAYER1")}</div>
          <div class="leaderMeta">Lvl ${Number(e.level)||1}</div>
        </div>
        <div class="big">${Number(e.score)||0}</div>
      `;
      ui.leaderboard.appendChild(wrap);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function isPhone(){
    return window.matchMedia && window.matchMedia("(max-width:720px)").matches;
  }
  function updateScrollHint(){
    if (!ui.scrollHint || !ui.controlsScroll) return;
    if (!isPhone()){ ui.scrollHint.style.display = "none"; return; }
    if (sessionStorage.getItem(SS_SCROLLED) === "1"){ ui.scrollHint.style.display = "none"; return; }
    const canScroll = ui.controlsScroll.scrollHeight > (ui.controlsScroll.clientHeight + 6);
    const atTop = ui.controlsScroll.scrollTop <= 2;
    ui.scrollHint.style.display = (canScroll && atTop) ? "block" : "none";
  }
  ui.controlsScroll?.addEventListener("scroll", () => {
    if (!isPhone()) return;
    if (ui.controlsScroll.scrollTop > 20){
      sessionStorage.setItem(SS_SCROLLED, "1");
      updateScrollHint();
    }
  }, { passive:true });
  window.addEventListener("resize", () => setTimeout(updateScrollHint, 60), { passive:true });

  /* ---------- AUDIO ---------- */
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  async function unlockAudio(){
    try{
      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.00001;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.01);
      audioUnlocked = true;
    }catch(_){}
  }
  const unlockOnce = async () => {
    if (audioUnlocked) return;
    await unlockAudio();
  };
  document.addEventListener("touchstart", unlockOnce, { passive:true });
  document.addEventListener("pointerdown", unlockOnce, { passive:true });

  function beep(freq=440, dur=0.08, type="sine", gain=0.08){
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.linearRampToValueAtTime(0, t0 + dur);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }catch(e){}
  }
  function chord(freqs=[440,550], dur=0.12, gain=0.05, type="triangle"){
    freqs.forEach((f)=>beep(f, dur, type, gain));
  }

  function startMusic(){
    ensureAudio();
    if (musicTimer) return;
    musicStep = 0;
    musicTimer = setInterval(() => {
      if (!musicOn) return;
      if (game.pendingMonster) return;

      const now = Date.now();
      const inDoom = now < doomUntil;
      const inCelebration = (!inDoom) && (now < celebrationUntil);

      const step = inDoom ? pickDoomStep() : (inCelebration ? pickCelebrationStep() : pickMusicStep(musicStep++));
      if (!step) return;

      const hasChord = Array.isArray(step.chord) && step.chord.length;
      const hasLead  = step.lead && !hasChord;
      const hasBass  = step.bass;

      if (!hasChord && !hasLead && !hasBass) return;

      const dur  = step.dur  ?? 0.16;
      const gain = step.gain ?? 0.040;
      const oscType = step.type || "triangle";

      if (hasChord){
        chord(step.chord, dur, gain, oscType);
      } else if (hasLead){
        beep(step.lead, dur, oscType, gain);
      }
      if (hasBass){
        beep(step.bass, dur * 1.2, "sine", gain * 0.70);
      }
    }, MUSIC_STEP_MS);
  }
  function stopMusic(){
    if (musicTimer){ clearInterval(musicTimer); musicTimer = null; }
  }

  /* ---- Pause (true pause: stops loop, stops music, freezes timeouts) ---- */
  let paused = false;
  let rafId = null;
  let pauseStartedAt = 0;
  let pausePrevInputLocked = false;
  let pausePrevMusicOn = false;

  const activeTimeouts = new Map();
  let pausedTimeouts = [];

  function gameSetTimeout(fn, ms){
    const due = Date.now() + ms;
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.set(id, { fn, due });
    return id;
  }
  function pauseAllGameTimeouts(){
    const now = Date.now();
    pausedTimeouts = [];
    for (const [id, meta] of activeTimeouts.entries()){
      clearTimeout(id);
      pausedTimeouts.push({ fn: meta.fn, ms: Math.max(0, meta.due - now) });
    }
    activeTimeouts.clear();
  }
  function resumeAllGameTimeouts(){
    const list = pausedTimeouts.slice();
    pausedTimeouts = [];
    list.forEach(t => gameSetTimeout(t.fn, t.ms));
  }

  function startLoop(){
    if (rafId) return;
    rafId = requestAnimationFrame(loop);
  }

  function stopMonsterDoom(){
    if (monsterDoomStingTimer){
      clearTimeout(monsterDoomStingTimer);
      monsterDoomStingTimer = null;
    }
  }

  function pauseGame(){
    if (paused) return;
    if (ui.nameOverlay.style.display === "flex") return;

    paused = true;
    pauseStartedAt = Date.now();

    pausePrevInputLocked = game.inputLocked;
    game.inputLocked = true;

    pausePrevMusicOn = musicOn;
    if (musicOn) stopMusic();
    stopMonsterDoom();

    pauseAllGameTimeouts();

    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    ui.pauseOverlay.style.display = "flex";
    ui.btnPause.textContent = "‚ñ∂ Resume";
  }

  function resumeGame(){
    if (!paused) return;

    const now = Date.now();
    const delta = Math.max(0, now - pauseStartedAt);

    if (celebrationUntil) celebrationUntil += delta;
    if (doomUntil) doomUntil += delta;

    paused = false;

    ui.pauseOverlay.style.display = "none";
    ui.btnPause.textContent = "‚è∏ Pause";

    game.inputLocked = pausePrevInputLocked;

    resumeAllGameTimeouts();
    startLoop();

    if (pausePrevMusicOn && musicOn){
      startMusic();
      if (game.pendingMonster) playMonsterDoomSting();
    }
  }

  function togglePause(){
    if (paused) resumeGame();
    else pauseGame();
  }

  /* ---- Stick Monster: doom sting (battle intro) ---- */
  let monsterDoomStingTimer = null;

  function playMonsterDoomSting(){
    if (!musicOn) return;
    ensureAudio();
    stopMonsterDoom();

    const seq = [
      () => { beep(55, 0.22, "sawtooth", 0.10); beep(73.4, 0.20, "sawtooth", 0.08); chord([110,131,165], 0.14, 0.055, "triangle"); },
      () => { beep(49, 0.22, "sawtooth", 0.10); chord([98,117,147], 0.16, 0.055, "triangle"); },
      () => { beep(55, 0.26, "sawtooth", 0.10); chord([110,147,165], 0.14, 0.055, "triangle"); },
      () => { beep(41.2, 0.28, "sawtooth", 0.10); chord([82,98,123], 0.18, 0.055, "triangle"); },
      () => { beep(55, 0.30, "sawtooth", 0.10); chord([110,131,165], 0.18, 0.055, "triangle"); }
    ];

    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (!game.pendingMonster) return;
      if (i >= seq.length) return;
      seq[i++]();
      monsterDoomStingTimer = gameSetTimeout(step, 480);
    };
    step();
  }

  function playPacmanDeathSting(){
    if (!musicOn) return;
    ensureAudio();
    const notes = [988, 932, 880, 784, 698, 622, 554, 466, 392];
    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (i >= notes.length) return;
      beep(notes[i++], 0.11 + i*0.01, "square", 0.095);
      gameSetTimeout(step, 90);
    };
    step();
  }

  /* ---- SFX ---- */
  function sfxRoll(){ beep(320,0.06,"square",0.06); beep(420,0.07,"square",0.05); }
  function sfxPickup(){ beep(740,0.06,"triangle",0.07); }
  function sfxPlace(){ beep(420,0.07,"triangle",0.05); }
  function sfxDeposit(){ chord([520,660,780],0.14,0.06,"triangle"); }
  function sfxError(){ beep(160,0.08,"sawtooth",0.06); }
  function sfxZeroBad(){ beep(120,0.10,"sawtooth",0.07); beep(90,0.12,"sawtooth",0.06); }
  function sfxBonus(){ chord([660,880],0.16,0.06,"triangle"); }
  // Special power-up stick sounds
  function playSpeedStickSound(){
    // Fast ascending notes
    setTimeout(() => beep(440, 0.08, "square", 0.12), 0);
    setTimeout(() => beep(554, 0.08, "square", 0.12), 80);
    setTimeout(() => beep(659, 0.08, "square", 0.12), 160);
    setTimeout(() => beep(880, 0.12, "square", 0.15), 240);
  }
  
  function playShieldStickSound(){
    // Power-up ascending chord
    setTimeout(() => chord([330, 440, 554], 0.15, 0.1, "triangle"), 0);
    setTimeout(() => chord([440, 554, 659], 0.15, 0.1, "triangle"), 150);
    setTimeout(() => chord([554, 659, 880], 0.2, 0.12, "triangle"), 300);
  }
  
  function playVisionStickSound(){
    // Mystical sparkle sound
    setTimeout(() => beep(659, 0.08, "sine", 0.1), 0);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 70);
    setTimeout(() => beep(1047, 0.08, "sine", 0.1), 140);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 210);
    setTimeout(() => beep(1175, 0.15, "sine", 0.12), 280);
  }

  function sfxExtraLife(){ chord([523,659,784],0.20,0.06,"triangle"); chord([659,784,988],0.22,0.06,"triangle"); }
  function sfxMonsterHit(){ beep(70,0.16,"sawtooth",0.08); beep(55,0.18,"sawtooth",0.08); }
  function sfxLevelUp(){
    chord([440,660,880],0.18,0.06,"triangle");
    chord([494,740,988],0.18,0.06,"triangle");
    chord([523,784,1046],0.22,0.06,"triangle");
  }
  function sfxWin(){
    // Pac-Man style victory fanfare
    setTimeout(() => beep(523,0.12,"square",0.15), 0);      // C5
    setTimeout(() => beep(659,0.12,"square",0.15), 150);    // E5
    setTimeout(() => beep(784,0.12,"square",0.15), 300);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 450);   // C6
    setTimeout(() => beep(784,0.12,"square",0.15), 600);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 750);   // C6
    setTimeout(() => beep(1047,0.12,"square",0.15), 900);   // C6
    setTimeout(() => beep(1047,0.18,"square",0.15), 1050);  // C6 final
  }

  const player = { name: "PLAYER1" };

  function sanitizeName(s){
    return (s || "").trim().replace(/\s+/g," ").slice(0,16);
  }
  function getSavedName(){
    const saved = localStorage.getItem(LS_PLAYER_NAME);
    const name = saved ? sanitizeName(saved).toUpperCase() : "";
    return name || "";
  }
  function setAndStoreName(name){
    const n = (sanitizeName(name) || "PLAYER1").toUpperCase();
    player.name = n;
    localStorage.setItem(LS_PLAYER_NAME, n);
    ui.player.textContent = n;
  }

  function getSavedSkin(){
    const raw = (localStorage.getItem(LS_PLAYER_SKIN) || "").toLowerCase();
    if (raw === "bighead" || raw === "alien") return "alien";
    if (raw === "runner" || raw === "sally") return "sally";
    if (raw === "rick") return "rick";
    if (raw === "robot") return "robot";
    return "classic";
  }
  function setAndStoreSkin(s){
    let val = (s || "classic").toLowerCase();
    if (val === "bighead") val = "alien";
    if (val === "runner") val = "sally";
    const allowed = ["classic","alien","sally","rick","robot","rex"];
    const skin = allowed.includes(val) ? val : "classic";
    game.playerSkin = skin;
    localStorage.setItem(LS_PLAYER_SKIN, skin);
    if (ui.skin) ui.skin.value = skin;
  }

  const game = {
    level: 1,
    lives: 3,
    score: 0,
    actions: 0,

    bonusActive: false,
    bonusExtraRollReady: false,
    bonusPendingRoll: false,
    bonusMovesDoubled: false,

    playerSkin: "classic",

    playerX: 2,
    playerY: 2,
    carry: [],
    sticks: [],
    holeX: 12,
    holeY: 12,

    lifeTileX: -1,
    lifeTileY: -1,
    lifeTileUsed: false,

    treeX: -1,
    treeY: -1,
    treeActive: false,
    treePhase: "hidden",
    treePhaseTimer: 0,
    treeSpawnDelay: 0,
    treeSpawnedThisLevel: false,

    pendingMonster: null,
    monsterWinStreak: 0,

    hudMsg: "",
    hudTimer: 0,
    holePulse: 0,
    holeFlash: 0,
    sparks: [],

    inputLocked: false
  };

  function carryCap(){
    const base = Math.min(6, 3 + Math.floor((game.level - 1) / 3));
    return game.bonusActive ? (base + 2) : base;
  }
  function sticksToSpawnForLevel(level){
    return 6 + (level-1)*3;
  }
  function zeroChance(level){
    return Math.min(0.18, 0.00 + (level-1)*0.015);
  }
  function curseChance(level){
    return Math.min(0.16, 0.08 + (level-1)*0.015);
  }
  function bonusChance(level){
    return Math.min(0.22, 0.10 + (level-1)*0.01);
  }

  function setHud(msg){
    game.hudMsg = msg;
    game.hudTimer = 60;
  }

  function currentLevelTheme(){
    const idx = clamp(game.level - 1, 0, LEVELS.length - 1);
    return LEVELS[idx];
  }

  function applyThemeForLevel(){
    const t = currentLevelTheme();
    if (ui.themeMini) ui.themeMini.textContent = t.name;
    document.documentElement.style.setProperty("--lvlBg", t.bg);
    document.documentElement.style.setProperty("--lvlBorder", t.border);
    document.documentElement.style.setProperty("--lvlAccentGlow", t.accentGlow);
    document.documentElement.style.setProperty("--lvlAccentShadow", t.accentShadow);
  }

  function isOccupiedByStick(x,y){
    return game.sticks.some(s => s.x===x && s.y===y);
  }
  function isHole(x,y){ return x===game.holeX && y===game.holeY; }
  function isLifeTile(x,y){
    return !game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY;
  }
  function isTreeTile(x,y){
    return game.treeActive && x===game.treeX && y===game.treeY;
  }

  function randomEmptyTile(){
    for (let i=0;i<2000;i++){
      const x = randInt(0, GRID_W-1);
      const y = randInt(0, GRID_H-1);
      if ((x===game.playerX && y===game.playerY) || isHole(x,y) || isOccupiedByStick(x,y)) continue;
      if (!game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY) continue;
      if (game.treeActive && x===game.treeX && y===game.treeY) continue;
      
      // Avoid hazard tiles
      if (fireTiles && fireTiles.some(f => f.x === x && f.y === y)) continue;
      if (windTiles && windTiles.some(w => w.x === x && w.y === y)) continue;
      if (freezeTiles && freezeTiles.some(f => f.x === x && f.y === y)) continue;
      
      return {x,y};
    }
    return {x:0,y:0};
  }

  function spawnHole(){
    if (game.level === 1){
      game.holeX = Math.floor(GRID_W/2);
      game.holeY = Math.floor(GRID_H/2);
      return;
    }
    game.holeX = randInt(6, GRID_W-7);
    game.holeY = randInt(6, GRID_H-7);
  }


  // Spawn special power-up sticks (rare)
  function maybeSpawnSpecialSticks(){
    const theme = currentLevelTheme().name;
    const level = game.level;
    
    // Special sticks only appear from level 3 onwards
    if (level < 3) return;
    
    // 20% chance per level to spawn ONE special stick
    if (Math.random() < 0.2){
      const p = randomEmptyTile();
      const types = ['speed', 'shield', 'vision'];
      const type = types[randInt(0, 2)];
      
      let color = '#3aa7ff'; // Speed = blue
      if (type === 'shield') color = '#39ff95'; // Shield = green
      if (type === 'vision') color = '#ffd400'; // Vision = yellow
      
      game.sticks.push({ 
        x: p.x, 
        y: p.y, 
        color: color, 
        cursed: false, 
        bonus: false,
        special: type
      });
    }
  }
  function spawnSticksForLevel(level){
    game.sticks = [];
    const n = sticksToSpawnForLevel(level);
    const cc = curseChance(level);
    const bc = bonusChance(level);

    for (let i=0;i<n;i++){
      const p = randomEmptyTile();
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      const cursed = Math.random() < cc;
      const bonus = !cursed && (Math.random() < bc);
      game.sticks.push({ x:p.x, y:p.y, color, cursed, bonus });
    }
    if (game.sticks.length > 0 && !game.sticks.some(s => s.cursed)){
      const idx = randInt(0, game.sticks.length - 1);
      game.sticks[idx].cursed = true;
      game.sticks[idx].bonus = false;
    }
  }

  function spawnLifeTile(){
    const p = randomEmptyTile();
    game.lifeTileX = p.x;
    game.lifeTileY = p.y;
    game.lifeTileUsed = false;
  }

  function clearTree(){
    game.treeActive = false;
    game.treePhase = "hidden";
    game.treePhaseTimer = 0;
    game.treeX = -1;
    game.treeY = -1;
  }

  function scheduleTreeForLevel(){
    clearTree();
    game.treeSpawnedThisLevel = false;
    game.treeSpawnDelay = 60 * randInt(30, 300); // 30 seconds ‚Äì 5 minutes
  }

  function spawnTreeNow(){
    const p = randomEmptyTile();
    game.treeX = p.x;
    game.treeY = p.y;
    game.treeActive = true;
    game.treePhase = "visible";
    game.treePhaseTimer = 60 * 15;
    game.treeSpawnedThisLevel = true;

    logEvent("bonus","A tree appears... (15s)");
    setHud("TREE APPEARS!");
    
    // Tree chime!
    setTimeout(() => beep(523, 0.12, "sine", 0.08), 0);
    setTimeout(() => beep(659, 0.12, "sine", 0.08), 120);
    setTimeout(() => beep(784, 0.15, "sine", 0.10), 240);
  }

  function startTreeBlinking(){
    game.treePhase = "blinking";
    game.treePhaseTimer = 60 * 15;
    logEvent("warn","Tree is blinking... hurry!");
    setHud("TREE BLINKING!");
  }

  function endTree(){
    clearTree();
    logEvent("warn","The tree fades away.");
    setHud("TREE GONE");
  }

  function showNameModal(){
    game.inputLocked = true;
    ui.nameOverlay.style.display = "flex";
    ui.nameInput.value = "";
    ui.nameInput.placeholder = "ENTER NAME";

    const saved = getSavedName();
    if (saved && saved !== "PLAYER1"){
      ui.savedNameHint.style.display = "block";
      ui.savedNameHint.textContent = `Saved on this device: ${saved}`;
      ui.nameUseSavedBtn.style.display = "inline-block";
      ui.nameUseSavedBtn.textContent = `Use ${saved}`;
    }else{
      ui.savedNameHint.style.display = "none";
      ui.nameUseSavedBtn.style.display = "none";
    }

    gameSetTimeout(()=>ui.nameInput.focus(), 50);
  }
  function closeNameModal(){
    ui.nameOverlay.style.display = "none";
    game.inputLocked = false;
  }
  function startFromNameInput(){
    const entered = sanitizeName(ui.nameInput.value);
    if (!entered) setAndStoreName("PLAYER1");
    else setAndStoreName(entered);
    closeNameModal();
    newGame(true);
  }

  function resetCoreState(){
    game.level = 1;
    game.lives = 3;
    game.score = 0;
    game.actions = 0;

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    game.carry = [];
    game.sticks = [];
    game.sparks = [];
    game.holePulse = 0;
    game.holeFlash = 0;
    game.hudMsg = "";
    game.hudTimer = 0;

    game.playerX = 2;
    game.playerY = 2;

    game.lifeTileX = -1;
    game.lifeTileY = -1;
    game.lifeTileUsed = false;

    scheduleTreeForLevel();

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    game.monsterWinStreak = 0;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();

    if (ui.log) ui.log.innerHTML = "";
    if (ui.battleLog) ui.battleLog.innerHTML = "";
    logEvent("neutral","Welcome to STICKS.");
    logEvent("neutral","Roll to begin.");

    setAndStoreSkin(getSavedSkin());
    
    // Init wind tiles for Sky Stick
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
    }
    
    // Init snakes for Snake Stick
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    // Init freeze zones for Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Init shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    // Init sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      bubbles = [];
    }
    
    // Init sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick"){
      initSunBursts();
    } else {
      sunBurstTiles = [];
      sunBurstWarningTimer = 0;
    }
    
    // Init star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
    } else {
      starGridTiles = [];
      playerGlowTimer = 0;
    }
    
    // Init Spell Stick - moving teleports + moving hole
    if (currentLevelTheme().name === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      teleportTiles = [];
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900);
      holeFlashTimer = 0;
    } else if (currentLevelTheme().name !== "Victory Stick") {
      teleportTiles = [];
      teleportMoveTimer = 0;
      holeMoveTimer = 0;
      holeFlashTimer = 0;
    }
    
    // Init Ice Stick wind sound and snowman
    if (currentLevelTheme().name === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      stopIceWindSound();
      snowman = null;
    }
    
    // Init Spider Stick
    if (currentLevelTheme().name === "Spider Stick"){
      initSpiderWebs();
      initSpiders();
    } else {
      spiderWebs = [];
      spiders = [];
    }
    
    // Init Skunk Stick
    if (currentLevelTheme().name === "Skunk Stick"){
      initSkunks();
    } else {
      skunks = [];
      stinkClouds = [];
    }
    
    // Victory Stick - ALL HAZARDS!
    if (currentLevelTheme().name === "Victory Stick"){
      windTiles = [];
      for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
      windGustTimer = 0;
      
      fireTiles = [];
      for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
      fireWarningTimer = 0;
      
      initSnakes();
      snakes = snakes.slice(0,1);
      snakeMoveTimer = 0;
      
      initFreezeTiles();
      freezeTiles = freezeTiles.slice(0,2);
      freezeWarningTimer = 0;
      
      initShadowMonsters();
      shadowMonsters = shadowMonsters.slice(0,1);
      
      initSharks();
      sharks = sharks.slice(0,2); // 2 sharks for Victory
      
      initSunBursts();
      sunBurstTiles = sunBurstTiles.slice(0,3); // 3 sun bursts
      
      initSnowman();
      
      initSpiderWebs();
      spiderWebs = spiderWebs.slice(0,3);
      
      initSpiders();
      spiders = spiders.slice(0,2); // 2 spiders for Victory
      
      // Moving hole + teleports for Victory!
      teleportTiles = [];
      for(let i=0;i<4;i++) teleportTiles.push({
        x:randInt(0,GRID_W-1),
        y:randInt(0,GRID_H-1),
        glow:Math.random()*Math.PI*2,
        moveTimer:randInt(120,300)
      });
      holeMoveTimer = randInt(600,900);
      holeFlashTimer = 0;
    }
    
    // Initialize snowflakes if starting on Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize fire tiles if starting on Fire Stick
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset all effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;// Reset hole visibility
    holeVisible = true;
    holeFadeTimer = 0;

    gameSetTimeout(updateScrollHint, 60);
  }

  function commitScoreToLeaderboard(){
    upsertLeaderboardEntry(player.name, game.score, game.level);
  }

  function burstFx(el, emoji, count=26){
    if (!el) return;
    el.innerHTML = "";
    const w = el.clientWidth || 680;
    for (let i=0;i<count;i++){
      const s = document.createElement("span");
      s.textContent = emoji;
      s.style.left = randInt(0, w) + "px";
      s.style.top  = randInt(-20, 30) + "px";
      s.style.animationDuration = (1.2 + Math.random()*0.9) + "s";
      s.style.transform = `translateY(0) rotate(${randInt(0,180)}deg)`;
      el.appendChild(s);
    }
  }

  function winGame(){
    commitScoreToLeaderboard();

    burstFx(ui.winFx, "‚ú®", 34);

    ui.winText.textContent = `YOU WIN ‚Äî ${player.name}\nScore: ${game.score}\n\nThe sticks have been humbled. The hole is satisfied (for now).`;
    ui.winOverlay.style.display = "flex";
    game.inputLocked = true;

    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    setHud("VICTORY STICK!");
    logEvent("win","Victory Stick cleared. You win.");

    spawnSparks(game.holeX, game.holeY, 46, false);
    spawnSparks(game.playerX, game.playerY, 22, false);

    sfxWin();
    startCelebrationMusic(8500);
  }

  function newLevel(){
    if (game.level > 11){
      winGame();
      updateUI();
      return;
    }

    game.level++;
    applyThemeForLevel();
    
    // Initialize snowflakes for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize wind tiles for Sky Stick
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
    }
    
    // Initialize snakes for Snake Stick
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    // Initialize freeze zones for Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Initialize shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    if (currentLevelTheme().name === "Spider Stick"){
      initSpiderWebs();
      initSpiders();
    } else {
      spiderWebs = [];
      spiders = [];
    }
    
    if (currentLevelTheme().name === "Skunk Stick"){
      initSkunks();
    } else {
      skunks = [];
      stinkClouds = [];
    }
    
    // Initialize sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      bubbles = [];
    }
    
    // Initialize sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick"){
      initSunBursts();
    } else {
      sunBurstTiles = [];
      sunBurstWarningTimer = 0;
    }
    
    // Initialize star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
    } else {
      starGridTiles = [];
      playerGlowTimer = 0;
    }
    
    // Initialize Spell Stick - moving teleports + moving hole
    if (currentLevelTheme().name === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      teleportTiles = [];
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900);
      holeFlashTimer = 0;
    } else if (currentLevelTheme().name !== "Victory Stick") {
      teleportTiles = [];
      teleportMoveTimer = 0;
      holeMoveTimer = 0;
      holeFlashTimer = 0;
    }
    
    // Ice Stick wind sound and snowman
    if (currentLevelTheme().name === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      stopIceWindSound();
      snowman = null;
    }
    
    // Victory Stick - ALL HAZARDS!
    if (currentLevelTheme().name === "Victory Stick"){
      windTiles = [];
      for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
      windGustTimer = 0;
      
      fireTiles = [];
      for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
      fireWarningTimer = 0;
      
      initSnakes();
      snakes = snakes.slice(0,1);
      snakeMoveTimer = 0;
      
      initFreezeTiles();
      freezeTiles = freezeTiles.slice(0,2);
      freezeWarningTimer = 0;
      
      initShadowMonsters();
      shadowMonsters = shadowMonsters.slice(0,1);
      
      initSharks();
      sharks = sharks.slice(0,2); // 2 sharks for Victory
      
      initSunBursts();
      sunBurstTiles = sunBurstTiles.slice(0,3); // 3 sun bursts
      
      initSnowman();
      
      initSpiderWebs();
      spiderWebs = spiderWebs.slice(0,3);
      
      initSpiders();
      spiders = spiders.slice(0,2); // 2 spiders for Victory
      
      // Moving hole + teleports for Victory!
      teleportTiles = [];
      for(let i=0;i<4;i++) teleportTiles.push({
        x:randInt(0,GRID_W-1),
        y:randInt(0,GRID_H-1),
        glow:Math.random()*Math.PI*2,
        moveTimer:randInt(120,300)
      });
      holeMoveTimer = randInt(600,900);
      holeFlashTimer = 0;
    }
    
    // Initialize fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset special effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;
    
    // Clear trails and particles// Reset hole visibility for new level
    holeVisible = true;
    holeFadeTimer = 0;
    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();
    scheduleTreeForLevel();

    game.actions = 0;
    game.carry = [];

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    logEvent("level",`Level ${game.level}! (${currentLevelTheme().name})`);
    sfxLevelUp();
    setHud(`LEVEL ${game.level}!`);

    commitScoreToLeaderboard();
    updateUI();
  }

  function newGame(fresh=false){
    if (!fresh){
      showNameModal();
      return;
    }
    resetCoreState();
    applyThemeForLevel();
    updateUI();
    startLoop();
  }

  function canRoll(){
    if (game.inputLocked && !game.pendingMonster) return false;
    if (game.pendingMonster) return true;
    if (game.actions > 0) return false;
    return true;
  }

  function rollNormal(){
    const zc = zeroChance(game.level);
    if (Math.random() < zc) return 0;
    return randInt(1,5);
  }

  function rollBonus2d6(){
    const d1 = randInt(1,6);
    const d2 = randInt(1,6);
    return { total: d1 + d2, d1, d2 };
  }

  function doRoll(){
    if (!canRoll()){
      sfxError();
      setHud("Spend Actions first!");
      return;
    }

    ui.diceBox.classList.add("rolling");
    sfxRoll();

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      if (game.pendingMonster){
        resolveMonsterRoll();
        return;
      }

      if (game.bonusActive){
        const r = rollBonus2d6();
        ui.diceFace.textContent = String(r.total);
        ui.diceLabel.textContent = `BONUS üé≤üé≤ (${r.d1}+${r.d2})`;

        game.bonusPendingRoll = false;
        game.bonusMovesDoubled = false;

        game.actions = r.total;
        logEvent("bonus",`Bonus roll: ${r.total}`);
        if (r.total === 12){
          game.bonusExtraRollReady = true;
          logEvent("bonus","Jackpot 12! Extra Bonus roll earned.");
          setHud("12! Extra Bonus roll earned!");
        } else {
          game.bonusExtraRollReady = false;
        }
      } else {
        const r = rollNormal();
        ui.diceFace.textContent = String(r);
        ui.diceLabel.textContent = `Normal üé≤ (0‚Äì5)`;

        if (r === 0){
          logEvent("bad","Rolled 0!");
          sfxZeroBad();
          handleZeroPenalty();
          game.actions = 0;
        } else {
          game.actions = r;
          
          // Spider web effect - halve the roll
          if (game.webbed){
            const before = game.actions;
            game.actions = Math.floor(game.actions / 2);
            logEvent("bad", `WEB TRAPPED! Roll halved: ${before} ‚Üí ${game.actions}`);
            setHud("WEBBED!");
            beep(300, 0.15, "sawtooth", 0.08);
            game.webbed = false;
          }
          
          logEvent("roll",`Rolled ${r}.`);
        }
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
    }, 260);
  }

  function scatterPositionAround(x,y, radius){
    for (let i=0;i<200;i++){
      const nx = clamp(x + randInt(-radius, radius), 0, GRID_W-1);
      const ny = clamp(y + randInt(-radius, radius), 0, GRID_H-1);
      if (isHole(nx,ny)) continue;
      if (isOccupiedByStick(nx,ny)) continue;
      if (nx===game.playerX && ny===game.playerY) continue;
      if (isLifeTile(nx,ny)) continue;
      if (isTreeTile(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    return randomEmptyTile();
  }

  function handleZeroPenalty(){
    // HOLE IS SACRED - bonus points if in hole!
    if (game.playerX === game.holeX && game.playerY === game.holeY){
      const bonus = 5;
      game.score += bonus;
      logEvent("bonus", `Zero in hole! +${bonus} bonus points!`);
      setHud(`HOLE BONUS +${bonus}!`);
      game.holePulse = 1.0;
      beep(550, 0.12, "triangle", 0.08);
      spawnSparks(game.holeX, game.holeY, 18, false);
      commitScoreToLeaderboard();
      return;
    }
    
    if (game.carry.length > 0){
      const dropped = game.carry.splice(0, game.carry.length);
      dropped.forEach(st => {
        const p = scatterPositionAround(game.playerX, game.playerY, 3);
        game.sticks.push({ x:p.x, y:p.y, color: st.color, cursed:false, bonus:false });
      });
      logEvent("bad",`Zero! Dropped ${dropped.length} stick(s).`);
      setHud(`Zero! Dropped ${dropped.length}!`);
    } else {
      const p = scatterPositionAround(game.holeX, game.holeY, 3);
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      game.sticks.push({ x:p.x, y:p.y, color, cursed:false, bonus:false });
      logEvent("bad","Zero! Hole spits out a stick.");
      setHud("Hole spits out a stick!");
    }
    game.holeFlash = 1.0;
  }

  function onBonusStickPickup(){
    game.bonusPendingRoll = true;

    if (game.actions > 0){
      const before = game.actions;
      game.actions *= 2;
      game.bonusMovesDoubled = true;

      logEvent("bonus",`BONUS STICK! Actions doubled: ${before} ‚Üí ${game.actions}.`);
      setHud(`BONUS! ${before}‚Üí${game.actions} (Roll later)`);
      sfxBonus();
      updateUI();
      return;
    }

    game.bonusMovesDoubled = false;
    game.bonusActive = true;

    logEvent("bonus","BONUS STICK! No Actions left ‚Äî Bonus roll now!");
    setHud("BONUS ROLL NOW!");
    sfxBonus();
    updateUI();

    doRoll();
  }

  function promptBonusRollReady(){
    game.bonusActive = true;
    game.bonusMovesDoubled = false;

    ui.diceFace.textContent = "‚Äî";
    ui.diceLabel.textContent = "BONUS READY (2‚Äì12)";
    ui.btnRoll.classList.add("flashRoll");

    logEvent("bonus","Bonus roll ready! Press ROLL.");
    setHud("BONUS ROLL READY!");
    sfxBonus();
    updateUI();
  }

  function exitBonusIfDone(){
    if (game.actions === 0 && !game.bonusExtraRollReady){
      if (game.bonusActive){
        game.bonusActive = false;
        ui.btnRoll.classList.remove("flashRoll");
        logEvent("neutral","Bonus ended.");
        setHud("Bonus ended.");
      }
    }
  }

  function spendAction(){
    if (game.pendingMonster){
      sfxError();
      setHud("Fight the monster first! Press ROLL.");
      return false;
    }
    if (game.actions <= 0){
      sfxError();
      setHud("No Actions. Roll!");
      return false;
    }
    if (activeSpeedBoost > 0){
          activeSpeedBoost--;
          logEvent("info", `Speed boost! ${activeSpeedBoost} free moves left`);
        } else {
          game.actions--;
        }

    if (game.actions === 0){
      if (game.bonusPendingRoll && !game.bonusActive){
        promptBonusRollReady();
      } else {
        exitBonusIfDone();
      }
    }

    updateUI();
    return true;
  }

  function monsterStickValueForStreak(streak){
    if (streak <= 3) return 2;
    return Math.min(12, (streak - 1));
  }

  function resolveMonsterRoll(){
    const pending = game.pendingMonster;
    if (!pending) return;
    const index = pending.index;
    game.pendingMonster = null;

    ui.diceBox.classList.add("rolling");
    sfxRoll();
    logEvent("monster","Monster Stick! Rolling (0‚Äì5)...");

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      const roll = randInt(0,5);
      ui.diceFace.textContent = String(roll);
      ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";

      const s = game.sticks[index];
      stopMonsterDoom();

      if (roll <= 1){
        if (s && s.cursed){
          game.sticks.splice(index,1);
        }
        game.lives = Math.max(0, game.lives - 1);
        spawnSparks(game.playerX, game.playerY, 18, true);

        game.monsterWinStreak = 0;

        logEvent("monster","Monster wins! Lost 1 life. (Streak reset)");
        setHud("MONSTER WINS! -1 LIFE");

        playPacmanDeathSting();

        if (game.lives <= 0){
          ui.monsterEvent.style.display = "none";
          ui.btnRoll.classList.remove("flashRoll");
          updateUI();
          game.inputLocked = false;
          game.pendingMonster = null;
          gameOver();
          return;
        }
      } else {
        game.monsterWinStreak++;
        const streak = game.monsterWinStreak;
        const mult = monsterStickValueForStreak(streak);

        if (s){
          game.sticks.splice(index,1);
          game.carry.push({ color: s.color, value: mult, fromMonster:true, streakAtWin: streak });
        }

        logEvent("bonus",`You beat the monster! Stick is worth ${mult}√ó. (Streak ${streak})`);
        setHud(`MONSTER BEATEN! ${mult}√ó STICK`);
        sfxPickup();
        startCelebrationMusic(6500);

        if (streak === 3){
          if (game.lives < MAX_LIVES){
            game.lives++;
            logEvent("bonus","3√ó Monster streak! +1 life.");
            setHud("+1 LIFE (3√ó STREAK)");
            sfxExtraLife();
            startCelebrationMusic(7500);
          } else {
            logEvent("bonus","3√ó Monster streak (already max lives).");
            setHud("3√ó STREAK (MAX LIVES)");
            startCelebrationMusic(6500);
          }
        }
      }

ui.monsterEvent.style.display = "none";
ui.btnRoll.classList.remove("flashRoll");
game.inputLocked = false;
updateUI();

/* ‚úÖ BUGFIX: if the monster removed the LAST stick and you‚Äôre carrying none,
   the field is cleared but the game never advances. */
if (game.sticks.length === 0 && game.carry.length === 0){
  logEvent("level","Cleared the field!");
  newLevel();
  return;
}

gameSetTimeout(updateScrollHint, 30);

    }, 260);
  }

  function move(dx,dy){
    if (game.inputLocked) return;
    if (!spendAction()) return;
    game.playerX = clamp(game.playerX + dx, 0, GRID_W-1);
    game.playerY = clamp(game.playerY + dy, 0, GRID_H-1);
    beep(220,0.03,"triangle",0.02);
    updateUI();
  }

  function pickOrDrop(){
    if (game.inputLocked) return;
    if (!spendAction()) return;

    if (isTreeTile(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        const cap = carryCap();
        for (let i=0;i<cap;i++){
          const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
          game.carry.push({ color, value:1, fromMagic:true });
        }
        logEvent("bonus",`Tree magic! Instantly filled to ${cap}.`);
        setHud(`TREE LOAD (${cap})`);
        sfxPickup();

        if (game.sticks.length === 0){
          endTree();
        }

        updateUI();
        return;
      }

      game.carry.pop();

      if (game.lives < MAX_LIVES){
        game.lives++;
        logEvent("bonus","Fed the tree. +1 life.");
        setHud("+1 LIFE (TREE)");
        sfxExtraLife();
        startCelebrationMusic(6500);
      } else {
        game.score += TREE_FEED_MAX_POINTS;
        logEvent("bonus",`Fed the tree (max lives). +${TREE_FEED_MAX_POINTS} points.`);
        setHud(`TREE FED (+${TREE_FEED_MAX_POINTS})`);
        sfxPickup();
        commitScoreToLeaderboard();
      }

      endTree();

      if (game.sticks.length === 0 && game.carry.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
        return;
      }

      updateUI();
      return;
    }

    if (isHole(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        sfxError(); setHud("Nothing to deposit."); return;
      }
      const n = game.carry.length;
      let pts = 0;
      for (const st of game.carry){
        let v = st.value || 1;
        if (game.bonusActive) v *= 2;
        pts += v;
      }
      game.score += pts;
      game.carry = [];
      
      // Expire power-ups on deposit
      if (activeShield > 0){
        activeShield = 0;
        logEvent("info", "Shield expired.");
      }
      if (visionRevealed){
        visionRevealed = false;
        visionTimer = 0;
        logEvent("info", "Vision expired.");
      }

      logEvent("deposit",`Deposited ${n} stick(s) (+${pts}).`);
      sfxDeposit();
      setHud(`+${pts} deposited!`);

      game.holePulse = 1.0;
      spawnSparks(game.holeX, game.holeY, 28);

      commitScoreToLeaderboard();

      if (game.sticks.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
      } else {
        updateUI();
      }
      return;
    }

    const idx = game.sticks.findIndex(s => s.x===game.playerX && s.y===game.playerY);
    if (idx >= 0){
      if (game.carry.length >= carryCap()){
        sfxError();
        const cap = carryCap();
        setHud(`MAX STICKS (${cap})`);
        logEvent("warn",`MAX STICKS (${cap}).`);
        return;
      }

      const s = game.sticks[idx];

      if (s.cursed){
        game.pendingMonster = { index: idx };
        game.inputLocked = true;

        logEvent("monster","Monster Stick! Press ROLL (0‚Äì5) to fight.");
        setHud("MONSTER STICK! PRESS ROLL");

        ui.diceFace.textContent = "?";
        ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";
        ui.monsterEventText.textContent =
          `Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a powered stick. Roll 0‚Äì1 and you lose 1 life. (Win streak carries across levels; resets only on a loss.)`;
        ui.monsterEvent.style.display = "flex";
        ui.btnRoll.classList.add("flashRoll");

        sfxMonsterHit();
        playMonsterDoomSting();
        updateUI();
        gameSetTimeout(updateScrollHint, 30);
        return;
      }

      // Check if it's a special stick
      if (s.special){
        pickupSpecialStick(s.special);
        game.sticks.splice(idx,1);return;
      }game.sticks.splice(idx,1);
      game.carry.push({ color:s.color, value:1 });

      sfxPickup();

      if (s.bonus){
        onBonusStickPickup();
      }

      const cap = carryCap();
      if (game.carry.length === cap){
        logEvent("warn",`MAX LOAD (${cap}).`);
        setHud(`MAX LOAD (${cap})`);
      } else {
        logEvent("pickup",`Picked up a stick. (${game.carry.length}/${cap})`);
        setHud(`Picked up (${game.carry.length}/${cap})`);
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
      return;
    }

    if (game.carry.length > 0){
      if (isOccupiedByStick(game.playerX, game.playerY)){
        sfxError(); setHud("Tile already has a stick."); return;
      }

      if (isLifeTile(game.playerX, game.playerY)){
        game.carry.pop();
        game.lifeTileUsed = true;

        if (game.lives < MAX_LIVES){
          game.lives++;
          logEvent("bonus","Secret life tile! +1 life.");
          setHud("+1 LIFE");
          sfxExtraLife();
          startCelebrationMusic(6500);
        } else {
          game.score += LIFE_TILE_MAX_POINTS;
          logEvent("bonus",`Life tile found (max lives). +${LIFE_TILE_MAX_POINTS} points.`);
          setHud(`LIFE TILE (+${LIFE_TILE_MAX_POINTS})`);
          sfxPickup();
          commitScoreToLeaderboard();
        }

        spawnSparks(game.playerX, game.playerY, 18, false);
        updateUI();
        return;
      }

      const st = game.carry.pop();
      game.sticks.push({ x:game.playerX, y:game.playerY, color:st.color, cursed:false, bonus:false });
      sfxPlace();
      logEvent("place","Placed 1 stick.");
      setHud("Placed 1 stick.");
      updateUI();
      return;
    }

    sfxError();
    setHud("No stick here.");
  }

  function gameOver(){
    commitScoreToLeaderboard();

    burstFx(ui.loseFx, "ü™µ", 30);

    const taunts = [
      "The Stick Monster claps slowly. Loudly. Rudely.",
      "The sticks whisper: 'Skill issue.'",
      "The monster does a little dance. It‚Äôs disrespectful.",
      "The hole sighs. The monster cackles."
    ];
    const t = taunts[randInt(0, taunts.length-1)];

    ui.gameOverText.textContent = `GAME OVER ‚Äî ${player.name}\nScore: ${game.score} ‚Ä¢ Level: ${game.level}\n\n${t}`;
    ui.gameOverOverlay.style.display = "flex";
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();
    game.inputLocked = true;

    logEvent("bad", `Game Over. ${t}`);
    setHud("GAME OVER");

    spawnSparks(game.playerX, game.playerY, 26, true);
    spawnSparks(game.holeX, game.holeY, 16, true);

    startDoomMusic(8500);
  }

  function spawnSparks(gx,gy,count=18, evil=false){
    const cx = gx*TILE + TILE/2;
    const cy = gy*TILE + TILE/2;
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      game.sparks.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 24 + Math.random()*20, evil });
    }
  }

  function updateRollButtonState(){
    const canRoll = !((game.inputLocked && !game.pendingMonster) || (game.actions !== 0 && !game.pendingMonster));
    ui.btnRoll.disabled = !canRoll;
    
    // Add visual highlight when ready to roll
    if (canRoll){
      ui.btnRoll.classList.add('ready-to-roll');
    } else {
      ui.btnRoll.classList.remove('ready-to-roll');
    }
  }

  function updateUI(){
    ui.player.textContent = player.name;
    ui.lives.textContent = String(game.lives);
    ui.level.textContent = String(game.level);
    ui.score.textContent = String(game.score);
    ui.actions.textContent = String(game.actions);

    const cap = carryCap();
    ui.carry.textContent = `${game.carry.length}/${cap}`;
    ui.left.textContent = String(game.sticks.length);

    let mode = "NORMAL";
    if (game.bonusActive) mode = game.bonusExtraRollReady ? "BONUS+" : "BONUS";
    else if (game.bonusPendingRoll) mode = "BONUS (PENDING)";
    ui.mode.textContent = mode;

    ui.die.textContent = game.bonusActive ? "2‚Äì12" : "0‚Äì5";

    updateRollButtonState();
  }

  function canSaveLoad(){
    if (ui.infoOverlay.style.display === "flex") return false;
    if (ui.nameOverlay.style.display === "flex") return false;
    if (ui.gameOverOverlay.style.display === "flex") return false;
    if (ui.winOverlay.style.display === "flex") return false;
    if (ui.pauseOverlay.style.display === "flex") return false;
    if (game.pendingMonster) return false;
    return true;
  }

  function serializeGame(){
    return {
      v: 2,
      when: Date.now(),
      playerName: player.name,
      playerSkin: game.playerSkin,
      game: {
        level: game.level,
        lives: game.lives,
        score: game.score,
        actions: game.actions,

        bonusActive: game.bonusActive,
        bonusExtraRollReady: game.bonusExtraRollReady,
        bonusPendingRoll: game.bonusPendingRoll,
        bonusMovesDoubled: game.bonusMovesDoubled,

        playerX: game.playerX,
        playerY: game.playerY,
        carry: game.carry,
        sticks: game.sticks,
        holeX: game.holeX,
        holeY: game.holeY,
        lifeTileX: game.lifeTileX,
        lifeTileY: game.lifeTileY,
        lifeTileUsed: game.lifeTileUsed,

        treeX: game.treeX,
        treeY: game.treeY,
        treeActive: game.treeActive,
        treePhase: game.treePhase,
        treePhaseTimer: game.treePhaseTimer,
        treeSpawnDelay: game.treeSpawnDelay,
        treeSpawnedThisLevel: game.treeSpawnedThisLevel,

        monsterWinStreak: game.monsterWinStreak,

        hudMsg: "",
        hudTimer: 0,
        holePulse: 0,
        holeFlash: 0
      }
    };
  }

  function applySerialized(obj){
    if (!obj || !obj.game) return false;

    setAndStoreName(obj.playerName || "PLAYER1");
    setAndStoreSkin(obj.playerSkin || getSavedSkin());

    const g = obj.game;
    game.level = clamp(Number(g.level)||1, 1, 9);
    game.lives = clamp(Number(g.lives)||3, 0, MAX_LIVES);
    game.score = Math.max(0, Number(g.score)||0);
    game.actions = Math.max(0, Number(g.actions)||0);

    game.bonusActive = !!g.bonusActive;
    game.bonusExtraRollReady = !!g.bonusExtraRollReady;
    game.bonusPendingRoll = !!g.bonusPendingRoll;
    game.bonusMovesDoubled = !!g.bonusMovesDoubled;

    game.playerX = clamp(Number(g.playerX)||2, 0, GRID_W-1);
    game.playerY = clamp(Number(g.playerY)||2, 0, GRID_H-1);

    game.carry = Array.isArray(g.carry) ? g.carry.slice(0, 12) : [];
    game.sticks = Array.isArray(g.sticks) ? g.sticks.map(s => ({
      x: clamp(Number(s.x)||0, 0, GRID_W-1),
      y: clamp(Number(s.y)||0, 0, GRID_H-1),
      color: String(s.color || "#f3f4f6"),
      cursed: !!s.cursed,
      bonus: !!s.bonus
    })) : [];

    game.holeX = clamp(Number(g.holeX)||12, 0, GRID_W-1);
    game.holeY = clamp(Number(g.holeY)||12, 0, GRID_H-1);

    game.lifeTileX = clamp(Number(g.lifeTileX)||-1, -1, GRID_W-1);
    game.lifeTileY = clamp(Number(g.lifeTileY)||-1, -1, GRID_W-1);
    game.lifeTileUsed = !!g.lifeTileUsed;

    game.treeX = clamp(Number(g.treeX)||-1, -1, GRID_W-1);
    game.treeY = clamp(Number(g.treeY)||-1, -1, GRID_W-1);
    game.treeActive = !!g.treeActive;
    game.treePhase = String(g.treePhase || (game.treeActive ? "visible" : "hidden"));
    game.treePhaseTimer = Math.max(0, Number(g.treePhaseTimer)||0);
    game.treeSpawnDelay = Math.max(0, Number(g.treeSpawnDelay)||0);
    game.treeSpawnedThisLevel = !!g.treeSpawnedThisLevel;

    game.monsterWinStreak = Math.max(0, Number(g.monsterWinStreak)||0);

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    game.inputLocked = false;
    applyThemeForLevel();
    
    // Re-initialize hazards for loaded level
    const loadedTheme = currentLevelTheme().name;
    
    if (loadedTheme === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    if (loadedTheme === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    if (loadedTheme === "Sky Stick"){
      initWindTiles();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
    }
    
    if (loadedTheme === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    if (loadedTheme === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    if (loadedTheme === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    if (loadedTheme === "Victory Stick"){
      windTiles = [];
      for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
      fireTiles = [];
      for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
      initSnakes(); snakes = snakes.slice(0,1);
      initFreezeTiles(); freezeTiles = freezeTiles.slice(0,4);
      initShadowMonsters(); shadowMonsters = shadowMonsters.slice(0,1);
      initSharks(); sharks = sharks.slice(0,2);
      initSunBursts(); sunBurstTiles = sunBurstTiles.slice(0,3);
      teleportTiles = [];
      for(let i=0;i<4;i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
      holeMoveTimer = randInt(600,900);
    }
    
    if (loadedTheme === "Sea Stick"){
      initSharks();
    } else if (loadedTheme !== "Victory Stick"){
      sharks = [];
    }
    
    if (loadedTheme === "Sun Stick"){
      initSunBursts();
    } else if (loadedTheme !== "Victory Stick"){
      sunBurstTiles = [];
    }
    
    if (loadedTheme === "Night Stick"){
      initStarGrid();
    } else {
      starGridTiles = [];
    }
    
    if (loadedTheme === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      snowman = null;
    }
    
    updateUI();
    setHud("Game loaded!");
    return true;
  }

  function saveGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't save right now.");
      logEvent("warn","Can't save during overlays or monster encounter.");
      return;
    }
    try{
      localStorage.setItem(LS_SAVEGAME, JSON.stringify(serializeGame()));
      logEvent("save","Game saved (this device).");
      setHud("GAME SAVED");
      chord([262,330,392],0.16,0.05,"triangle");
    }catch(_){
      sfxError();
      setHud("Save failed.");
    }
  }

  function loadGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't load right now.");
      logEvent("warn","Can't load during overlays or monster encounter.");
      return;
    }
    try{
      const raw = localStorage.getItem(LS_SAVEGAME);
      if (!raw){
        sfxError();
        setHud("No saved game.");
        logEvent("load","No saved game found.");
        return;
      }
      const obj = JSON.parse(raw);
      const ok = applySerialized(obj);
      if (ok){
        logEvent("load","Game loaded.");
        chord([294,370,440],0.16,0.05,"triangle");
      } else {
        sfxError();
        setHud("Load failed.");
      }
    }catch(_){
      sfxError();
      setHud("Load failed.");
    }
  }

  /* ---- Drawing ---- */

  /* ‚úÖ Casey changes requested:
     - Glow Stick grid: softened + pulses
     - Victory Stick grid: softened (and pulses a bit too)
     - Ice Stick: aesthetically nicer but still consistent (icy gradient + soft sheen + gentle pulse)
  */
  function drawGrid(theme){
    // background
    if (theme.name === "Ice Stick"){
      const g = ctx.createLinearGradient(0,0,CANVAS_W,CANVAS_H);
      g.addColorStop(0, "#f5fbff");
      g.addColorStop(0.55, theme.bg);
      g.addColorStop(1, "#dbeafe");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

      // subtle frost sheen diagonals (static look, very faint)
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.moveTo(-40 + i*90, 40);
        ctx.lineTo(CANVAS_W, CANVAS_H - 80 + i*40);
        ctx.stroke();
      }
      ctx.restore();
    } else {
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    }

    // time for pulse
    const t = ((performance.now ? performance.now() : Date.now()) / 1000);
    const osc = (Math.sin(t*2.8) + 1) / 2; // 0..1

    // base softness per theme
    const isGlow = theme.name === "Glow Stick";
    const isVic  = theme.name === "Victory Stick";
    const isIce  = theme.name === "Ice Stick";

    let baseAlpha = 0.55;
    let pulseAdd  = 0.00;
    let glowAlpha = 0.00;
    let glowBlur  = 0;

    if (isGlow){
      baseAlpha = 0.22;
      pulseAdd  = 0.22;   // noticeable pulse
      glowAlpha = 0.08 + osc*0.06;
      glowBlur  = 12 + osc*8;
    } else if (isVic){
      baseAlpha = 0.26;
      pulseAdd  = 0.16;   // softer pulse than Glow
      glowAlpha = 0.07 + osc*0.05;
      glowBlur  = 10 + osc*6;
    } else if (isIce){
      baseAlpha = 0.18;
      pulseAdd  = 0.14;   // gentle pulse
      glowAlpha = 0.05 + osc*0.04;
      glowBlur  = 8 + osc*5;
    } else {
      baseAlpha = 0.55;
      pulseAdd  = 0.00;
      glowAlpha = 0.00;
      glowBlur  = 0;
    }

    // neon blur pass (softens the grid + gives the pulse)
    if (isGlow || isVic || isIce){
      ctx.save();
      ctx.strokeStyle = theme.grid;
      ctx.shadowColor = theme.grid;
      ctx.shadowBlur = glowBlur;
      ctx.globalAlpha = glowAlpha;
      ctx.lineWidth = 2;

      for (let x=0;x<=GRID_W;x++){
        ctx.beginPath();
        ctx.moveTo(x*TILE + 0.5, 0);
        ctx.lineTo(x*TILE + 0.5, CANVAS_H);
        ctx.stroke();
      }
      for (let y=0;y<=GRID_H;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*TILE + 0.5);
        ctx.lineTo(CANVAS_W, y*TILE + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    // crisp pass (but softened via alpha + pulse)
    ctx.strokeStyle = theme.grid;
    ctx.lineWidth = 1;
    ctx.globalAlpha = clamp(baseAlpha + (osc*pulseAdd), 0.06, 0.72);

    for (let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE + 0.5, 0);
      ctx.lineTo(x*TILE + 0.5, CANVAS_H);
      ctx.stroke();
    }
    for (let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE + 0.5);
      ctx.lineTo(CANVAS_W, y*TILE + 0.5);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
  }

  function drawHole(theme){
    if (!holeVisible) return; // Support for hole fading on higher levels
    
    const cx = game.holeX*TILE + TILE/2;
    const cy = game.holeY*TILE + TILE/2;

    if (game.holePulse > 0) game.holePulse = Math.max(0, game.holePulse - 0.03);
    if (game.holeFlash > 0) game.holeFlash = Math.max(0, game.holeFlash - 0.04);

    const pulse = game.holePulse;
    const flash = game.holeFlash;

    // Theme-specific hole colors with vibrant accents
    let holeColor = "#000000";
    let holeStroke = "#f3f4f6";
    let glowColor = "rgba(243,244,246,0.4)";
    
    if (theme.name === "Sun Stick") {
      holeColor = "#2a1a00";
      holeStroke = "#ffd400";
      glowColor = "rgba(255,212,0,0.6)";
    } else if (theme.name === "Sea Stick") {
      holeColor = "#001a33";
      holeStroke = "#00bfff";
      glowColor = "rgba(0,191,255,0.6)";
    } else if (theme.name === "Sky Stick") {
      holeColor = "#051a3a";
      holeStroke = "#3aa7ff";
      glowColor = "rgba(58,167,255,0.6)";
    } else if (theme.name === "Fire Stick") {
      holeColor = "#1a0005";
      holeStroke = "#ff5a6a";
      glowColor = "rgba(255,31,58,0.6)";
    } else if (theme.name === "Snake Stick") {
      holeColor = "#001a0a";
      holeStroke = "#39ff95";
      glowColor = "rgba(57,255,149,0.6)";
    } else if (theme.name === "Spell Stick") {
      holeColor = "#1a0020";
      holeStroke = "#ff69ff";
      glowColor = "rgba(255,105,255,0.6)";
    } else if (theme.name === "Ice Stick") {
      holeColor = "#a0e8ff";
      holeStroke = "#ffffff";
      glowColor = "rgba(255,255,255,0.7)";
    } else if (theme.name === "Glow Stick") {
      holeColor = "#2a1500";
      holeStroke = "#ffb347";
      glowColor = "rgba(255,179,71,0.6)";
    } else if (theme.name === "Spider Stick") {
      holeColor = "#0d0a12";
      holeStroke = "#8b5cf6";
      glowColor = "rgba(139,92,246,0.6)";
    } else if (theme.name === "Victory Stick") {
      holeColor = "#0a0015";
      holeStroke = "#c27bff";
      glowColor = "rgba(194,123,255,0.6)";
    }

    ctx.save();

    if (pulse > 0){
      ctx.globalAlpha = 0.20 + pulse*0.55;
      ctx.fillStyle = theme.accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + pulse*12, 0, Math.PI*2);
      ctx.fill();
    }

    if (flash > 0){
      ctx.globalAlpha = 0.25 + flash*0.55;
      ctx.fillStyle = "#ff1f3a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + flash*10, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;
    
    // Pulsating glow effect
    const pulsePhase = (Date.now() % 1500) / 1500; // 1.5 second pulse cycle
    const pulseIntensity = 0.5 + Math.sin(pulsePhase * Math.PI * 2) * 0.5; // oscillates 0-1
    
    // Outer glow (pulsating)
    const glowRadius = 18 + pulseIntensity * 4;
    const gradient = ctx.createRadialGradient(cx, cy, 6, cx, cy, glowRadius);
    gradient.addColorStop(0, holeColor);
    gradient.addColorStop(0.6, holeColor);
    const glowAlpha = pulseIntensity * 0.3;
    const finalGlow = glowColor.replace(/[\d.]+\)$/, glowAlpha + ')');
    gradient.addColorStop(1, finalGlow);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, glowRadius, 0, Math.PI*2);
    ctx.fill();

    // Main hole body
    ctx.shadowBlur = 0;
    ctx.fillStyle = holeColor;
    ctx.globalAlpha = 0.92;
    ctx.beginPath();
    ctx.arc(cx, cy, 8 + pulse*2, 0, Math.PI*2);
    ctx.fill();
    
    // Refined subtle pulsating outline
    ctx.globalAlpha = 0.85 + pulseIntensity * 0.15;
    ctx.lineWidth = 1.2 + pulseIntensity * 0.3;
    ctx.strokeStyle = holeStroke;
    ctx.shadowColor = holeStroke;
    ctx.shadowBlur = 6 + pulseIntensity * 4;
    ctx.beginPath();
    ctx.arc(cx, cy, 16 + pulse*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawLifeHint(theme){
    if (game.lifeTileUsed) return;
    if (game.carry.length <= 0) return;
    if (game.playerX !== game.lifeTileX || game.playerY !== game.lifeTileY) return;

    const x = game.lifeTileX*TILE;
    const y = game.lifeTileY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*4) + 1) / 2;

    ctx.save();
    ctx.globalAlpha = 0.15 + osc*0.25;
    ctx.strokeStyle = theme.accent;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x+3, y+3, TILE-6, TILE-6);
    ctx.stroke();
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawTree(theme){
    if (!game.treeActive) return;

    if (game.treePhase === "blinking"){
      const blinkOn = (Math.floor(game.treePhaseTimer / 10) % 2) === 0;
      if (!blinkOn) return;
    }

    const x = game.treeX*TILE;
    const y = game.treeY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*5) + 1) / 2;

    ctx.save();

    ctx.globalAlpha = 0.10 + osc*0.18;
    ctx.strokeStyle = "#39ff95";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x + TILE/2, y + TILE/2, 10 + osc*3, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#a16207";
    ctx.fillRect(x + 11, y + 12, 2, 7);
    ctx.fillRect(x + 10, y + 14, 4, 5);

    ctx.fillStyle = "#22c55e";
    ctx.fillRect(x + 8,  y + 8,  8, 2);
    ctx.fillRect(x + 7,  y + 10, 10, 2);
    ctx.fillRect(x + 8,  y + 12, 8, 2);

    ctx.globalAlpha = 0.35 + osc*0.35;
    ctx.fillStyle = theme.accent;
    ctx.fillRect(x + 6, y + 6, 1, 1);
    ctx.fillRect(x + 17, y + 7, 1, 1);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawStick(s){
    const x = s.x*TILE;
    const y = s.y*TILE;
    ctx.save();
    ctx.translate(x + TILE/2, y + TILE/2);

    const theme = currentLevelTheme();
    if (theme.name === "Ice Stick" || theme.name === "Glow Stick" || theme.name === "Victory Stick"){
      ctx.shadowColor = "rgba(0,0,0,0.18)";
      ctx.shadowBlur = 6;
    }

    ctx.strokeStyle = s.color;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(-6, -8);
    ctx.lineTo(7, 9);
    ctx.stroke();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-4, -6);
    ctx.lineTo(5, 7);
    ctx.stroke();
    ctx.globalAlpha = 1;

    if (s.bonus){
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#ffd166";
      ctx.beginPath();
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawPlayer(){
    const cx = game.playerX*TILE + TILE/2;
    const cy = game.playerY*TILE + TILE/2;

    ctx.save();
    ctx.translate(cx, cy);

    const theme = currentLevelTheme();
    const strokeBase = (theme.name === "Ice Stick") ? "#0b0f14" : "#f3f4f6";
    ctx.strokeStyle = strokeBase;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";

    const skin = game.playerSkin || "classic";

    const drawCarryDots = () => {
      const cap = carryCap();
      const carried = game.carry.length;
      const slots = Math.min(6, cap);
      const startX = -((slots-1)*4)/2;
      const isFull = carried >= cap;

      for (let i=0;i<slots;i++){
        ctx.beginPath();
        const filled = i < carried;
        if (isFull){
          ctx.fillStyle = filled ? "#ff1f3a" : "rgba(255,31,58,0.25)";
        } else {
          ctx.fillStyle = filled ? "#ffd166" : "rgba(243,244,246,0.18)";
        }
        ctx.arc(startX + i*4, 17, 1.5, 0, Math.PI*2);
        ctx.fill();
      }
    };

    const drawClassicBody = () => {
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    };

    if (skin === "alien"){
      ctx.beginPath();
      ctx.arc(0, -7, 7, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, -14);
      ctx.lineTo(-6, -19);
      ctx.moveTo(3, -14);
      ctx.lineTo(6, -19);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = "#ffd166";
      ctx.arc(-6, -20, 1.6, 0, Math.PI*2);
      ctx.arc(6, -20, 1.6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = strokeBase;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 3);
      ctx.lineTo(7, 1);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "sally"){
      ctx.beginPath();
      ctx.arc(0, -8, 4.5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(-7, 9);
      ctx.lineTo(7, 9);
      ctx.closePath();
      ctx.fillStyle = strokeBase;
      ctx.globalAlpha = 0.16;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = strokeBase;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(-11, 4);
      ctx.moveTo(7, 2);
      ctx.lineTo(11, 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, 9);
      ctx.lineTo(-6, 13);
      ctx.moveTo(3, 9);
      ctx.lineTo(6, 13);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rick"){
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-4, -11);
      ctx.lineTo(-2, -14);
      ctx.moveTo(-1, -11);
      ctx.lineTo(1, -15);
      ctx.moveTo(2, -11);
      ctx.lineTo(4, -14);
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(-4, -9, 3, 3);
      ctx.rect(1, -9, 3, 3);
      ctx.moveTo(-1, -7.5);
      ctx.lineTo(1, -7.5);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "robot"){
      // Pulsating value for eyes and antenna
      const eyePulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
      const eyeGlow = 0.4 + eyePulse * 0.6;
      
      // head
      ctx.beginPath();
      ctx.rect(-6, -13, 12, 10);
      ctx.stroke();

      // antenna
      ctx.beginPath();
      ctx.moveTo(0, -13);
      ctx.lineTo(0, -18);
      ctx.stroke();
      
      // antenna tip (RED pulsating to match eyes!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 3 + eyePulse * 5;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.beginPath();
      ctx.arc(0, -19, 1.8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.strokeStyle = strokeBase;

      // eyes (RED pulsating glow!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 4 + eyePulse * 6;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.fillRect(-4, -10, 3, 2);
      ctx.fillRect(1, -10, 3, 2);
      ctx.restore();
      
      // Eye outlines
      ctx.beginPath();
      ctx.rect(-4, -10, 3, 2);
      ctx.rect(1, -10, 3, 2);
      ctx.stroke();

      // body
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(0, 9);
      ctx.stroke();

      // arms
      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(7, 2);
      ctx.stroke();

      // legs
      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rex"){
      // Rex Stick - pure simple stick dog!
      // Uses strokeBase (dark on Ice Stick, white elsewhere)
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      
      // BIG Head (circle outline)
      ctx.beginPath();
      ctx.arc(0, -10, 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // BIG Ears (longer lines sticking up)
      ctx.beginPath();
      ctx.moveTo(-4, -14);
      ctx.lineTo(-5, -18);
      ctx.moveTo(4, -14);
      ctx.lineTo(5, -18);
      ctx.stroke();
      
      // Short body
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(0, 2);
      ctx.stroke();
      
      // Minimal cute legs (just little stubs)
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-2, 2);
      ctx.lineTo(-2, 6);
      ctx.moveTo(2, 2);
      ctx.lineTo(2, 6);
      ctx.stroke();
      
      // Wagging tail! (wags left and right like a real dog!)
      const waggle = Math.sin(Date.now() / 150) * 0.8; // swings from -0.8 to +0.8
      ctx.save();
      ctx.translate(0, -1);
      ctx.rotate(waggle);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(3, -1, 6, -4);
      ctx.stroke();
      ctx.restore();
      
      drawCarryDots();
    }
    else {
      drawClassicBody();
    }

    ctx.restore();
  }

  function drawSparks(){
    if (!game.sparks.length) return;
    ctx.save();
    for (let i=game.sparks.length-1;i>=0;i--){
      const s = game.sparks[i];
      s.x += s.vx;
      s.y += s.vy;
      s.vx *= 0.96;
      s.vy *= 0.96;
      s.life -= 1;

      const a = clamp(s.life / 40, 0, 1);
      ctx.globalAlpha = 0.15 + a*0.75;
      ctx.fillStyle = s.evil ? "#ff1f3a" : "#f3f4f6";
      ctx.fillRect(s.x, s.y, 2, 2);

      if (s.life <= 0) game.sparks.splice(i,1);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawHudText(){
    if (game.hudTimer > 0 && game.hudMsg){
      game.hudTimer--;
      const t = currentLevelTheme();
      ctx.save();
      ctx.globalAlpha = clamp(game.hudTimer / 60, 0, 1);
      ctx.font = "bold 16px ui-monospace, Menlo, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(game.hudMsg, CANVAS_W/2 + 1, 20 + 1);

      ctx.fillStyle = t.name === "Ice Stick" ? "#0b0f14" : "#f3f4f6";
      ctx.fillText(game.hudMsg, CANVAS_W/2, 20);
      ctx.restore();
    }
  }

  function updateTreeTimers(){
    // freeze during monster battles (as promised in info)
    if (game.pendingMonster) return;

    if (!game.treeSpawnedThisLevel){
      if (game.treeSpawnDelay > 0){
        game.treeSpawnDelay--;
        if (game.treeSpawnDelay <= 0) spawnTreeNow();
      }
      return;
    }

    if (game.treeActive){
      if (game.treePhaseTimer > 0){
        game.treePhaseTimer--;
        if (game.treePhaseTimer <= 0){
          if (game.treePhase === "visible") startTreeBlinking();
          else if (game.treePhase === "blinking") endTree();
        }
      }
    }
  }

  function updateRollButton(){
    ui.btnRoll.disabled = !canRoll() && !game.pendingMonster;
  }

  /* ---- Main loop ---- */
  function loop(){
    rafId = requestAnimationFrame(loop);

    // update
    updateTreeTimers();
    updateRollButton();
    
    // Update fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick" && fireTiles.length > 0){
      updateFireTiles();
    }
    
    // Update wind tiles for Sky Stick theme
    if (currentLevelTheme().name === "Sky Stick" && windTiles.length > 0){
      updateWindTiles();
    }
    
    // Update snakes for Snake Stick theme
    if (currentLevelTheme().name === "Snake Stick" && snakes.length > 0){
      updateSnakes();
    }
    
    // Update freeze zones for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick" && freezeTiles.length > 0){
      updateFreezeTiles();
    }
    
    // Update shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick" && shadowMonsters.length > 0){
      updateShadowMonsters();
    }
    
    // Update ambient particles (shooting stars, etc)
    updateAmbientParticles();
    
    // Update sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick" && sharks.length > 0){
      updateSharks();
    }
    
    // Update sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick" && sunBurstTiles.length > 0){
      updateSunBursts();
    }
    
    // Update star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick" && starGridTiles.length > 0){
      updateStarGrid();
    }
    
    // Update Spell Stick hazards (moving teleports + hole)
    if (currentLevelTheme().name === "Spell Stick"){
      updateLevelHazards();
    }
    
    // Update snowman for Ice Stick
    if (currentLevelTheme().name === "Ice Stick" && snowman){
      updateSnowman();
    }
    
    if (currentLevelTheme().name === "Spider Stick"){
      if (spiderWebs.length > 0) updateSpiderWebs();
      if (spiders.length > 0) updateSpiders();
    }
    
    // Victory Stick - update ALL hazards
    if (currentLevelTheme().name === "Victory Stick"){
      if (windTiles.length > 0) updateWindTiles();
      if (fireTiles.length > 0) updateFireTiles();
      if (snakes.length > 0) updateSnakes();
      if (freezeTiles.length > 0) updateFreezeTiles();
      if (shadowMonsters.length > 0) updateShadowMonsters();
      if (sharks.length > 0) updateSharks();
      if (sunBurstTiles.length > 0) updateSunBursts();
      if (teleportTiles.length > 0) updateLevelHazards();
      if (snowman) updateSnowman();
      if (spiderWebs.length > 0) updateSpiderWebs();
      if (spiders.length > 0) updateSpiders();
    }

    // draw
    const theme = currentLevelTheme();
    drawGrid(theme);
    drawLifeHint(theme);
    drawTree(theme);

    // Star grid (draw BEFORE sticks for layering)
    if (theme.name === "Night Stick" && starGridTiles.length > 0){
      drawStarGrid();
    }

    // sticks
    for (const s of game.sticks) drawStick(s);

    // hole + player glow (behind player)
    drawHole(theme);
    if (theme.name === "Night Stick"){
      drawPlayerGlow();
    }
    drawPlayer();
    
    // Draw wind tiles
    if (theme.name === "Sky Stick" && windTiles.length > 0){
      drawWindTiles();
    }
    
    // Draw snakes
    if (theme.name === "Snake Stick" && snakes.length > 0){
      drawSnakes();
    }
    
    // Draw freeze zones
    if (theme.name === "Ice Stick" && freezeTiles.length > 0){
      drawFreezeTiles();
    }
    
    // Draw shadow monsters
    if (theme.name === "Glow Stick" && shadowMonsters.length > 0){
      drawShadowMonsters();
    }
    
    // Draw sharks for Sea Stick
    if (theme.name === "Sea Stick" && sharks.length > 0){
      drawSharks();
    }
    
    // Draw sun bursts for Sun Stick
    if (theme.name === "Sun Stick" && sunBurstTiles.length > 0){
      drawSunBursts();
    }
    
    // Draw Spell Stick teleports and hole flash
    if (theme.name === "Spell Stick" && teleportTiles.length > 0){
      drawLevelHazards();
    }
    
    // Draw snowman for Ice Stick
    if (theme.name === "Ice Stick" && snowman){
      drawSnowman();
    }
    
    if (theme.name === "Spider Stick"){
      if (spiderWebs.length > 0) drawSpiderWebs();
      if (spiders.length > 0) drawSpiders();
    }
    
    // Victory Stick - draw ALL hazards
    if (theme.name === "Victory Stick"){
      if (windTiles.length > 0) drawWindTiles();
      if (fireTiles.length > 0) drawFireTiles();
      if (snakes.length > 0) drawSnakes();
      if (freezeTiles.length > 0) drawFreezeTiles();
      if (shadowMonsters.length > 0) drawShadowMonsters();
      if (sharks.length > 0) drawSharks();
      if (sunBurstTiles.length > 0) drawSunBursts();
      if (snowman) drawSnowman();
          if (spiderWebs.length > 0) drawSpiderWebs();
      if (spiders.length > 0) drawSpiders();
    }

    drawSparks();
    
    // Draw ambient particles (background)
    drawAmbientParticles();
    
    // Draw ice frost on edges
    drawIceFrost();
    
    // Draw level hazards (dark tiles, teleport tiles)
    drawLevelHazards();
    
    // Draw fire tiles for Fire Stick theme
    if (theme.name === "Fire Stick" && fireTiles.length > 0){
      drawFireTiles();
    }
    

    // Draw stick pickup particles// Draw special effects (shield, vision)
    drawSpecialEffects();
    
    // Draw snowflakes for Ice Stick theme (foreground)
    if (theme.name === "Ice Stick" && snowflakes.length > 0){
      drawSnowflakes();
    }
    
    drawHudText();
  }

  /* ---- UI + Controls ---- */
  function openInfo(){
    ui.infoOverlay.style.display = "flex";
    game.inputLocked = true;
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    window.infoMusicWas = musicOn;
    if (musicOn) stopMusic();
  }
  function closeInfo(){
    ui.infoOverlay.style.display = "none";
    if (!paused && ui.nameOverlay.style.display !== "flex" &&
        ui.gameOverOverlay.style.display !== "flex" &&
        ui.winOverlay.style.display !== "flex"){
      game.inputLocked = false;
    }
    if (!rafId) startLoop();
    if (window.infoMusicWas) { musicOn = true; ui.btnMusic.textContent = "Music: ON"; startMusic(); }
  }

  ui.btnInfo.addEventListener("click", openInfo);
  ui.btnInfoClose.addEventListener("click", closeInfo);

  ui.btnRoll.addEventListener("click", doRoll);
  ui.btnUse.addEventListener("click", pickOrDrop);
  ui.btnNew.addEventListener("click", () => newGame(false));
  ui.btnPause.addEventListener("click", togglePause);
  ui.btnPauseClose.addEventListener("click", togglePause);

  ui.btnSave.addEventListener("click", saveGame);
  ui.btnLoad.addEventListener("click", loadGame);

  ui.btnUp.addEventListener("click", () => move(0,-1));
  ui.btnDown.addEventListener("click", () => move(0,1));
  ui.btnLeft.addEventListener("click", () => move(-1,0));
  ui.btnRight.addEventListener("click", () => move(1,0));

  ui.skin.addEventListener("change", (e) => setAndStoreSkin(e.target.value));

  ui.btnGameOverClose.addEventListener("click", () => {
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });
  ui.btnRestart.addEventListener("click", () => {
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnWinRestart.addEventListener("click", () => {
    ui.winOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnMusic.addEventListener("click", async () => {
    await unlockOnce();
    musicOn = !musicOn;
    ui.btnMusic.textContent = musicOn ? "Music: ON" : "Music: OFF";
    if (musicOn){
      startMusic();
      logEvent("neutral","Music ON.");
    } else {
      stopMusic();
      logEvent("neutral","Music OFF.");
    }
  });

  ui.nameStartBtn.addEventListener("click", startFromNameInput);
  ui.nameUseP1Btn.addEventListener("click", () => { setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); });
  ui.nameUseSavedBtn.addEventListener("click", () => {
    const s = getSavedName();
    setAndStoreName(s || "PLAYER1");
    closeNameModal();
    newGame(true);
  });

  ui.nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){ e.preventDefault(); startFromNameInput(); }
    if (e.key === "Escape"){ e.preventDefault(); setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); }
  });

  document.addEventListener("keydown", (e) => {
    // Check overlays FIRST - don't allow level skip during modals
    if (ui.nameOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        setAndStoreName("PLAYER1");
        closeNameModal();
        newGame(true);
      }
      return;
    }
    if (ui.infoOverlay.style.display === "flex"){
      if (e.key === "Escape"){ e.preventDefault(); closeInfo(); }
      return;
    }
    if (ui.gameOverOverlay.style.display === "flex" || ui.winOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        ui.gameOverOverlay.style.display = "none";
        ui.winOverlay.style.display = "none";
        game.inputLocked = false;
        newGame(false);
      }
      return;
    }

    if (e.key === "p" || e.key === "P" || e.key === "Escape"){
      e.preventDefault();
      togglePause();
      return;
    }
    if (paused) return;

    // save/load hotkeys (only when allowed)
    if ((e.key === "s" || e.key === "S") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      saveGame();
      return;
    }
    if ((e.key === "l" || e.key === "L") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      loadGame();
      return;
    }
    
    // SECRET LEVEL SKIP: Shift + L (only during gameplay, not during modals)
    if (e.shiftKey && (e.key === 'L' || e.key === 'l')){
      e.preventDefault();
      const input = prompt("Skip to level (1-11):");
      if (input){
        const num = parseInt(input);
        if (!isNaN(num) && num >= 1 && num <= 11){
          game.level = num;
          applyThemeForLevel();
          game.sticks = [];
          game.carry = [];
          spawnHole();
          spawnSticksForLevel(game.level);
          spawnLifeTile();
          scheduleTreeForLevel();
          
          const theme = currentLevelTheme().name;
          
          // Clear all hazards first
          windTiles = [];
          fireTiles = [];
          freezeTiles = [];
          snakes = [];
          shadowMonsters = [];
          sharks = [];
          sunBurstTiles = [];
          starGridTiles = [];
          teleportTiles = [];
          spiderWebs = [];
          spiders = [];
          skunks = [];
          stinkClouds = [];
          snowman = null;
          stopIceWindSound();
          
          // Initialize for specific level
          if (theme === "Sky Stick") initWindTiles();
          if (theme === "Fire Stick") initFireTiles();
          if (theme === "Ice Stick"){ initFreezeTiles(); startIceWindSound(); initSnowman(); }
          if (theme === "Snake Stick") initSnakes();
          if (theme === "Spell Stick"){
            teleportTiles = [];
            for(let i=0;i<randInt(5,8);i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
            holeMoveTimer = randInt(600,900);
          }
          if (theme === "Glow Stick") initShadowMonsters();
          if (theme === "Sea Stick") initSharks();
          if (theme === "Sun Stick") initSunBursts();
          if (theme === "Night Stick") initStarGrid();
          if (theme === "Spider Stick"){ initSpiderWebs(); initSpiders(); }
          if (theme === "Victory Stick"){
            windTiles = []; for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
            fireTiles = []; for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
            initSnakes(); snakes = snakes.slice(0,1);
            initFreezeTiles(); freezeTiles = freezeTiles.slice(0,4);
            initShadowMonsters(); shadowMonsters = shadowMonsters.slice(0,1);
            initSharks(); sharks = sharks.slice(0,2);
            initSunBursts(); sunBurstTiles = sunBurstTiles.slice(0,3);
            initSnowman();
            initSpiderWebs(); spiderWebs = spiderWebs.slice(0,3);
            initSpiders(); spiders = spiders.slice(0,2);
            teleportTiles = []; for(let i=0;i<4;i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
            holeMoveTimer = randInt(600,900);
          }
          
          initLevelHazards();
          initAmbientParticles();
          
          logEvent("level", "Skipped to Level " + num + " (" + theme + ")");
          setHud("LEVEL " + num + "!");
          updateUI();
        }
      }
      return;
    }

    if (game.inputLocked && !game.pendingMonster) return;

    if (e.key === "ArrowUp"){ e.preventDefault(); move(0,-1); }
    else if (e.key === "ArrowDown"){ e.preventDefault(); move(0,1); }
    else if (e.key === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if (e.key === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if (e.key === " "){ e.preventDefault(); pickOrDrop(); }
    else if (e.key === "r" || e.key === "R"){ e.preventDefault(); doRoll(); }
    else if (e.key === "s" || e.key === "S"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); saveGame(); } }
    else if (e.key === "l" || e.key === "L"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); loadGame(); } }
  });

  // init
  renderLeaderboard(loadLeaderboard());
  setAndStoreSkin(getSavedSkin());
  const savedName = getSavedName();
  if (savedName) setAndStoreName(savedName);
  applyThemeForLevel();
  updateUI();
  updateScrollHint();

  // always start on name prompt
  showNameModal();
})();
</script>
</body>
</html>
