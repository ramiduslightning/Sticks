<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>STICKS</title>
  <style>
    :root{ color-scheme: dark; }

    body{
      margin:0;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      background:#0b0f14;
      color:#e6edf3;
    }

    .wrap{
      max-width: 1320px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 260px 1fr 420px;
      gap:14px;
      align-items:start;
    }

    .gameWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
    }

    canvas{
      width:100%;
      height:auto;
      border:2px solid var(--lvlBorder, #1f2a37);
      border-radius:12px;
      image-rendering: pixelated;
      background: var(--lvlBg, #070a0e);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15), 0 18px 50px rgba(0,0,0,.35);
      display:block;
      aspect-ratio: 1 / 1;
    }

    .panel{
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:12px;
      padding:12px;
    }

    .panelSticky{
      position: sticky;
      top: 14px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      padding-right: 10px;
    }

    .title{
      font-weight:1000;
      letter-spacing:.6px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }

    .subtitle{
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
      margin-top:6px;
    }

    .hr{ height:1px; background:#1f2a37; margin:10px 0; }

    .log{
      height: 600px;
      overflow:auto;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
      line-height:1.45;
    }
    .log .line{ margin: 0 0 8px 0; }
    .log .line:last-child{ margin-bottom:0; }

    .kv{ display:flex; justify-content:space-between; gap:10px; margin:6px 0; align-items:center; }
    .kv span:first-child{ color:#9fb1c6; }
    .big{ font-size:18px; font-weight:1000; }

    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      font-weight:1000;
      font-size:12px;
      user-select:none;
    }

    .playerArcade{
      font-size:22px;
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      text-shadow: 0 0 18px rgba(120,180,255,0.18);
      user-select:none;
    }

    .controlsTop{
      display:grid;
      grid-template-columns: 132px 1fr;
      gap:12px;
      align-items:center;
    }

    .diceBox{
      width:132px;
      height:132px;
      border-radius:16px;
      border:2px solid #2b3a4c;
      background: radial-gradient(120px 120px at 40% 35%, #1a2a3c 0%, #0b1220 70%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .diceGlow{
      position:absolute;
      inset:-40px;
      background: conic-gradient(from 180deg,
        rgba(0,0,0,0),
        rgba(0,0,0,0),
        var(--lvlAccentGlow, rgba(58,167,255,.32)),
        rgba(0,0,0,0)
      );
      opacity:0;
      filter: blur(10px);
      transform: rotate(0deg);
      pointer-events:none;
    }
    .rolling .diceGlow{ opacity:1; animation: spin .32s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .diceFace{
      font-size:52px;
      font-weight:1000;
      line-height:1;
      text-shadow: 0 0 16px var(--lvlAccentShadow, rgba(58,167,255,.25));
      user-select:none;
    }
    .diceLabel{
      margin-top:8px;
      font-size:12px;
      color:#9fb1c6;
      text-align:center;
      line-height:1.25;
      user-select:none;
    }

    .dpadWrap{ margin-top:10px; display:flex; justify-content:center; align-items:center; }
    .dpad{ width:200px; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .dpad button{
      padding:10px 0;
      border-radius:12px;
      color:#e6edf3;
      background: linear-gradient(180deg,#1b2432,#0b1220);
      border:1px solid #2b3a4c;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.10),
        0 8px 18px rgba(0,0,0,.35);
      font-weight:1000;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      text-shadow: 0 0 14px rgba(255,255,255,0.08);
    }
    .dpad button:hover{ filter: brightness(1.08); }
    .dpad button:active{ transform: translateY(1px); }
    .dpad .empty{ visibility:hidden; }

    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-top:10px;
    }

    button{
      cursor:pointer;
      border:0;
      padding:11px 10px;
      border-radius:12px;
      font-weight:1000;
      letter-spacing:.2px;
      user-select:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.08); }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; }

    .btn-roll { background: linear-gradient(180deg,#3aa7ff,#1172ff); color:#061018; }
    .btn-use  { background: linear-gradient(180deg,#39ff95,#08c46b); color:#061018; }
    .btn-new  { background: linear-gradient(180deg,#ffb347,#ff7a18); color:#1a0f00; }
    .btn-clear{ background: linear-gradient(180deg,#ff5a6a,#ff1f3a); color:#200007; }

    .btn-save { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }
    .btn-load { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }

    .btn-music{ background: linear-gradient(180deg,#c27bff,#7a35ff); color:#120018; grid-column: 1 / span 2; }
    .btn-info { background: linear-gradient(180deg,#f3f4f6,#cbd5e1); color:#0b0f14; }

    .titleBtns{ display:flex; align-items:center; gap:8px; }
    .btn-mini{
      padding:8px 10px;
      border-radius:12px;
      font-weight:1000;
      box-shadow:none;
      min-width:44px;
      line-height:1;
    }

    @keyframes flashRoll {
      0%   { box-shadow: 0 0 0 0 rgba(255,255,255,0.0); transform: translateY(0); }
      100% { box-shadow: 0 0 0 3px rgba(255,255,255,0.75); transform: translateY(-1px); }
    }
    .flashRoll{ animation: flashRoll 0.55s ease-in-out infinite alternate; }

    .monsterEvent{
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #ff1f3a;
      background:#1a0509;
      display:flex;
      gap:8px;
      align-items:flex-start;
      font-size:12px;
      line-height:1.35;
    }
    .monsterEventIcon{ font-size:20px; margin-top:2px; }
    .monsterEventTitle{ font-weight:1000; color:#ffb347; margin-bottom:3px; }

    .statsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #1f2a37;
      background:#0b1220;
    }
    .statsGrid .kv{ margin:0; }
    .statsGrid .big{ font-size:16px; }

    .leaderboard{
      margin-top:10px;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
    }
    .leaderRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 6px;
      border-radius:10px;
    }
    .leaderRow:nth-child(odd){ background: rgba(255,255,255,0.03); }
    .leaderName{ font-weight:1000; letter-spacing:.3px; }
    .leaderMeta{ color:#9fb1c6; }
    .gold { color:#ffd166; }
    .silver { color:#cbd5e1; }
    .bronze { color:#ffb347; }

    .battleFeedWrap{
      margin-top:10px;
      border:1px solid #1f2a37;
      border-radius:12px;
      background:#0b1220;
      padding:10px;
    }
    .battleFeedHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
    }
    .battleFeedHeader b{ letter-spacing:.4px; }
    .battleLog{
      max-height: 220px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      border-radius:10px;
      border:1px solid #1f2a37;
      padding:10px;
      background:#070c16;
      font-size:12px;
      line-height:1.45;
    }

    .scrollHint{
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px dashed #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.25;
      text-align:center;
      user-select:none;
    }
    .scrollHint .arrow{
      display:inline-block;
      font-weight:1000;
      margin-left:6px;
      animation: bob 1.1s ease-in-out infinite;
    }
    @keyframes bob{
      0%,100%{ transform: translateY(0); opacity:.75; }
      50%{ transform: translateY(2px); opacity:1; }
    }

    /* ‚úÖ stick figure selector */
    select{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      cursor:pointer;
    }
    select:focus{ box-shadow: 0 0 0 3px rgba(58,167,255,0.18); }

    #infoOverlay,#nameOverlay,#gameOverOverlay,#winOverlay,#pauseOverlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.72);
      z-index:9999;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .modalBox{
      width:min(780px,94vw);
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:16px;
      padding:16px;
      max-height: calc(var(--vh, 1vh) * 92);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    .modalTitle{ font-weight:1000; letter-spacing:.8px; font-size:18px; }
    .modalText{
      color:#cdd9e5;
      font-size:13px;
      line-height:1.45;
      margin-top:8px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 6px;
      white-space: pre-wrap;
    }
    .modalActions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:14px;
      flex-wrap:wrap;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(15,23,32,0.0), rgba(15,23,32,0.88) 30%, rgba(15,23,32,1));
      padding-top: 10px;
    }
    .modalClose{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      box-shadow:none;
    }

    /* ‚úÖ Win/Lose presentation */
    .endBanner{
      margin-top:10px;
      border-radius:14px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      overflow:hidden;
      position:relative;
    }
    .endBanner .bigIcon{
      font-size:34px;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.12));
      animation: pop 0.9s ease-in-out infinite alternate;
      user-select:none;
    }
    @keyframes pop { from{ transform: translateY(0) scale(1); } to{ transform: translateY(-2px) scale(1.04); } }

    .endBanner .endHeadline{
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      font-size:14px;
    }
    .endBanner .endSub{
      color:#9fb1c6;
      font-size:12px;
      margin-top:4px;
      line-height:1.25;
    }

    .fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .fx span{
      position:absolute;
      font-size:14px;
      opacity:0.9;
      animation: drift 1.6s linear forwards;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.10));
      user-select:none;
    }
    @keyframes drift{
      from{ transform: translateY(0) rotate(0deg); opacity:0.95; }
      to{ transform: translateY(140px) rotate(180deg); opacity:0; }
    }

    .winBanner{
      border-color: rgba(194,123,255,0.65);
      background: radial-gradient(340px 140px at 35% 25%, rgba(194,123,255,0.22) 0%, rgba(7,12,22,1) 65%);
    }
    .loseBanner{
      border-color: rgba(255,90,106,0.7);
      background: radial-gradient(340px 140px at 35% 25%, rgba(255,31,58,0.20) 0%, rgba(7,12,22,1) 65%);
    }

    #nameOverlay input{
      flex:1;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      font-size:16px;
      letter-spacing:.6px;
      text-transform: uppercase;
    }
    .saveBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #39ff95;
      background: linear-gradient(180deg,#39ff95,#08c46b);
      color:#061018;
      font-weight:1000;
      box-shadow:none;
    }
    .altBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#f3f4f6,#cbd5e1);
      color:#0b0f14;
      font-weight:1000;
      box-shadow:none;
    }
    .warnBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #ff5a6a;
      background: linear-gradient(180deg,#ff5a6a,#ff1f3a);
      color:#200007;
      font-weight:1000;
      box-shadow:none;
    }
    .hintRow{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
    }

    @media (max-width:1200px){
      .wrap{ grid-template-columns:1fr; }
      .log{ height:220px; }
      .controlsTop{ grid-template-columns:1fr; }
      .diceBox{ width:100%; height:120px; }
      .dpad{ width:100%; max-width:240px; }
      .panelSticky{ position: static; max-height: none; overflow: visible; padding-right:12px; }
    }

    @media (max-width:720px){
      .wrap > .panel:first-child{ display:none; }

      body{
        height: calc(var(--vh, 1vh) * 100);
        overflow:hidden;
      }

      .wrap{
        height: calc(var(--vh, 1vh) * 100);
        max-width:none;
        margin:0;
        padding:10px;
        gap:10px;
        grid-template-columns: 1fr;
        grid-template-rows: 1.35fr 1fr;
        align-items:stretch;
      }

      .gameWrap{
        height:100%;
        min-height:0;
      }

      canvas{
        width:auto;
        height:100%;
        max-width:100%;
        max-height:100%;
      }

      .panel-right{
        height:100%;
        min-height:0;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        display:flex;
        flex-direction:column;
        padding-bottom: calc(env(safe-area-inset-bottom) + 90px);
      }

      .controlsScroll{ order:1; }
      .headerBlock{ order:2; margin-top:10px; }
      .headerBlock .hr{ margin:10px 0 0 0; }

      .controlsTop{
        grid-template-columns: 1fr;
        gap:8px;
        margin-top:2px;
      }
      .controlsTop .subtitle{ display:none; }

      .diceBox{
        width:100%;
        height:84px;
        border-radius:14px;
      }
      .diceFace{ font-size:40px; }
      .diceLabel{ font-size:11px; margin-top:4px; }

      .controlsScroll{
        overflow: visible;
        -webkit-overflow-scrolling: auto;
        min-height:auto;
        padding-right:0;
        flex: 0 0 auto;
      }

      .battleFeedWrap{ display:block; }
    }

    @media (min-width:721px){
      .battleFeedWrap{ display:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="title"><div>Activity</div><span class="badge" id="uiThemeMini">Night Stick</span></div>
      <div class="subtitle">Latest on top. Color = importance.</div>
      <div class="hr"></div>
      <div class="log" id="log"></div>
    </div>

    <div class="gameWrap">
      <canvas id="game"></canvas>
    </div>

    <div class="panel panelSticky panel-right">
      <div class="controlsScroll" id="controlsScroll">
        <div class="controlsTop">
          <div class="diceBox" id="diceBox">
            <div class="diceGlow"></div>
            <div class="diceFace" id="diceFace">‚Äî</div>
            <div class="diceLabel" id="diceLabel">Press Roll</div>
          </div>
          <div class="subtitle">
            <b>Actions</b> = your energy.<br/>
            Spend Actions to <span class="badge">Move</span> or <span class="badge">Pick/Drop</span>.<br/>
            <span style="color:#9fb1c6">Spend Actions before rolling again.</span>
          </div>
        </div>

        <div class="scrollHint" id="scrollHint">
          Swipe up for controls, stats, and battle feed <span class="arrow">‚ñº</span>
        </div>

        <div id="monsterEvent" class="monsterEvent" style="display:none;">
          <div class="monsterEventIcon">üëπ</div>
          <div>
            <div class="monsterEventTitle">Stick Monster Appears!</div>
            <div id="monsterEventText">
              Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a 2√ó stick. Roll 0‚Äì1 and you lose 1 life.
            </div>
          </div>
        </div>

        <div class="dpadWrap" aria-label="D-pad">
          <div class="dpad">
            <button class="empty"></button>
            <button id="btnUp" aria-label="Up">‚ñ≤</button>
            <button class="empty"></button>
            <button id="btnLeft" aria-label="Left">‚óÄ</button>
            <button id="btnDown" aria-label="Down">‚ñº</button>
            <button id="btnRight" aria-label="Right">‚ñ∂</button>
          </div>
        </div>

        <div class="btns">
          <button id="btnRoll" class="btn-roll">üé≤ Roll</button>
          <button id="btnUse" class="btn-use">Pick/Drop</button>
          <button id="btnNew" class="btn-new">New Game</button>
          <button id="btnPause" class="btn-clear">‚è∏ Pause</button>
          <button id="btnMusic" class="btn-music">Music: OFF</button>
        </div>

        <div class="hr"></div>

        <div class="kv"><span>Player</span><span id="uiPlayer" class="playerArcade">PLAYER1</span></div>

        <div class="kv"><span>Stick Figure</span>
          <select id="uiSkin" aria-label="Stick Figure">
            <option value="classic">Classic</option>
            <option value="alien">Alien Stick</option>
            <option value="sally">Sally Stick</option>
            <option value="rick">Rick Stick</option>
            <option value="robot">Robo Stick</option>
            <option value="rex">Rex Stick</option>
          </select>
        </div>

        <div class="statsGrid">
          <div class="kv"><span>Lives</span><span id="uiLives" class="big">3</span></div>
          <div class="kv"><span>Level</span><span id="uiLevel" class="big">1</span></div>
          <div class="kv"><span>Score</span><span id="uiScore" class="big">0</span></div>
          <div class="kv"><span>Actions</span><span id="uiActions" class="big">0</span></div>
          <div class="kv"><span>Mode</span><span id="uiMode" class="big">NORMAL</span></div>
          <div class="kv"><span>Die</span><span id="uiDie" class="big">0‚Äì5</span></div>
          <div class="kv"><span>Carrying</span><span id="uiCarry" class="big">0/3</span></div>
          <div class="kv"><span>Sticks left</span><span id="uiLeft" class="big">0</span></div>
        </div>

        <div class="leaderboard" id="leaderboard"></div>

        <div class="battleFeedWrap" id="battleFeedWrap">
          <div class="battleFeedHeader">
            <b>Battle Feed</b>
            <span class="badge">Latest</span>
          </div>
          <div style="color:#9fb1c6; font-size:12px; margin-bottom:8px;">
            Monster wins, deposits, level-ups, and warnings show up here.
          </div>
          <div class="battleLog" id="battleLog"></div>
        </div>

        <div style="height:10px;"></div>
      </div>

      <div class="headerBlock">
        <div class="title">
          <div>STICKS <span class="badge">v2.41</span></div>
          <div class="titleBtns">
            <button id="btnSave" class="btn-save btn-mini" aria-label="Save Game" title="Save (S)">üíæ</button>
            <button class="btn-info btn-mini" id="btnInfo" title="Info">Info</button>
            <button id="btnLoad" class="btn-load btn-mini" aria-label="Load Game" title="Load (L)">üìÇ</button>
          </div>
        </div>
        <div class="subtitle">Pick up sticks. Feed the hole. Clear the field. Advance levels.</div>
        <div class="hr"></div>
      </div>
    </div>
  </div>

  <div id="infoOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">How to Play (Quick)</div>
      <div class="modalText">
        <div style="margin:8px 0;"><span class="badge">Roll</span> gives Actions. You must spend Actions before rolling again.</div>
        <div style="margin:8px 0;"><span class="badge">Move</span> costs 1 Action per step (Arrow Keys or D-Pad).</div>
        <div style="margin:8px 0;"><span class="badge">Pick/Drop</span> costs 1 Action:
          pick a stick if on one, <b>place 1 carried stick</b> onto an empty tile, or deposit into the hole.
        </div>
        <div style="margin:8px 0;"><span class="badge">Zero</span>:
          if carrying sticks, you drop and they scatter. If carrying none, the hole gets angry and spits out a stick.
        </div>

        <div style="margin:8px 0;"><span class="badge">Bonus Stick</span>:
          a secret Bonus stick pays out in 2 parts:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
            <li><b>If you have Actions left</b> after picking it up, your remaining Actions are <b>doubled</b>.</li>
            <li><b>After Actions hit 0</b>, you get a <b>Bonus Roll</b> (double dice <b>2‚Äì12</b>).</li>
            <li><b>If you hit 0 Actions immediately</b> after picking it up, the <b>Bonus Roll happens right away</b>.</li>
          </ul>
          During Bonus Roll mode: deposits are <b>2√ó</b>. Roll <b>12</b> to earn <b>one extra Bonus roll</b> (after Actions hit 0).
        </div>

        <div style="margin:8px 0;"><span class="badge">Extra Life (Secret Tile)</span>:
          each level hides <b>one secret tile</b>.
          The tile only hints/pulses when you are <b>standing on it</b> while <b>carrying a stick</b>.
          If you <b>drop</b> a stick on that square, you gain <b>+1 life</b> (the stick is used up).
          <b>If you are already at max lives</b>, you get <b>bonus points</b> instead.
        </div>

        
        <div style="margin:8px 0;"><span class="badge">Special Power Sticks</span>:
          rarely, you may find special colored sticks with unique temporary powers. Discover what each one does!
        </div>

        <div style="margin:8px 0;"><span class="badge">Mystery Tree</span>:
          a tree may appear during a level. <b>(Tree timer freezes during Stick Monster battles.)</b>
          While standing on it:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
            <li><b>If carrying sticks:</b> press <b>Pick/Drop</b> to feed <b>1 stick</b> for <b>+1 life</b>. <b>If already max lives</b>, that stick becomes <b>bonus points</b>.</li>
            <li><b>If carrying 0 sticks:</b> press <b>Pick/Drop</b> to instantly get a <b>full load</b> (fills to your carry limit for that level).</li>
            <li><b>Tree balance:</b> after you successfully <b>gain a life</b> from the tree, it <b>disappears</b>. If there are <b>no sticks left on the ground</b> and you use the tree to get a <b>full load</b>, it also <b>disappears</b>.</li>
          </ul>
        </div>

        <div style="margin:8px 0;"><span class="badge">Level Challenges</span>:
          Each of the 9 level themes features unique environmental hazards and gameplay twists. 
          Stay alert and adapt your strategy as you progress through Sun, Snake, Sky, Sea, Glow, Spell, Ice, Fire, and Victory Stick!
        </div>

        <div style="margin:8px 0;"><span class="badge">Stick Monster</span>:
          some sticks are cursed. When you try to pick one up, a Stick Monster appears.
          Press <b>ROLL</b>: roll <b>2‚Äì5</b> to keep a powered-up stick, roll <b>0‚Äì1</b> and you lose 1 life.
          <div style="margin-top:6px;color:#9fb1c6;">
            <b>Streak Bonus:</b>
            <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5;">
              <li>Each monster win in a row builds a <b>Monster streak</b>.</li>
              <li>The streak persists across levels and only resets when you <b>lose</b> a monster fight (roll 0‚Äì1).</li>
              <li>On your <b>3rd consecutive win</b> you gain <b>+1 life</b> (max 5).</li>
              <li>Monster sticks are normally <b>2√ó</b>. Starting on your <b>4th consecutive win</b>, they scale up: <b>3√ó ‚Üí 4√ó ‚Üí 5√ó ‚Üí ...</b> until you lose.</li>
            </ul>
          </div>
        </div>

        <div style="margin:8px 0; color:#9fb1c6;">Controls: Arrow Keys or D-Pad ‚Ä¢ Space = Pick/Drop ‚Ä¢ Esc or P = Pause</div>
        <div style="margin:10px 0; color:#9fb1c6;"><b>Save/Load:</b> saves only on this device (local browser storage).</div>
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnInfoClose">Close</button>
      </div>
    </div>
  </div>

  <div id="nameOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">ENTER YOUR NAME</div>
      <div class="modalText" style="color:#9fb1c6">Stored only on this device (local browser storage).</div>

      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <input id="nameInput" maxlength="16" placeholder="ENTER NAME"/>
        <button id="nameStartBtn" class="saveBtn">Start</button>
      </div>

      <div class="hintRow" id="savedNameHint" style="display:none;"></div>

      <div class="modalActions" style="justify-content:flex-start;">
        <button id="nameUseSavedBtn" class="altBtn" style="display:none;">Use SAVED</button>
        <button id="nameUseP1Btn" class="warnBtn">Use PLAYER1</button>
      </div>

      <div class="modalText" style="color:#9fb1c6; margin-top:10px;">Press <b>Enter</b> to start ‚Ä¢ <b>Esc</b> uses PLAYER1</div>
    </div>
  </div>

  <div id="pauseOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">PAUSED</div>
      <div class="modalText" style="color:#9fb1c6">
        Game + music are paused.<br/>
        Press <b>Pause</b> again to resume.
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnPauseClose">Resume</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">GAME OVER</div>

      <div class="endBanner loseBanner">
        <div>
          <div class="endHeadline">The sticks won this round</div>
          <div class="endSub">No shame. Just‚Ä¶ stick disrespect.</div>
        </div>
        <div class="bigIcon">üíÄ</div>
        <div class="fx" id="loseFx"></div>
      </div>

      <div class="modalText" id="gameOverText">The sticks won this time.</div>
      <div class="modalActions">
        <button class="modalClose" id="btnGameOverClose">Close</button>
        <button class="modalClose" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>

  <div id="winOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">YOU WIN</div>

      <div class="endBanner winBanner">
        <div>
          <div class="endHeadline">Victory Stick cleared</div>
          <div class="endSub">Fanfare engaged. Ego permitted.</div>
        </div>
        <div class="bigIcon">üèÜ</div>
        <div class="fx" id="winFx"></div>
      </div>

      <div class="modalText" id="winText">You cleared the sticks. The hole is satisfied (for now).</div>
      <div class="modalActions">
        <button class="modalClose" id="btnWinRestart">Play Again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar, { passive:true });
  window.addEventListener('orientationchange', setVhVar, { passive:true });

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (lo, hi) => Math.floor(Math.random() * (hi - lo + 1)) + lo;

  const LS_PLAYER_NAME  = "sticks_playerName_v3";
  const LS_LEADERBOARD  = "sticks_leaderboard_v1";
  const LS_SAVEGAME     = "sticks_savegame_v1";
  const SS_SCROLLED     = "sticks_scrolled_controls_v1";
  const LS_PLAYER_SKIN  = "sticks_playerSkin_v1";

  /* ---- Level Themes + Stick Names ---- */
  const LEVELS = [
    { name:"Sun Stick",     bg:"#140a03", grid:"#4a3a06", border:"#ffd400", accent:"#ffd400", accentGlow:"rgba(255,212,0,.46)", accentShadow:"rgba(255,212,0,.28)" },
    { name:"Sky Stick",     bg:"#041027", grid:"#0b234a", border:"#1172ff", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.46)", accentShadow:"rgba(58,167,255,.30)" },
    { name:"Sea Stick",     bg:"#0a1a2e", grid:"#1e3a5f", border:"#00d9ff", accent:"#00d9ff", accentGlow:"rgba(0,217,255,.46)", accentShadow:"rgba(0,217,255,.30)" },
    { name:"Spell Stick",   bg:"#180414", grid:"#330b2a", border:"#ff69b4", accent:"#ff69ff", accentGlow:"rgba(255,105,255,.46)", accentShadow:"rgba(255,105,180,.30)" },
    { name:"Snake Stick",   bg:"#04120a", grid:"#0a2414", border:"#08c46b", accent:"#39ff95", accentGlow:"rgba(57,255,149,.44)", accentShadow:"rgba(57,255,149,.28)" },
    { name:"Glow Stick",    bg:"#09060f", grid:"#ffb347", border:"#ff7a18", accent:"#ffb347", accentGlow:"rgba(255,122,24,.46)", accentShadow:"rgba(255,122,24,.22)" },
    { name:"Ice Stick",     bg:"#c8e6ff", grid:"#ffffff", border:"#ffffff", accent:"#ffffff", accentGlow:"rgba(255,255,255,.42)", accentShadow:"rgba(255,255,255,.22)" },
    { name:"Fire Stick",    bg:"#1a0509", grid:"#361017", border:"#ff1f3a", accent:"#ff5a6a", accentGlow:"rgba(255,31,58,.46)", accentShadow:"rgba(255,90,106,.30)" },
    { name:"Victory Stick", bg:"#070315", grid:"#c27bff", border:"#7a35ff", accent:"#c27bff", accentGlow:"rgba(194,123,255,.55)", accentShadow:"rgba(194,123,255,.30)" }
  ];

  const STICK_COLORS = [
    "#ff5a6a","#ff1f3a","#ffb347","#ff7a18","#39ff95","#08c46b",
    "#3aa7ff","#1172ff","#c27bff","#7a35ff","#ffd166","#a8dadc",
    "#95d5b2","#ff9f1c","#b08cff","#f3f4f6"
  ];

  const TILE = 24, GRID_W = 24, GRID_H = 24;
  const CANVAS_W = GRID_W * TILE, CANVAS_H = GRID_H * TILE;





  // Fire hazards for Fire Stick theme
  let fireTiles = [];
  let fireWarningTimer = 0;
  const FIRE_WARNING_TIME = 300; // 5 seconds to escape
  // Freeze zones for Ice Stick (like fire hazards!)
  let freezeTiles = [];
  let freezeWarningTimer = 0;
  const FREEZE_WARNING_TIME = 300; // 5 seconds like fire
  
  function initFreezeTiles(){
    freezeTiles = [];
    // Create 6-9 random freeze tiles
    const numFreeze = randInt(6, 9);
    for (let i = 0; i < numFreeze; i++){
      const x = randInt(0, GRID_W - 1);
      const y = randInt(0, GRID_H - 1);
      freezeTiles.push({
        x, y,
        shimmer: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateFreezeTiles(){
    // Animate shimmer
    for (let freeze of freezeTiles){
      freeze.shimmer = (freeze.shimmer + 0.08) % (Math.PI * 2);
    }
    
    // Check if player is on freeze tile
    const onFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFreeze){
      freezeWarningTimer++;
      if (freezeWarningTimer >= FREEZE_WARNING_TIME){
        // Player stayed too long - freeze and lose life!
        // HOLE IS SACRED - no damage if on hole
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          freezeWarningTimer = 0;
        } else if (activeShield > 0){
          freezeWarningTimer = 0;
          logEvent("info", "Shield protected you from freezing!");
          setHud("SHIELD SAVED YOU!");
        } else {
          game.lives--;
          game.holeLostLife = true;
          freezeWarningTimer = 0;
          logEvent("bad", "Frozen solid! -1 life");
          setHud("FROZEN!");
          playFreezeSound();
          sfxLoseLife();
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) endGame();
          else updateUI();
        }
      } else if (freezeWarningTimer === 60){
        // Warning at 1 second
        playFreezeWarningSound();
        logEvent("warn", "Freezing! Move or lose a life!");
        setHud("FREEZING!");
      } else if (freezeWarningTimer === 150 || freezeWarningTimer === 240){
        // Additional warnings
        playFreezeWarningSound();
      }
    } else {
      freezeWarningTimer = 0;
    }
  }
  
  function drawFreezeTiles(){
    ctx.save();
    for (let freeze of freezeTiles){
      const x = freeze.x * TILE + TILE / 2;
      const y = freeze.y * TILE + TILE / 2;
      
      const shimmer = Math.sin(freeze.shimmer) * 0.5 + 0.5;
      
      // Ice crystal base (light blue)
      const iceGrad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      iceGrad.addColorStop(0, 'rgba(200,230,255,' + (0.6 + shimmer * 0.2) + ')');
      iceGrad.addColorStop(0.5, 'rgba(150,210,255,' + (0.4 + shimmer * 0.2) + ')');
      iceGrad.addColorStop(1, 'rgba(100,180,230,0)');
      ctx.fillStyle = iceGrad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Ice crystal shape (snowflake-like)
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.7 + shimmer * 0.3) + ')';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 4 + shimmer * 4;
      
      // 6 pointed crystal
      for (let i = 0; i < 6; i++){
        const angle = (Math.PI / 3) * i + freeze.shimmer;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
        ctx.stroke();
      }
      
      // Center
      ctx.fillStyle = 'rgba(255,255,255,' + (0.8 + shimmer * 0.2) + ')';
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw warning indicator if player is on freeze
    if (freezeWarningTimer > 0){
      const playerOnFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFreeze){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(freezeWarningTimer * 0.3) * 0.5 + 0.5;
        
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#00d9ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }
  
  // Freeze warning sound
  function playFreezeWarningSound(){
    beep(400, 0.1, "sine", 0.06);
    setTimeout(() => beep(350, 0.1, "sine", 0.06), 100);
    setTimeout(() => beep(300, 0.1, "sine", 0.06), 200);
  }
  
  // Freeze damage sound

  // Victory Stick - Ultimate Challenge (all hazards!)
  let victoryHazards = {
    snake: null,
    shark: null,
    shadow: null,
    fires: [],
    winds: [],
    freezes: []
  };
  
  function initVictoryHazards(){
    victoryHazards = {
      snake: null,
      shark: null,
      shadow: null,
      fires: [],
      winds: [],
      freezes: []
    };
    
    // 1 snake
    let sx, sy;
    do {
      sx = randInt(0, GRID_W - 1);
      sy = randInt(0, GRID_H - 1);
    } while (Math.abs(sx - game.playerX) + Math.abs(sy - game.playerY) < 5);
    victoryHazards.snake = { x: sx, y: sy, slither: 0 };
    
    // 1 shark
    victoryHazards.shark = {
      x: randInt(2, GRID_W - 3),
      y: randInt(2, GRID_H - 3),
      horizontal: Math.random() > 0.5,
      direction: Math.random() > 0.5 ? 1 : -1,
      swim: 0
    };
    
    // 1 shadow monster
    victoryHazards.shadow = {
      x: randInt(0, GRID_W - 1),
      y: randInt(0, GRID_H - 1),
      pulse: 0,
      moveTimer: 60
    };
    
    // 2 fire tiles
    for (let i = 0; i < 2; i++){
      victoryHazards.fires.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        intensity: Math.random() * Math.PI * 2
      });
    }
    
    // 2 wind tiles
    for (let i = 0; i < 2; i++){
      victoryHazards.winds.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        intensity: Math.random() * Math.PI * 2
      });
    }
    
    // 2 freeze tiles
    for (let i = 0; i < 2; i++){
      victoryHazards.freezes.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        shimmer: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateVictoryHazards(){
    if (game.pendingMonster) return;
    
    // Update snake
    if (victoryHazards.snake){
      victoryHazards.snake.slither = (victoryHazards.snake.slither + 0.15) % (Math.PI * 2);
      // Move every 150 frames
      if (!updateVictoryHazards.snakeTimer) updateVictoryHazards.snakeTimer = 0;
      updateVictoryHazards.snakeTimer++;
      if (updateVictoryHazards.snakeTimer >= 150){
        updateVictoryHazards.snakeTimer = 0;
        const dx = game.playerX - victoryHazards.snake.x;
        const dy = game.playerY - victoryHazards.snake.y;
        if (Math.abs(dx) > Math.abs(dy)){
          if (dx > 0) victoryHazards.snake.x++;
          else victoryHazards.snake.x--;
        } else if (Math.abs(dy) > 0){
          if (dy > 0) victoryHazards.snake.y++;
          else victoryHazards.snake.y--;
        }
        victoryHazards.snake.x = clamp(victoryHazards.snake.x, 0, GRID_W - 1);
        victoryHazards.snake.y = clamp(victoryHazards.snake.y, 0, GRID_H - 1);
        
        // Check collision
        if (victoryHazards.snake.x === game.playerX && victoryHazards.snake.y === game.playerY &&
            !(game.playerX === game.holeX && game.playerY === game.holeY) && !activeShield){
          game.lives--;
          logEvent("bad", "Snake bite! -1 life");
          sfxLoseLife();
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) endGame();
          else updateUI();
          victoryHazards.snake = null;
        }
      }
    }
    
    // Update shark
    if (victoryHazards.shark){
      victoryHazards.shark.swim = (victoryHazards.shark.swim + 0.2) % (Math.PI * 2);
      if (!updateVictoryHazards.sharkTimer) updateVictoryHazards.sharkTimer = 0;
      updateVictoryHazards.sharkTimer++;
      if (updateVictoryHazards.sharkTimer >= 30){
        updateVictoryHazards.sharkTimer = 0;
        // Move and check collision (same as normal sharks)
        if (victoryHazards.shark.x === game.playerX && victoryHazards.shark.y === game.playerY &&
            !(game.playerX === game.holeX && game.playerY === game.holeY) && !activeShield){
          game.lives--;
          logEvent("bad", "Shark attack! -1 life");
          sfxLoseLife();
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) endGame();
          else updateUI();
        }
        if (victoryHazards.shark.horizontal){
          victoryHazards.shark.x += victoryHazards.shark.direction;
          if (victoryHazards.shark.x <= 0 || victoryHazards.shark.x >= GRID_W - 1){
            victoryHazards.shark.direction *= -1;
            victoryHazards.shark.x = clamp(victoryHazards.shark.x, 0, GRID_W - 1);
          }
        } else {
          victoryHazards.shark.y += victoryHazards.shark.direction;
          if (victoryHazards.shark.y <= 0 || victoryHazards.shark.y >= GRID_H - 1){
            victoryHazards.shark.direction *= -1;
            victoryHazards.shark.y = clamp(victoryHazards.shark.y, 0, GRID_H - 1);
          }
        }
      }
    }
    
    // Update shadow
    if (victoryHazards.shadow){
      victoryHazards.shadow.pulse = (victoryHazards.shadow.pulse + 0.1) % (Math.PI * 2);
      victoryHazards.shadow.moveTimer--;
      if (victoryHazards.shadow.moveTimer <= 0){
        victoryHazards.shadow.moveTimer = 60;
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        victoryHazards.shadow.x = clamp(victoryHazards.shadow.x + dir.dx, 0, GRID_W - 1);
        victoryHazards.shadow.y = clamp(victoryHazards.shadow.y + dir.dy, 0, GRID_H - 1);
      }
      if (victoryHazards.shadow.x === game.playerX && victoryHazards.shadow.y === game.playerY &&
          !(game.playerX === game.holeX && game.playerY === game.holeY) && !activeShield){
        game.lives--;
        logEvent("bad", "Shadow attack! -1 life");
        sfxLoseLife();
        spawnSparks(game.playerX, game.playerY, 22, true);
        if (game.lives <= 0) endGame();
        else updateUI();
        victoryHazards.shadow = null;
      }
    }
    
    // Animate fires, winds, freezes
    for (let f of victoryHazards.fires) f.intensity = (f.intensity + 0.08) % (Math.PI * 2);
    for (let w of victoryHazards.winds) w.intensity = (w.intensity + 0.12) % (Math.PI * 2);
    for (let z of victoryHazards.freezes) z.shimmer = (z.shimmer + 0.08) % (Math.PI * 2);
  }
  
  function drawVictoryHazards(){
    // Use existing draw functions with victory hazards data
    if (victoryHazards.snake){
      snakes = [victoryHazards.snake];
      drawSnakes();
      snakes = [];
    }
    if (victoryHazards.shark){
      sharks = [victoryHazards.shark];
      drawSharks();
      sharks = [];
    }
    if (victoryHazards.shadow){
      shadowMonsters = [victoryHazards.shadow];
      // Draw with purple eyes for Victory theme
      const temp = shadowMonsters[0];
      const x = temp.x * TILE + TILE / 2;
      const y = temp.y * TILE + TILE / 2;
      const pulse = Math.sin(temp.pulse) * 0.5 + 0.5;
      ctx.save();
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 10);
      gradient.addColorStop(0, 'rgba(100,50,150,0.8)');
      gradient.addColorStop(1, 'rgba(50,20,80,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.fillStyle = '#c27bff';
      ctx.shadowColor = '#c27bff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(x - 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      shadowMonsters = [];
    }
    fireTiles = victoryHazards.fires;
    drawFireTiles();
    fireTiles = [];
    windTiles = victoryHazards.winds;
    drawWindTiles();
    windTiles = [];
    freezeTiles = victoryHazards.freezes;
    drawFreezeTiles();
    freezeTiles = [];
  }
  function playFreezeSound(){
    beep(300, 0.15, "sine", 0.1);
    setTimeout(() => beep(250, 0.15, "sine", 0.1), 150);
    setTimeout(() => beep(200, 0.2, "sine", 0.12), 300);
  }

  // Wind/tornado tiles for Sky Stick theme
  let windTiles = [];
  let windWarningTimer = 0;
  const WIND_WARNING_TIME = 300; // 5 seconds like fire
  // Snakes for Snake Stick theme (chase mechanic!)
  let snakes = [];
  let snakeMoveTimer = 0;
  const SNAKE_MOVE_INTERVAL = 150; // Snakes move every 2.5 seconds
  
  function initSnakes(){
    snakes = [];
    // Spawn 3-5 snakes away from player
    const numSnakes = randInt(3, 5);
    for (let i = 0; i < numSnakes; i++){
      let x, y;
      let attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        const distToPlayer = Math.abs(x - game.playerX) + Math.abs(y - game.playerY);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY) ||
        Math.abs(x - game.playerX) + Math.abs(y - game.playerY) < 5 // Start at least 5 tiles away
      ));
      
      snakes.push({
        x: x,
        y: y,
        slither: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSnakes(){
    // Pause during monster battles
    if (game.pendingMonster) return;
    
    // Animate slither
    for (let snake of snakes){
      snake.slither = (snake.slither + 0.15) % (Math.PI * 2);
    }
    
    // Move snakes toward player periodically
    snakeMoveTimer++;
    if (snakeMoveTimer >= SNAKE_MOVE_INTERVAL){
      snakeMoveTimer = 0;
      
      for (let i = snakes.length - 1; i >= 0; i--){
        const snake = snakes[i];
        
        // Check if snake caught player (NOT in hole!)
        const playerInHole = (game.playerX === game.holeX && game.playerY === game.holeY);
        if (!playerInHole && snake.x === game.playerX && snake.y === game.playerY){
          if (activeShield > 0){
            logEvent("info", "Shield protected you from snake bite!");
            setHud("SHIELD SAVED YOU!");
          } else {
            game.lives--;
            logEvent("bad", "Snake bite! -1 life");
            setHud("SNAKE BITE!");
            sfxLoseLife();
            spawnSparks(game.playerX, game.playerY, 22, true);
            if (game.lives <= 0) endGame();
            else updateUI();
          }
          // Snake disappears after biting
          snakes.splice(i, 1);
          continue;
        }
        
        // Move snake one tile toward player
        const dx = game.playerX - snake.x;
        const dy = game.playerY - snake.y;
        
        // Choose direction (prioritize longer distance)
        if (Math.abs(dx) > Math.abs(dy)){
          // Move horizontally
          if (dx > 0) snake.x++;
          else snake.x--;
        } else if (Math.abs(dy) > 0){
          // Move vertically
          if (dy > 0) snake.y++;
          else snake.y--;
        }
        
        // Clamp to grid
        snake.x = clamp(snake.x, 0, GRID_W - 1);
        snake.y = clamp(snake.y, 0, GRID_H - 1);
        
        // Play hiss sound if snake is close (2-3 tiles)
        const distToPlayer = Math.abs(snake.x - game.playerX) + Math.abs(snake.y - game.playerY);
        if (distToPlayer <= 3){
          playSnakeHissSound();
        }
      }
    }
  }
  
  function drawSnakes(){
    ctx.save();
    for (let snake of snakes){
      const x = snake.x * TILE + TILE / 2;
      const y = snake.y * TILE + TILE / 2;
      
      const slitherOffset = Math.sin(snake.slither) * 2;
      
      // Longer serpentine body (S-curve)
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x - 10, y + slitherOffset);
      ctx.quadraticCurveTo(x - 5, y - slitherOffset * 2, x, y + slitherOffset);
      ctx.quadraticCurveTo(x + 5, y - slitherOffset, x + 10, y + slitherOffset * 1.5);
      ctx.stroke();
      
      // Snake body fill (bright green)
      ctx.strokeStyle = '#39ff95';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x - 10, y + slitherOffset);
      ctx.quadraticCurveTo(x - 5, y - slitherOffset * 2, x, y + slitherOffset);
      ctx.quadraticCurveTo(x + 5, y - slitherOffset, x + 10, y + slitherOffset * 1.5);
      ctx.stroke();
      
      // Snake head (triangle shape)
      ctx.fillStyle = '#39ff95';
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + 10, y + slitherOffset * 1.5 - 3);
      ctx.lineTo(x + 14, y + slitherOffset * 1.5);
      ctx.lineTo(x + 10, y + slitherOffset * 1.5 + 3);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Eyes (tiny red dots)
      ctx.fillStyle = '#ff1f3a';
      ctx.beginPath();
      ctx.arc(x + 11, y + slitherOffset * 1.5 - 1, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 11, y + slitherOffset * 1.5 + 1, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Forked tongue (flicks in and out)
      if (Math.sin(snake.slither * 2) > 0.5){
        ctx.strokeStyle = '#ff5a6a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + 14, y + slitherOffset * 1.5);
        ctx.lineTo(x + 16, y + slitherOffset * 1.5 - 1.5);
        ctx.moveTo(x + 14, y + slitherOffset * 1.5);
        ctx.lineTo(x + 16, y + slitherOffset * 1.5 + 1.5);
        ctx.stroke();
      }
    }
    ctx.restore();
  }
  
  // Snake hiss sound

  // Shadow monsters for Glow Stick (hide in darkness!)
  let shadowMonsters = [];
  


  // Shadow clones for Victory Stick (final boss!)
  let shadowClones = [];
  let cloneMoveTimer = 0;
  const CLONE_MOVE_INTERVAL = 120; // Clones move every 2 seconds
  
  function initShadowClones(){
    shadowClones = [];
    // Spawn 2-3 dark clones of the player
    const numClones = randInt(2, 3);
    for (let i = 0; i < numClones; i++){
      let x, y;
      let attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY) ||
        Math.abs(x - game.playerX) + Math.abs(y - game.playerY) < 6
      ));
      
      shadowClones.push({
        x: x,
        y: y,
        glitch: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateShadowClones(){
    // Pause during monster battles
    if (game.pendingMonster) return;
    
    for (let clone of shadowClones){
      clone.glitch = (clone.glitch + 0.12) % (Math.PI * 2);
    }
    
    // Move clones toward player
    cloneMoveTimer++;
    if (cloneMoveTimer >= CLONE_MOVE_INTERVAL){
      cloneMoveTimer = 0;
      
      for (let i = shadowClones.length - 1; i >= 0; i--){
        const clone = shadowClones[i];
        
        // Check if clone caught player (NOT in hole!)
        const playerInHole = (game.playerX === game.holeX && game.playerY === game.holeY);
        if (!playerInHole && clone.x === game.playerX && clone.y === game.playerY){
          if (activeShield > 0){
            logEvent("info", "Shield protected you from shadow clone!");
            setHud("SHIELD SAVED YOU!");
          } else {
            game.lives--;
            logEvent("bad", "Shadow clone caught you! -1 life");
            setHud("SHADOW CLONE!");
            playShadowMonsterSound();
            sfxLoseLife();
            spawnSparks(game.playerX, game.playerY, 22, true);
            if (game.lives <= 0) endGame();
            else updateUI();
          }
          shadowClones.splice(i, 1);
          continue;
        }
        
        // Move clone toward player
        const dx = game.playerX - clone.x;
        const dy = game.playerY - clone.y;
        
        if (Math.abs(dx) > Math.abs(dy)){
          if (dx > 0) clone.x++;
          else clone.x--;
        } else if (Math.abs(dy) > 0){
          if (dy > 0) clone.y++;
          else clone.y--;
        }
        
        clone.x = clamp(clone.x, 0, GRID_W - 1);
        clone.y = clamp(clone.y, 0, GRID_H - 1);
      }
    }
  }
  
  function drawShadowClones(){
    ctx.save();
    for (let clone of shadowClones){
      const x = clone.x * TILE + TILE / 2;
      const y = clone.y * TILE + TILE / 2;
      
      const glitch = Math.sin(clone.glitch) * 0.5 + 0.5;
      
      ctx.save();
      ctx.translate(x, y);
      
      // Dark distorted player shape
      ctx.globalAlpha = 0.7 + glitch * 0.2;
      ctx.strokeStyle = '#7a35ff';
      ctx.shadowColor = '#7a35ff';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      
      // Head (glitchy circle)
      ctx.beginPath();
      ctx.arc(0, -10 + glitch * 2, 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // Body
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(glitch * 2, 4);
      ctx.stroke();
      
      // Glowing eyes
      ctx.fillStyle = '#c27bff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(-2, -11, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2, -11, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  function updateShadowMonsters(){
    for (let i = shadowMonsters.length - 1; i >= 0; i--){
      const monster = shadowMonsters[i];
      monster.pulse = (monster.pulse + 0.1) % (Math.PI * 2);
      
      // Decrease lifetime
      if (monster.lifetime !== undefined){
        monster.lifetime--;
        if (monster.lifetime <= 0){
          shadowMonsters.splice(i, 1);
          continue;
        }
      }
      
      // Check if player stepped on shadow monster (NOT in hole!)
      const playerInHole = (game.playerX === game.holeX && game.playerY === game.holeY);
      if (!playerInHole && monster.x === game.playerX && monster.y === game.playerY){
        if (activeShield > 0){
          logEvent("info", "Shield protected you from shadow monster!");
          setHud("SHIELD SAVED YOU!");
        } else {
          game.lives--;
          logEvent("bad", "Shadow monster attacked! -1 life");
          setHud("SHADOW ATTACK!");
          playShadowMonsterSound();
          sfxLoseLife();
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) endGame();
          else updateUI();
        }
        shadowMonsters.splice(i, 1);
      }
    }
  }
  
  function drawShadowMonsters(){
    if (shadowMonsters.length === 0) return;
    
    ctx.save();
    for (let monster of shadowMonsters){
      const x = monster.x * TILE + TILE / 2;
      const y = monster.y * TILE + TILE / 2;
      
      const pulse = Math.sin(monster.pulse) * 0.5 + 0.5;
      
      // Shadow form (dark ghostly shape)
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 10);
      gradient.addColorStop(0, 'rgba(80,50,20,0.9)');
      gradient.addColorStop(1, 'rgba(40,25,10,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
      
      // Glowing ORANGE eyes (match Glow theme)
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.fillStyle = '#ff7a18';
      ctx.shadowColor = '#ff7a18';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(x - 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  
  // Sharks for Sea Stick (patrol mechanic!)
  let sharks = [];
  let sharkMoveTimer = 0;
  const SHARK_MOVE_INTERVAL = 30; // Sharks move every 0.5 seconds (fast!)
  
  function initSharks(){
    sharks = [];
    // Spawn 2-3 sharks with patrol routes
    const numSharks = randInt(2, 3);
    for (let i = 0; i < numSharks; i++){
      const horizontal = Math.random() > 0.5;
      let x, y, direction;
      
      if (horizontal){
        // Horizontal patrol
        x = randInt(0, GRID_W - 1);
        y = randInt(2, GRID_H - 3); // Not too close to edges
        direction = Math.random() > 0.5 ? 1 : -1;
      } else {
        // Vertical patrol
        x = randInt(2, GRID_W - 3);
        y = randInt(0, GRID_H - 1);
        direction = Math.random() > 0.5 ? 1 : -1;
      }
      
      sharks.push({
        x: x,
        y: y,
        horizontal: horizontal,
        direction: direction,
        swim: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSharks(){
    // Animate swimming
    for (let shark of sharks){
      shark.swim = (shark.swim + 0.2) % (Math.PI * 2);
    }
    
    // Move sharks along patrol routes
    sharkMoveTimer++;
    if (sharkMoveTimer >= SHARK_MOVE_INTERVAL){
      sharkMoveTimer = 0;
      
      for (let shark of sharks){
        // Check if shark chomps player BEFORE moving (NOT in hole!)
        const playerInHole = (game.playerX === game.holeX && game.playerY === game.holeY);
        if (!playerInHole && shark.x === game.playerX && shark.y === game.playerY){
          if (activeShield > 0){
            logEvent("info", "Shield protected you from shark!");
            setHud("SHIELD SAVED YOU!");
          } else {
            game.lives--;
            logEvent("bad", "Shark attack! -1 life");
            setHud("CHOMPED!");
            playSharkChompSound();
            sfxLoseLife();
            spawnSparks(game.playerX, game.playerY, 22, true);
            if (game.lives <= 0) endGame();
            else updateUI();
          }
        }
        
        // Move shark
        if (shark.horizontal){
          shark.x += shark.direction;
          // Bounce at edges
          if (shark.x <= 0 || shark.x >= GRID_W - 1){
            shark.direction *= -1;
            shark.x = clamp(shark.x, 0, GRID_W - 1);
          }
        } else {
          shark.y += shark.direction;
          // Bounce at edges
          if (shark.y <= 0 || shark.y >= GRID_H - 1){
            shark.direction *= -1;
            shark.y = clamp(shark.y, 0, GRID_H - 1);
          }
        }
      }
    }
  }
  
  function drawSharks(){
    ctx.save();
    for (let shark of sharks){
      const x = shark.x * TILE + TILE / 2;
      const y = shark.y * TILE + TILE / 2;
      
      const swimOffset = Math.sin(shark.swim) * 2;
      const facingRight = (shark.horizontal && shark.direction > 0) || (!shark.horizontal && shark.direction > 0);
      
      ctx.save();
      ctx.translate(x, y);
      if (!facingRight) ctx.scale(-1, 1);
      
      // Shark body (gray)
      ctx.fillStyle = '#5a6c7d';
      ctx.strokeStyle = '#2a3c4d';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, swimOffset, 8, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Shark fin (triangle)
      ctx.fillStyle = '#4a5c6d';
      ctx.beginPath();
      ctx.moveTo(0, swimOffset - 5);
      ctx.lineTo(-3, swimOffset - 8);
      ctx.lineTo(3, swimOffset - 8);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Shark tail
      ctx.fillStyle = '#5a6c7d';
      ctx.beginPath();
      ctx.moveTo(-8, swimOffset);
      ctx.lineTo(-11, swimOffset - 3);
      ctx.lineTo(-11, swimOffset + 3);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Eye (beady)
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(5, swimOffset - 1, 1, 0, Math.PI * 2);
      ctx.fill();
      
      // Teeth (sharp!)
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(6, swimOffset + 1);
      ctx.lineTo(7, swimOffset + 3);
      ctx.moveTo(8, swimOffset + 1);
      ctx.lineTo(9, swimOffset + 3);
      ctx.stroke();
      
      ctx.restore();
      
      // Water trail (shows patrol path)
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = '#00d9ff';
      if (shark.horizontal){
        ctx.fillRect(0, shark.y * TILE, CANVAS_W, TILE);
      } else {
        ctx.fillRect(shark.x * TILE, 0, TILE, CANVAS_H);
      }
      ctx.globalAlpha = 1;
    }
    ctx.restore();
  }
  function playSnakeHissSound(){
    // Only play if not recently played (debounce)
    if (!playSnakeHissSound.lastPlayed || Date.now() - playSnakeHissSound.lastPlayed > 2000){
      playSnakeHissSound.lastPlayed = Date.now();
      // Hissing sound (white noise-ish)
      beep(150, 0.08, "sawtooth", 0.04);
      setTimeout(() => beep(140, 0.08, "sawtooth", 0.04), 80);
      setTimeout(() => beep(130, 0.08, "sawtooth", 0.04), 160);
    }
  }


  

  
  function initWindTiles(){
    windTiles = [];
    // Create 6-10 random wind/tornado tiles
    const numWinds = randInt(6, 10);
    for (let i = 0; i < numWinds; i++){
      const x = randInt(0, GRID_W - 1);
      const y = randInt(0, GRID_H - 1);
      windTiles.push({
        x, y,
        intensity: Math.random() * Math.PI * 2
      });
    }
  }
  function initFireTiles(){
    fireTiles = [];
    // Create 8-12 random fire tiles
    const numFires = randInt(8, 12);
    for (let i = 0; i < numFires; i++){
      const x = randInt(0, GRID_W - 1);
      const y = randInt(0, GRID_H - 1);
      fireTiles.push({
        x, y,
        intensity: Math.random() // for animation
      });
    }
  }
  
  function updateFireTiles(){
    // Animate fire intensity
    for (let fire of fireTiles){
      fire.intensity = (fire.intensity + 0.08) % (Math.PI * 2);
    }
    
    // Check if player is on fire tile
    const onFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFire){
      fireWarningTimer++;
      if (fireWarningTimer >= FIRE_WARNING_TIME){
        // Player stayed too long - lose a life!
        // HOLE IS SACRED - no damage if on hole
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          fireWarningTimer = 0;
        } else if (activeShield > 0){
          fireWarningTimer = 0;
          logEvent("info", "Shield protected you from fire!");
          setHud("SHIELD SAVED YOU!");
        } else {
          game.lives--;
          game.holeLostLife = true;
          fireWarningTimer = 0;
          logEvent("bad", "Burned by fire! -1 life");
          sfxLoseLife();
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) endGame();
          else updateUI();
        }
      } else if (fireWarningTimer === 60){
        // Warning sound and message
        playFireWarningSound();
        logEvent("warn", "Fire burning! Move or lose a life!");
        setHud("BURNING!");
      } else if (fireWarningTimer === 150 || fireWarningTimer === 240){
        // Additional warnings as time runs out
        playFireWarningSound();
      }
    } else {
      fireWarningTimer = 0;
    }
  }
  

  
  function drawWindTiles(){
    ctx.save();
    for (let wind of windTiles){
      const x = wind.x * TILE + TILE / 2;
      const y = wind.y * TILE + TILE / 2;
      
      // Animated tornado/wind effect
      const spin = wind.intensity;
      const pulse = Math.sin(spin * 2) * 0.3 + 0.7;
      
      // Swirling wind base
      const windGrad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      windGrad.addColorStop(0, 'rgba(200,220,255,' + (0.3 * pulse) + ')');
      windGrad.addColorStop(0.5, 'rgba(150,180,220,' + (0.2 * pulse) + ')');
      windGrad.addColorStop(1, 'rgba(100,140,200,0)');
      ctx.fillStyle = windGrad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Swirling lines (tornado effect)
      ctx.strokeStyle = 'rgba(180,200,240,' + (0.5 * pulse) + ')';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++){
        const offset = (spin + i * Math.PI * 0.66) % (Math.PI * 2);
        const radius = 4 + i * 2;
        ctx.beginPath();
        ctx.arc(x, y, radius, offset, offset + Math.PI * 0.8);
        ctx.stroke();
      }
      
      // Center swirl
      ctx.fillStyle = 'rgba(220,230,255,' + (0.6 * pulse) + ')';
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw warning indicator if player is on wind
    if (windWarningTimer > 0){
      const playerOnWind = windTiles.some(w => w.x === game.playerX && w.y === game.playerY);
      if (playerOnWind){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(windWarningTimer * 0.3) * 0.5 + 0.5;
        
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#3aa7ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }
  function drawFireTiles(){
    ctx.save();
    for (let fire of fireTiles){
      const x = fire.x * TILE + TILE / 2;
      const y = fire.y * TILE + TILE / 2;
      
      // Multiple flame flickers for realistic effect
      const flicker1 = Math.sin(fire.intensity) * 0.4 + 0.6;
      const flicker2 = Math.sin(fire.intensity * 1.7 + 1) * 0.3 + 0.7;
      const flicker3 = Math.sin(fire.intensity * 2.3 + 2) * 0.35 + 0.65;
      
      // Large base glow
      const glowGrad = ctx.createRadialGradient(x, y + 2, 0, x, y + 2, TILE / 2 + 6);
      glowGrad.addColorStop(0, 'rgba(255,180,0,' + (0.6 * flicker1) + ')');
      glowGrad.addColorStop(0.4, 'rgba(255,100,20,' + (0.4 * flicker2) + ')');
      glowGrad.addColorStop(1, 'rgba(255,31,58,0)');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(x, y + 2, TILE / 2 + 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main flame body (tall, dancing shape)
      const flameHeight = 10 + flicker1 * 4;
      const flameGrad = ctx.createLinearGradient(x, y + 4, x, y - flameHeight);
      flameGrad.addColorStop(0, 'rgba(255,100,0,' + (0.9 * flicker2) + ')');
      flameGrad.addColorStop(0.3, 'rgba(255,150,0,' + (0.85 * flicker1) + ')');
      flameGrad.addColorStop(0.6, 'rgba(255,200,50,' + (0.7 * flicker3) + ')');
      flameGrad.addColorStop(1, 'rgba(255,220,100,0)');
      
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.moveTo(x - 6 * flicker1, y + 4);
      ctx.bezierCurveTo(x - 5, y, x - 3 * flicker2, y - flameHeight * 0.7, x - 2, y - flameHeight);
      ctx.bezierCurveTo(x - 1, y - flameHeight - 2, x + 1, y - flameHeight - 2, x + 2, y - flameHeight);
      ctx.bezierCurveTo(x + 3 * flicker3, y - flameHeight * 0.7, x + 5, y, x + 6 * flicker1, y + 4);
      ctx.closePath();
      ctx.fill();
      
      // Hot white core
      ctx.fillStyle = 'rgba(255,255,200,' + (0.8 * flicker2) + ')';
      ctx.beginPath();
      ctx.ellipse(x, y, 3 * flicker1, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Flickering tips
      const tipFlicker = Math.sin(fire.intensity * 3) * 0.5 + 0.5;
      ctx.fillStyle = 'rgba(255,200,50,' + (0.6 * tipFlicker) + ')';
      ctx.beginPath();
      ctx.arc(x - 2 * flicker2, y - flameHeight * 0.8, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 2 * flicker3, y - flameHeight * 0.9, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw warning indicator if player is on fire
    if (fireWarningTimer > 0){
      const playerOnFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFire){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(fireWarningTimer * 0.3) * 0.5 + 0.5;
        
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#ff1f3a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }


  // Special power-up sticks
  let activeSpeedBoost = 0; // Remaining free moves
  let activeShield = 0; // Remaining shield time in frames (300 = 5 seconds)
  let visionRevealed = false; // Whether vision stick revealed the secret
  let visionTimer = 0; // How long vision effect lasts
  
  function pickupSpecialStick(type){
    if (type === "speed"){
      activeSpeedBoost = 10;
      logEvent("bonus", "SPEED STICK! Next 10 moves are free!");
      setHud("SPEED BOOST!");
      playSpeedStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "shield"){
      activeShield = 300; // 5 seconds
      logEvent("bonus", "SHIELD STICK! Temporary immunity to hazards!");
      setHud("SHIELD ACTIVE!");
      playShieldStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "vision"){
      visionRevealed = true;
      visionTimer = 240; // 4 seconds
      logEvent("bonus", "VISION STICK! Secret square revealed!");
      setHud("VISION ACTIVATED!");
      playVisionStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    }
  }
  
  function updateSpecialEffects(){
    if (activeShield > 0) activeShield--;
    if (visionTimer > 0){
      visionTimer--;
      if (visionTimer <= 0) visionRevealed = false;
    }
  }
  
  function drawSpecialEffects(){
    // Draw shield indicator around player
    if (activeShield > 0){
      const px = game.playerX * TILE + TILE / 2;
      const py = game.playerY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
      
      ctx.save();
      ctx.strokeStyle = '#3aa7ff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      ctx.shadowColor = '#3aa7ff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(px, py, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw vision effect - pulsing glow on secret square
    if (visionRevealed && !game.lifeTileUsed){
      const sx = game.lifeTileX * TILE + TILE / 2;
      const sy = game.lifeTileY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 150) * 0.5 + 0.5;
      
      ctx.save();
      ctx.globalAlpha = 0.3 + pulse * 0.4;
      const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, TILE);
      gradient.addColorStop(0, 'rgba(255,212,0,0.8)');
      gradient.addColorStop(1, 'rgba(255,212,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(game.lifeTileX * TILE, game.lifeTileY * TILE, TILE, TILE);
      ctx.restore();
    }
  }


  // Level-specific hazards
  let windGustTimer = 0;
  let darkTiles = [];
  let darkTileTimer = 0;
  let teleportTiles = [];
  
  function initLevelHazards(){
    windGustTimer = 0;
    darkTiles = [];
    darkTileTimer = 0;
    teleportTiles = [];
    
    const theme = currentLevelTheme().name;
    
    // Sky Stick: No setup needed, wind happens randomly
    
    // Glow Stick: Create tiles that can go dark
    if (theme === "Glow Stick"){
      darkTileTimer = randInt(180, 420); // 3-7 seconds until first dark
    }
    
    // Spell Stick: Create 5-8 teleport tiles (avoid sticks and player)
    if (theme === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      for (let i = 0; i < numTeleports; i++){
        let x, y;
        let attempts = 0;
        do {
          x = randInt(0, GRID_W - 1);
          y = randInt(0, GRID_H - 1);
          attempts++;
        } while (attempts < 50 && (
          (x === game.playerX && y === game.playerY) ||
          (x === game.holeX && y === game.holeY) ||
          game.sticks.some(s => s.x === x && s.y === y)
        ));
        
        teleportTiles.push({
          x: x,
          y: y,
          glow: Math.random() * Math.PI * 2
        });
      }
    }
  }
  
  function updateLevelHazards(){
    const theme = currentLevelTheme().name;
    
    // Sky Stick: Random wind gusts
    if (theme === "Sky Stick"){
      windGustTimer++;
      if (windGustTimer >= randInt(180, 360)){ // Every 3-6 seconds
        windGustTimer = 0;
        if (!game.inputLocked && game.actions > 0){
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          const newX = clamp(game.playerX + dir.dx, 0, GRID_W - 1);
          const newY = clamp(game.playerY + dir.dy, 0, GRID_H - 1);
          
          // Don't push into hole
          if (newX !== game.holeX || newY !== game.holeY){
            game.playerX = newX;
            game.playerY = newY;
        
            logEvent("info", "Wind gust pushed you!");
            setHud("WIND GUST!");
            spawnSparks(game.playerX, game.playerY, 12, false);
          }
        }
      }
    }
    
    // Glow Stick: Shadow monsters spawn randomly (no dark tiles)
    if (theme === "Glow Stick"){
      darkTileTimer--;
      if (darkTileTimer <= 0){
        // Spawn 2-3 shadow monsters at random locations
        const numMonsters = randInt(2, 3);
        for (let i = 0; i < numMonsters; i++){
          let x, y;
          let attempts = 0;
          do {
            x = randInt(0, GRID_W - 1);
            y = randInt(0, GRID_H - 1);
            attempts++;
          } while (attempts < 50 && (
            (x === game.playerX && y === game.playerY) ||
            (x === game.holeX && y === game.holeY) ||
            shadowMonsters.some(s => s.x === x && s.y === y)
          ));
          
          shadowMonsters.push({
            x: x,
            y: y,
            pulse: Math.random() * Math.PI * 2,
            lifetime: 300 // 5 seconds
          });
        }
        logEvent("info", "Shadow monsters appear!");
        darkTileTimer = randInt(240, 480); // 4-8 seconds until next spawn
      }
    }
    
    // Spell Stick: Animate teleport tiles
    if (theme === "Spell Stick"){
      for (let tile of teleportTiles){
        tile.glow = (tile.glow + 0.08) % (Math.PI * 2);
      }
      
      // Check if player stepped on teleport
      const onTeleport = teleportTiles.find(t => t.x === game.playerX && t.y === game.playerY);
      if (onTeleport && game.actions > 0){
        // Teleport to random location
        let newX, newY;
        do {
          newX = randInt(0, GRID_W - 1);
          newY = randInt(0, GRID_H - 1);
        } while ((newX === game.holeX && newY === game.holeY) || 
                 (newX === game.playerX && newY === game.playerY));
        
        spawnSparks(game.playerX, game.playerY, 18, false);
        game.playerX = newX;
        game.playerY = newY;
        
        spawnSparks(game.playerX, game.playerY, 18, false);
        logEvent("info", "Teleported by magic tile!");
        setHud("TELEPORT!");
        sfxBonus();
      }
    }
  }
  
  function drawLevelHazards(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    // Draw dark tiles for Glow Stick
    if (theme === "Glow Stick" && darkTiles.length > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      for (let tile of darkTiles){
        ctx.fillRect(tile.x * TILE, tile.y * TILE, TILE, TILE);
      }
    }
    
    // Draw teleport tiles for Spell Stick
    if (theme === "Spell Stick" && teleportTiles.length > 0){
      for (let tile of teleportTiles){
        const x = tile.x * TILE + TILE / 2;
        const y = tile.y * TILE + TILE / 2;
        const pulse = Math.sin(tile.glow) * 0.5 + 0.5;
        
        // Teleport glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
        gradient.addColorStop(0, 'rgba(255,105,255,' + (0.4 + pulse * 0.3) + ')');
        gradient.addColorStop(1, 'rgba(255,105,255,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Teleport symbol (spiral)
        ctx.strokeStyle = 'rgba(255,105,255,' + (0.6 + pulse * 0.4) + ')';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < Math.PI * 4; i += 0.3){
          const r = (i / (Math.PI * 4)) * 6;
          const px = x + Math.cos(i + tile.glow) * r;
          const py = y + Math.sin(i + tile.glow) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }
    
    ctx.restore();
  }


  // Theme-specific ambient particles
  let ambientParticles = [];
  
  function initAmbientParticles(){
    ambientParticles = [];
    const theme = currentLevelTheme().name;
    
    // Sun Stick: Light rays
    if (theme === "Sun Stick"){
      for (let i = 0; i < 5; i++){
        ambientParticles.push({
          type: 'sunray',
          x: randInt(0, CANVAS_W),
          y: -20,
          angle: Math.random() * 0.4 - 0.2,
          speed: 0.3 + Math.random() * 0.3,
          opacity: Math.random() * 0.3 + 0.1
        });
      }
    }
    
    // Leaf Stick: Grass/leaf particles
    if (theme === "Leaf Stick"){
      for (let i = 0; i < 20; i++){
        ambientParticles.push({
          type: 'leaf',
          x: Math.random() * CANVAS_W,
          y: Math.random() * CANVAS_H,
          vx: (Math.random() - 0.5) * 0.4,
          vy: 0.2 + Math.random() * 0.3,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 0.05
        });
      }
    }
    
    // Sea Stick: Bubbles rising
    if (theme === "Sea Stick"){
      for (let i = 0; i < 30; i++){
        ambientParticles.push({
          type: 'bubble',
          x: Math.random() * CANVAS_W,
          y: Math.random() * CANVAS_H + CANVAS_H, // Start below screen
          size: 1 + Math.random() * 3,
          speed: 0.3 + Math.random() * 0.5,
          wobble: Math.random() * Math.PI * 2,
          wobbleSpeed: 0.05 + Math.random() * 0.05
        });
      }
    }
    
    // Victory Stick: Stars/sparkles
    if (theme === "Victory Stick"){
      for (let i = 0; i < 25; i++){
        ambientParticles.push({
          type: 'star',
          x: Math.random() * CANVAS_W,
          y: Math.random() * CANVAS_H,
          size: 1 + Math.random() * 2,
          twinkle: Math.random() * Math.PI * 2,
          twinkleSpeed: 0.05 + Math.random() * 0.05
        });
      }
    }
  }
  
  function updateAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        p.y += p.speed;
        if (p.y > CANVAS_H + 50){
          p.y = -50;
          p.x = randInt(0, CANVAS_W);
        }
      } else if (p.type === 'leaf'){
        p.x += p.vx;
        p.y += p.vy;
        p.rotation += p.rotSpeed;
        if (p.y > CANVAS_H){
          p.y = -10;
          p.x = Math.random() * CANVAS_W;
        }
        if (p.x < 0) p.x = CANVAS_W;
        if (p.x > CANVAS_W) p.x = 0;
      } else if (p.type === 'bubble'){
        p.y -= p.speed;
        p.wobble += p.wobbleSpeed;
        p.x += Math.sin(p.wobble) * 0.5;
        if (p.y < -10){
          p.y = CANVAS_H + 10;
          p.x = Math.random() * CANVAS_W;
        }
      } else if (p.type === 'bubble'){
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#00d9ff';
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Bubble highlight
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath();
        ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
      } else if (p.type === 'star'){
        p.twinkle += p.twinkleSpeed;
      }
    }
  }
  
  function drawAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.globalAlpha = p.opacity * 0.3;
        
        // Wide beam shape (not stick-like)
        const gradient = ctx.createLinearGradient(0, 0, 0, 60);
        gradient.addColorStop(0, 'rgba(255,212,0,0.6)');
        gradient.addColorStop(1, 'rgba(255,212,0,0)');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.lineTo(-4, 60);
        ctx.lineTo(4, 60);
        ctx.lineTo(8, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      } else if (p.type === 'leaf'){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = 'rgba(57,255,149,0.4)';
        ctx.beginPath();
        ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else if (p.type === 'bubble'){
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#00d9ff';
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Bubble highlight
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath();
        ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
      } else if (p.type === 'star'){
        const twinkle = Math.sin(p.twinkle) * 0.5 + 0.5;
        ctx.globalAlpha = 0.3 + twinkle * 0.5;
        ctx.fillStyle = '#c27bff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Star points
        if (twinkle > 0.5){
          ctx.strokeStyle = '#c27bff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(p.x - p.size * 2, p.y);
          ctx.lineTo(p.x + p.size * 2, p.y);
          ctx.moveTo(p.x, p.y - p.size * 2);
          ctx.lineTo(p.x, p.y + p.size * 2);
          ctx.stroke();
        }
      }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  // Ice frost effect on screen edges
  function drawIceFrost(){
    if (currentLevelTheme().name !== "Ice Stick") return;
    
    ctx.save();
    
    // Top frost
    const topGrad = ctx.createLinearGradient(0, 0, 0, 40);
    topGrad.addColorStop(0, 'rgba(200,230,255,0.2)');
    topGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = topGrad;
    ctx.fillRect(0, 0, CANVAS_W, 40);
    
    // Bottom frost
    const botGrad = ctx.createLinearGradient(0, CANVAS_H - 40, 0, CANVAS_H);
    botGrad.addColorStop(0, 'rgba(200,230,255,0)');
    botGrad.addColorStop(1, 'rgba(200,230,255,0.2)');
    ctx.fillStyle = botGrad;
    ctx.fillRect(0, CANVAS_H - 40, CANVAS_W, 40);
    
    // Left frost
    const leftGrad = ctx.createLinearGradient(0, 0, 40, 0);
    leftGrad.addColorStop(0, 'rgba(200,230,255,0.15)');
    leftGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = leftGrad;
    ctx.fillRect(0, 0, 40, CANVAS_H);
    
    // Right frost
    const rightGrad = ctx.createLinearGradient(CANVAS_W - 40, 0, CANVAS_W, 0);
    rightGrad.addColorStop(0, 'rgba(200,230,255,0)');
    rightGrad.addColorStop(1, 'rgba(200,230,255,0.15)');
    ctx.fillStyle = rightGrad;
    ctx.fillRect(CANVAS_W - 40, 0, 40, CANVAS_H);
    
    ctx.restore();
  }



  



  // Draw a custom stick monster instead of emoji
  function drawStickMonster(x, y, anger){
    ctx.save();
    ctx.translate(x, y);
    
    // Monster is made of evil sticks!
    const shake = Math.sin(Date.now() / 100) * (anger * 2);
    
    // Body - jagged sticks forming a scary shape
    ctx.strokeStyle = '#ff1f3a';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.shadowColor = '#ff1f3a';
    ctx.shadowBlur = 8;
    
    // Main body sticks (X shape)
    ctx.beginPath();
    ctx.moveTo(-12 + shake, -12);
    ctx.lineTo(12 - shake, 12);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(12 - shake, -12);
    ctx.lineTo(-12 + shake, 12);
    ctx.stroke();
    
    // Extra angry sticks pointing out
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-15, 0);
    ctx.lineTo(-22 + shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(22 - shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(3, -22 - shake);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 15);
    ctx.lineTo(-3, 22 + shake);
    ctx.stroke();
    
    // Glowing evil eyes
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff5a6a';
    ctx.beginPath();
    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Evil eye pupils
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#1a0005';
    ctx.beginPath();
    ctx.arc(-5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Angry mouth (jagged)
    ctx.strokeStyle = '#ff5a6a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-6, 4);
    ctx.lineTo(-3, 7);
    ctx.lineTo(0, 4);
    ctx.lineTo(3, 7);
    ctx.lineTo(6, 4);
    ctx.stroke();
    
    ctx.restore();
  }

  // Hole fading for higher levels (7+)
  let holeFadeTimer = 0;
  let holeFadeInterval = 200;
  let holeVisible = true;

  const LOG_MAX_LINES = 12;

  /* ---- Max life bonus points (when a life reward is blocked) ---- */
  const MAX_LIVES = 5;
  const LIFE_TILE_MAX_POINTS = 12;
  const TREE_FEED_MAX_POINTS = 8;

  /* ---- Music ---- */
  const MUSIC_STEP_MS = 245;
  let musicOn = false;
  let musicTimer = null;
  let musicStep = 0;

  let celebrationUntil = 0;
  let celebrationStep = 0;

  let doomUntil = 0;
  let doomStep = 0;

  const MUSIC_A = [
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.040 },
    { lead:330, bass:98, dur:0.16, gain:0.038 },
    { lead:294, bass:98, dur:0.16, gain:0.038 },
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:392, bass:110, dur:0.16, gain:0.038 },
    { lead:330, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_B = [
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:494, bass:110, dur:0.16, gain:0.038 },
    { lead:523, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:294, bass:98, dur:0.16, gain:0.036 },
    { chord:[247,311,370], bass:92, dur:0.18, gain:0.040 },
    { lead:370, bass:92, dur:0.16, gain:0.038 },
    { lead:330, bass:92, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_CELEB = [
    { chord:[523,659,784], bass:131, dur:0.18, gain:0.052 },
    { lead:784, bass:131, dur:0.14, gain:0.050 },
    { lead:988, bass:131, dur:0.14, gain:0.050 },
    { chord:[659,784,988], bass:147, dur:0.18, gain:0.052 },
    { lead:1175, bass:147, dur:0.14, gain:0.050 },
    { lead:988, bass:147, dur:0.14, gain:0.048 },
    { chord:[587,740,880], bass:110, dur:0.18, gain:0.050 },
    { lead:880, bass:110, dur:0.14, gain:0.048 },
    { lead:988, bass:110, dur:0.14, gain:0.048 },
    { chord:[659,784,988], bass:131, dur:0.18, gain:0.052 },
    { lead:0 }
  ];

  const MUSIC_DOOM = [
    { lead:988, dur:0.14, gain:0.080, type:"square" },
    { lead:932, dur:0.14, gain:0.080, type:"square" },
    { lead:880, dur:0.14, gain:0.080, type:"square" },
    { lead:784, dur:0.16, gain:0.082, type:"square" },
    { lead:698, dur:0.18, gain:0.082, type:"square" },
    { lead:622, dur:0.20, gain:0.082, type:"square" },
    { lead:554, dur:0.22, gain:0.082, type:"square" },
    { lead:466, dur:0.24, gain:0.082, type:"square" },
    { lead:392, dur:0.28, gain:0.082, type:"square" },
    { lead:0 }
  ];

  function startCelebrationMusic(ms=6500){
    if (!musicOn) return;
    celebrationUntil = Date.now() + ms;
    celebrationStep = 0;
  }
  function startDoomMusic(ms=6500){
    if (!musicOn) return;
    doomUntil = Date.now() + ms;
    doomStep = 0;
  }

  function pickMusicStep(stepIdx){
    const block = Math.floor(stepIdx / 32);
    const useB = (block % 2 === 1);
    const seq = useB ? MUSIC_B : MUSIC_A;
    const s = seq[stepIdx % seq.length];
    if (s && s.lead && Math.random() < 0.10){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickCelebrationStep(){
    const s = MUSIC_CELEB[celebrationStep++ % MUSIC_CELEB.length];
    if (s && s.lead && Math.random() < 0.18){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickDoomStep(){
    const s = MUSIC_DOOM[doomStep++ % MUSIC_DOOM.length];
    return s;
  }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const ui = {
    log: document.getElementById("log"),
    battleLog: document.getElementById("battleLog"),
    themeMini: document.getElementById("uiThemeMini"),
    controlsScroll: document.getElementById("controlsScroll"),
    scrollHint: document.getElementById("scrollHint"),

    player: document.getElementById("uiPlayer"),
    skin: document.getElementById("uiSkin"),

    lives: document.getElementById("uiLives"),
    level: document.getElementById("uiLevel"),
    score: document.getElementById("uiScore"),
    actions: document.getElementById("uiActions"),
    mode: document.getElementById("uiMode"),
    die: document.getElementById("uiDie"),
    carry: document.getElementById("uiCarry"),
    left: document.getElementById("uiLeft"),

    diceBox: document.getElementById("diceBox"),
    diceFace: document.getElementById("diceFace"),
    diceLabel: document.getElementById("diceLabel"),

    btnRoll: document.getElementById("btnRoll"),
    btnUse: document.getElementById("btnUse"),
    btnNew: document.getElementById("btnNew"),
    btnPause: document.getElementById("btnPause"),
    btnMusic: document.getElementById("btnMusic"),

    btnUp: document.getElementById("btnUp"),
    btnDown: document.getElementById("btnDown"),
    btnLeft: document.getElementById("btnLeft"),
    btnRight: document.getElementById("btnRight"),

    btnSave: document.getElementById("btnSave"),
    btnLoad: document.getElementById("btnLoad"),

    infoOverlay: document.getElementById("infoOverlay"),
    btnInfo: document.getElementById("btnInfo"),
    btnInfoClose: document.getElementById("btnInfoClose"),

    nameOverlay: document.getElementById("nameOverlay"),
    nameInput: document.getElementById("nameInput"),
    nameStartBtn: document.getElementById("nameStartBtn"),
    nameUseSavedBtn: document.getElementById("nameUseSavedBtn"),
    nameUseP1Btn: document.getElementById("nameUseP1Btn"),
    savedNameHint: document.getElementById("savedNameHint"),

    pauseOverlay: document.getElementById("pauseOverlay"),
    btnPauseClose: document.getElementById("btnPauseClose"),

    gameOverOverlay: document.getElementById("gameOverOverlay"),
    gameOverText: document.getElementById("gameOverText"),
    btnRestart: document.getElementById("btnRestart"),
    btnGameOverClose: document.getElementById("btnGameOverClose"),

    winOverlay: document.getElementById("winOverlay"),
    winText: document.getElementById("winText"),
    btnWinRestart: document.getElementById("btnWinRestart"),

    leaderboard: document.getElementById("leaderboard"),

    monsterEvent: document.getElementById("monsterEvent"),
    monsterEventText: document.getElementById("monsterEventText"),

    winFx: document.getElementById("winFx"),
    loseFx: document.getElementById("loseFx"),
  };

  const LOG_STYLE = {
    neutral: { color:"#e5e7eb", icon:"" },
    roll:    { color:"#e5e7eb", icon:"üé≤ " },
    place:   { color:"#e5e7eb", icon:"üìç " },
    pickup:  { color:"#e5e7eb", icon:"ü™µ " },
    deposit: { color:"#39ff95", icon:"‚ú® " },
    bonus:   { color:"#c27bff", icon:"üí• " },
    level:   { color:"#ffd166", icon:"üèÜ " },
    warn:    { color:"#ffb347", icon:"‚ö†Ô∏è " },
    bad:     { color:"#ff5a6a", icon:"üíÄ " },
    monster: { color:"#ff1f3a", icon:"üëπ " },
    save:    { color:"#ffd166", icon:"üíæ " },
    load:    { color:"#a8dadc", icon:"üìÇ " },
    win:     { color:"#f3f4f6", icon:"üåü " },
  };

  function prependToLog(el, line){
    if (!el) return;
    el.prepend(line);
    while (el.children.length > LOG_MAX_LINES) el.removeChild(el.lastChild);
  }

  function logEvent(kind, msg){
    const st = LOG_STYLE[kind] || LOG_STYLE.neutral;

    const line1 = document.createElement("div");
    line1.className = "line";
    line1.style.color = st.color;
    line1.textContent = (st.icon || "") + msg;

    const line2 = line1.cloneNode(true);

    prependToLog(ui.log, line1);
    prependToLog(ui.battleLog, line2);
  }

  function loadLeaderboard(){
    try{
      const raw = localStorage.getItem(LS_LEADERBOARD);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveLeaderboard(arr){
    localStorage.setItem(LS_LEADERBOARD, JSON.stringify(arr));
  }
  function upsertLeaderboardEntry(name, score, level){
    const n = (name || "PLAYER1").toUpperCase();
    const lb = loadLeaderboard();
    const filtered = lb.filter(e => (e?.name || "").toUpperCase() !== n);
    filtered.push({ name:n, score: Number(score)||0, level: Number(level)||1 });
    filtered.sort((x,y) => {
      if (y.score !== x.score) return y.score - x.score;
      return y.level - x.level;
    });
    const top3 = filtered.slice(0,3);
    saveLeaderboard(top3);
    renderLeaderboard(top3);
  }
  function renderLeaderboard(lb){
    const rows = (lb && lb.length) ? lb : loadLeaderboard();
    ui.leaderboard.innerHTML = "";
    if (!rows.length){
      ui.leaderboard.innerHTML = `<div style="color:#9fb1c6;">No scores yet. Play a game.</div>`;
      return;
    }
    const medals = ["gold","silver","bronze"];
    rows.forEach((e, idx) => {
      const wrap = document.createElement("div");
      wrap.className = "leaderRow";
      const medalClass = medals[idx] || "";
      wrap.innerHTML = `
        <div>
          <div class="leaderName ${medalClass}">${escapeHtml(e.name || "PLAYER1")}</div>
          <div class="leaderMeta">Lvl ${Number(e.level)||1}</div>
        </div>
        <div class="big">${Number(e.score)||0}</div>
      `;
      ui.leaderboard.appendChild(wrap);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function isPhone(){
    return window.matchMedia && window.matchMedia("(max-width:720px)").matches;
  }
  function updateScrollHint(){
    if (!ui.scrollHint || !ui.controlsScroll) return;
    if (!isPhone()){ ui.scrollHint.style.display = "none"; return; }
    if (sessionStorage.getItem(SS_SCROLLED) === "1"){ ui.scrollHint.style.display = "none"; return; }
    const canScroll = ui.controlsScroll.scrollHeight > (ui.controlsScroll.clientHeight + 6);
    const atTop = ui.controlsScroll.scrollTop <= 2;
    ui.scrollHint.style.display = (canScroll && atTop) ? "block" : "none";
  }
  ui.controlsScroll?.addEventListener("scroll", () => {
    if (!isPhone()) return;
    if (ui.controlsScroll.scrollTop > 20){
      sessionStorage.setItem(SS_SCROLLED, "1");
      updateScrollHint();
    }
  }, { passive:true });
  window.addEventListener("resize", () => setTimeout(updateScrollHint, 60), { passive:true });

  /* ---------- AUDIO ---------- */
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  async function unlockAudio(){
    try{
      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.00001;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.01);
      audioUnlocked = true;
    }catch(_){}
  }
  const unlockOnce = async () => {
    if (audioUnlocked) return;
    await unlockAudio();
  };
  document.addEventListener("touchstart", unlockOnce, { passive:true });
  document.addEventListener("pointerdown", unlockOnce, { passive:true });

  function beep(freq=440, dur=0.08, type="sine", gain=0.08){
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.linearRampToValueAtTime(0, t0 + dur);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }catch(e){}
  }
  function chord(freqs=[440,550], dur=0.12, gain=0.05, type="triangle"){
    freqs.forEach((f)=>beep(f, dur, type, gain));
  }

  function startMusic(){
    ensureAudio();
    if (musicTimer) return;
    musicStep = 0;
    musicTimer = setInterval(() => {
      if (!musicOn) return;
      if (game.pendingMonster) return;

      const now = Date.now();
      const inDoom = now < doomUntil;
      const inCelebration = (!inDoom) && (now < celebrationUntil);

      const step = inDoom ? pickDoomStep() : (inCelebration ? pickCelebrationStep() : pickMusicStep(musicStep++));
      if (!step) return;

      const hasChord = Array.isArray(step.chord) && step.chord.length;
      const hasLead  = step.lead && !hasChord;
      const hasBass  = step.bass;

      if (!hasChord && !hasLead && !hasBass) return;

      const dur  = step.dur  ?? 0.16;
      const gain = step.gain ?? 0.040;
      const oscType = step.type || "triangle";

      if (hasChord){
        chord(step.chord, dur, gain, oscType);
      } else if (hasLead){
        beep(step.lead, dur, oscType, gain);
      }
      if (hasBass){
        beep(step.bass, dur * 1.2, "sine", gain * 0.70);
      }
    }, MUSIC_STEP_MS);
  }
  function stopMusic(){
    if (musicTimer){ clearInterval(musicTimer); musicTimer = null; }
  }

  /* ---- Pause (true pause: stops loop, stops music, freezes timeouts) ---- */
  let paused = false;
  let rafId = null;
  let pauseStartedAt = 0;
  let pausePrevInputLocked = false;
  let pausePrevMusicOn = false;

  const activeTimeouts = new Map();
  let pausedTimeouts = [];

  function gameSetTimeout(fn, ms){
    const due = Date.now() + ms;
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.set(id, { fn, due });
    return id;
  }
  function pauseAllGameTimeouts(){
    const now = Date.now();
    pausedTimeouts = [];
    for (const [id, meta] of activeTimeouts.entries()){
      clearTimeout(id);
      pausedTimeouts.push({ fn: meta.fn, ms: Math.max(0, meta.due - now) });
    }
    activeTimeouts.clear();
  }
  function resumeAllGameTimeouts(){
    const list = pausedTimeouts.slice();
    pausedTimeouts = [];
    list.forEach(t => gameSetTimeout(t.fn, t.ms));
  }

  function startLoop(){
    if (rafId) return;
    rafId = requestAnimationFrame(loop);
  }

  function stopMonsterDoom(){
    if (monsterDoomStingTimer){
      clearTimeout(monsterDoomStingTimer);
      monsterDoomStingTimer = null;
    }
  }

  function pauseGame(){
    if (paused) return;
    if (ui.nameOverlay.style.display === "flex") return;

    paused = true;
    pauseStartedAt = Date.now();

    pausePrevInputLocked = game.inputLocked;
    game.inputLocked = true;

    pausePrevMusicOn = musicOn;
    if (musicOn) stopMusic();
    stopMonsterDoom();

    pauseAllGameTimeouts();

    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    ui.pauseOverlay.style.display = "flex";
    ui.btnPause.textContent = "‚ñ∂ Resume";
  }

  function resumeGame(){
    if (!paused) return;

    const now = Date.now();
    const delta = Math.max(0, now - pauseStartedAt);

    if (celebrationUntil) celebrationUntil += delta;
    if (doomUntil) doomUntil += delta;

    paused = false;

    ui.pauseOverlay.style.display = "none";
    ui.btnPause.textContent = "‚è∏ Pause";

    game.inputLocked = pausePrevInputLocked;

    resumeAllGameTimeouts();
    startLoop();

    if (pausePrevMusicOn && musicOn){
      startMusic();
      if (game.pendingMonster) playMonsterDoomSting();
    }
  }

  function togglePause(){
    if (paused) resumeGame();
    else pauseGame();
  }

  /* ---- Stick Monster: doom sting (battle intro) ---- */
  let monsterDoomStingTimer = null;

  function playMonsterDoomSting(){
    if (!musicOn) return;
    ensureAudio();
    stopMonsterDoom();

    const seq = [
      () => { beep(55, 0.22, "sawtooth", 0.10); beep(73.4, 0.20, "sawtooth", 0.08); chord([110,131,165], 0.14, 0.055, "triangle"); },
      () => { beep(49, 0.22, "sawtooth", 0.10); chord([98,117,147], 0.16, 0.055, "triangle"); },
      () => { beep(55, 0.26, "sawtooth", 0.10); chord([110,147,165], 0.14, 0.055, "triangle"); },
      () => { beep(41.2, 0.28, "sawtooth", 0.10); chord([82,98,123], 0.18, 0.055, "triangle"); },
      () => { beep(55, 0.30, "sawtooth", 0.10); chord([110,131,165], 0.18, 0.055, "triangle"); }
    ];

    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (!game.pendingMonster) return;
      if (i >= seq.length) return;
      seq[i++]();
      monsterDoomStingTimer = gameSetTimeout(step, 480);
    };
    step();
  }

  function playPacmanDeathSting(){
    if (!musicOn) return;
    ensureAudio();
    const notes = [988, 932, 880, 784, 698, 622, 554, 466, 392];
    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (i >= notes.length) return;
      beep(notes[i++], 0.11 + i*0.01, "square", 0.095);
      gameSetTimeout(step, 90);
    };
    step();
  }

  /* ---- SFX ---- */
  function sfxRoll(){ beep(320,0.06,"square",0.06); beep(420,0.07,"square",0.05); }
  function sfxPickup(){ beep(740,0.06,"triangle",0.07); }
  function sfxPlace(){ beep(420,0.07,"triangle",0.05); }
  function sfxDeposit(){ chord([520,660,780],0.14,0.06,"triangle"); }
  function sfxError(){ beep(160,0.08,"sawtooth",0.06); }
  function sfxZeroBad(){ beep(120,0.10,"sawtooth",0.07); beep(90,0.12,"sawtooth",0.06); }
  function sfxBonus(){ chord([660,880],0.16,0.06,"triangle"); }
  // Special power-up stick sounds
  function playSpeedStickSound(){
    // Fast ascending notes
    setTimeout(() => beep(440, 0.08, "square", 0.12), 0);
    setTimeout(() => beep(554, 0.08, "square", 0.12), 80);
    setTimeout(() => beep(659, 0.08, "square", 0.12), 160);
    setTimeout(() => beep(880, 0.12, "square", 0.15), 240);
  }
  
  function playShieldStickSound(){
    // Power-up ascending chord
    setTimeout(() => chord([330, 440, 554], 0.15, 0.1, "triangle"), 0);
    setTimeout(() => chord([440, 554, 659], 0.15, 0.1, "triangle"), 150);
    setTimeout(() => chord([554, 659, 880], 0.2, 0.12, "triangle"), 300);
  }
  

  // Fire warning sound (ominous, dangerous)

  
  // Wind warning sound (whooshing, dangerous)

  
  // Shadow monster attack sound (eerie, scary)
  function playShadowMonsterSound(){
    beep(80, 0.15, "sawtooth", 0.1);
    setTimeout(() => beep(60, 0.15, "sawtooth", 0.1), 150);
    setTimeout(() => beep(40, 0.2, "sawtooth", 0.12), 300);
  }
  
  // Shark chomp sound (aggressive bite)
  function playSharkChompSound(){
    beep(200, 0.08, "square", 0.12);
    setTimeout(() => beep(150, 0.08, "square", 0.12), 80);
    setTimeout(() => beep(100, 0.12, "square", 0.15), 160);
  }
  
  // Bubbles sound for Sea Stick (ambient)
  function playBubbleSound(){
    if (!playBubbleSound.lastPlayed || Date.now() - playBubbleSound.lastPlayed > 3000){
      playBubbleSound.lastPlayed = Date.now();
      beep(800, 0.05, "sine", 0.03);
      setTimeout(() => beep(900, 0.05, "sine", 0.03), 100);
      setTimeout(() => beep(1000, 0.05, "sine", 0.03), 200);
    }
  }
  function playWindWarningSound(){
    // Whooshing wind tones
    beep(200, 0.12, "triangle", 0.06);
    setTimeout(() => beep(180, 0.12, "triangle", 0.06), 120);
    setTimeout(() => beep(160, 0.12, "triangle", 0.06), 240);
  }
  function playFireWarningSound(){
    // Low ominous tones
    beep(110, 0.15, "sawtooth", 0.08);
    setTimeout(() => beep(98, 0.15, "sawtooth", 0.08), 150);
    setTimeout(() => beep(110, 0.15, "sawtooth", 0.08), 300);
  }
  function playVisionStickSound(){
    // Mystical sparkle sound
    setTimeout(() => beep(659, 0.08, "sine", 0.1), 0);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 70);
    setTimeout(() => beep(1047, 0.08, "sine", 0.1), 140);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 210);
    setTimeout(() => beep(1175, 0.15, "sine", 0.12), 280);
  }

  function sfxExtraLife(){ chord([523,659,784],0.20,0.06,"triangle"); chord([659,784,988],0.22,0.06,"triangle"); }
  function sfxMonsterHit(){ beep(70,0.16,"sawtooth",0.08); beep(55,0.18,"sawtooth",0.08); }
  function sfxLevelUp(){
    chord([440,660,880],0.18,0.06,"triangle");
    chord([494,740,988],0.18,0.06,"triangle");
    chord([523,784,1046],0.22,0.06,"triangle");
  }
  function sfxWin(){
    // Pac-Man style victory fanfare
    setTimeout(() => beep(523,0.12,"square",0.15), 0);      // C5
    setTimeout(() => beep(659,0.12,"square",0.15), 150);    // E5
    setTimeout(() => beep(784,0.12,"square",0.15), 300);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 450);   // C6
    setTimeout(() => beep(784,0.12,"square",0.15), 600);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 750);   // C6
    setTimeout(() => beep(1047,0.12,"square",0.15), 900);   // C6
    setTimeout(() => beep(1047,0.18,"square",0.15), 1050);  // C6 final
  }

  const player = { name: "PLAYER1" };

  function sanitizeName(s){
    return (s || "").trim().replace(/\s+/g," ").slice(0,16);
  }
  function getSavedName(){
    const saved = localStorage.getItem(LS_PLAYER_NAME);
    const name = saved ? sanitizeName(saved).toUpperCase() : "";
    return name || "";
  }
  function setAndStoreName(name){
    const n = (sanitizeName(name) || "PLAYER1").toUpperCase();
    player.name = n;
    localStorage.setItem(LS_PLAYER_NAME, n);
    ui.player.textContent = n;
  }

  function getSavedSkin(){
    const raw = (localStorage.getItem(LS_PLAYER_SKIN) || "").toLowerCase();
    if (raw === "bighead" || raw === "alien") return "alien";
    if (raw === "runner" || raw === "sally") return "sally";
    if (raw === "rick") return "rick";
    if (raw === "robot") return "robot";
    return "classic";
  }
  function setAndStoreSkin(s){
    let val = (s || "classic").toLowerCase();
    if (val === "bighead") val = "alien";
    if (val === "runner") val = "sally";
    const allowed = ["classic","alien","sally","rick","robot","rex"];
    const skin = allowed.includes(val) ? val : "classic";
    game.playerSkin = skin;
    localStorage.setItem(LS_PLAYER_SKIN, skin);
    if (ui.skin) ui.skin.value = skin;
  }

  const game = {
    level: 1,
    lives: 3,
    score: 0,
    actions: 0,

    bonusActive: false,
    bonusExtraRollReady: false,
    bonusPendingRoll: false,
    bonusMovesDoubled: false,

    playerSkin: "classic",

    playerX: 2,
    playerY: 2,
    carry: [],
    sticks: [],
    holeX: 12,
    holeY: 12,

    lifeTileX: -1,
    lifeTileY: -1,
    lifeTileUsed: false,

    treeX: -1,
    treeY: -1,
    treeActive: false,
    treePhase: "hidden",
    treePhaseTimer: 0,
    treeSpawnDelay: 0,
    treeSpawnedThisLevel: false,

    pendingMonster: null,
    monsterWinStreak: 0,

    hudMsg: "",
    hudTimer: 0,
    holePulse: 0,
    holeFlash: 0,
    sparks: [],

    inputLocked: false
  };

  function carryCap(){
    const base = Math.min(6, 3 + Math.floor((game.level - 1) / 3));
    return game.bonusActive ? (base + 2) : base;
  }
  function sticksToSpawnForLevel(level){
    return 6 + (level-1)*3;
  }
  function zeroChance(level){
    return Math.min(0.18, 0.00 + (level-1)*0.015);
  }
  function curseChance(level){
    return Math.min(0.16, 0.08 + (level-1)*0.015);
  }
  function bonusChance(level){
    return Math.min(0.22, 0.10 + (level-1)*0.01);
  }

  function setHud(msg){
    game.hudMsg = msg;
    game.hudTimer = 60;
  }

  function currentLevelTheme(){
    const idx = clamp(game.level - 1, 0, LEVELS.length - 1);
    return LEVELS[idx];
  }

  function applyThemeForLevel(){
    const t = currentLevelTheme();
    if (ui.themeMini) ui.themeMini.textContent = t.name;
    document.documentElement.style.setProperty("--lvlBg", t.bg);
    document.documentElement.style.setProperty("--lvlBorder", t.border);
    document.documentElement.style.setProperty("--lvlAccentGlow", t.accentGlow);
    document.documentElement.style.setProperty("--lvlAccentShadow", t.accentShadow);
  }

  function isOccupiedByStick(x,y){
    return game.sticks.some(s => s.x===x && s.y===y);
  }
  function isHole(x,y){ return x===game.holeX && y===game.holeY; }
  function isLifeTile(x,y){
    return !game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY;
  }
  function isTreeTile(x,y){
    return game.treeActive && x===game.treeX && y===game.treeY;
  }

  function randomEmptyTile(){
    for (let i=0;i<2000;i++){
      const x = randInt(0, GRID_W-1);
      const y = randInt(0, GRID_H-1);
      if ((x===game.playerX && y===game.playerY) || isHole(x,y) || isOccupiedByStick(x,y)) continue;
      if (!game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY) continue;
      if (game.treeActive && x===game.treeX && y===game.treeY) continue;
      return {x,y};
    }
    return {x:0,y:0};
  }

  function spawnHole(){
    if (game.level === 1){
      game.holeX = Math.floor(GRID_W/2);
      game.holeY = Math.floor(GRID_H/2);
      return;
    }
    game.holeX = randInt(6, GRID_W-7);
    game.holeY = randInt(6, GRID_H-7);
  }


  // Spawn special power-up sticks (rare)
  function maybeSpawnSpecialSticks(){
    const theme = currentLevelTheme().name;
    const level = game.level;
    
    // Special sticks only appear from level 3 onwards
    if (level < 3) return;
    
    // 40% chance per level to spawn ONE special stick
    if (Math.random() < 0.4){
      const p = randomEmptyTile();
      const types = ['speed', 'shield', 'vision'];
      const type = types[randInt(0, 2)];
      
      let color = '#3aa7ff'; // Speed = blue
      if (type === 'shield') color = '#39ff95'; // Shield = green
      if (type === 'vision') color = '#ffd400'; // Vision = yellow
      
      game.sticks.push({ 
        x: p.x, 
        y: p.y, 
        color: color, 
        cursed: false, 
        bonus: false,
        special: type
      });
    }
  }
  function spawnSticksForLevel(level){
    game.sticks = [];
    const n = sticksToSpawnForLevel(level);
    const cc = curseChance(level);
    const bc = bonusChance(level);

    for (let i=0;i<n;i++){
      const p = randomEmptyTile();
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      const cursed = Math.random() < cc;
      const bonus = !cursed && (Math.random() < bc);
      game.sticks.push({ x:p.x, y:p.y, color, cursed, bonus });
    }
    if (game.sticks.length > 0 && !game.sticks.some(s => s.cursed)){
      const idx = randInt(0, game.sticks.length - 1);
      game.sticks[idx].cursed = true;
      game.sticks[idx].bonus = false;
    }
  }

  function spawnLifeTile(){
    const p = randomEmptyTile();
    game.lifeTileX = p.x;
    game.lifeTileY = p.y;
    game.lifeTileUsed = false;
  }

  function clearTree(){
    game.treeActive = false;
    game.treePhase = "hidden";
    game.treePhaseTimer = 0;
    game.treeX = -1;
    game.treeY = -1;
  }

  function scheduleTreeForLevel(){
    clearTree();
    game.treeSpawnedThisLevel = false;
    game.treeSpawnDelay = 60 * randInt(30, 300); // 30 seconds ‚Äì 5 minutes
  }

  function spawnTreeNow(){
    const p = randomEmptyTile();
    game.treeX = p.x;
    game.treeY = p.y;
    game.treeActive = true;
    game.treePhase = "visible";
    game.treePhaseTimer = 60 * 15;
    game.treeSpawnedThisLevel = true;

    logEvent("bonus","A tree appears... (15s)");
    setHud("TREE APPEARS!");
  }

  function startTreeBlinking(){
    game.treePhase = "blinking";
    game.treePhaseTimer = 60 * 15;
    logEvent("warn","Tree is blinking... hurry!");
    setHud("TREE BLINKING!");
  }

  function endTree(){
    clearTree();
    logEvent("warn","The tree fades away.");
    setHud("TREE GONE");
  }

  function showNameModal(){
    game.inputLocked = true;
    ui.nameOverlay.style.display = "flex";
    ui.nameInput.value = "";
    ui.nameInput.placeholder = "ENTER NAME";

    const saved = getSavedName();
    if (saved && saved !== "PLAYER1"){
      ui.savedNameHint.style.display = "block";
      ui.savedNameHint.textContent = `Saved on this device: ${saved}`;
      ui.nameUseSavedBtn.style.display = "inline-block";
      ui.nameUseSavedBtn.textContent = `Use ${saved}`;
    }else{
      ui.savedNameHint.style.display = "none";
      ui.nameUseSavedBtn.style.display = "none";
    }

    gameSetTimeout(()=>ui.nameInput.focus(), 50);
  }
  function closeNameModal(){
    ui.nameOverlay.style.display = "none";
    game.inputLocked = false;
  }
  function startFromNameInput(){
    const entered = sanitizeName(ui.nameInput.value);
    if (!entered) setAndStoreName("PLAYER1");
    else setAndStoreName(entered);
    closeNameModal();
    newGame(true);
  }

  function resetCoreState(){
    game.level = 1;
    game.lives = 3;
    game.score = 0;
    game.actions = 0;

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    game.carry = [];
    game.sticks = [];
    game.sparks = [];
    game.holePulse = 0;
    game.holeFlash = 0;
    game.hudMsg = "";
    game.hudTimer = 0;

    game.playerX = 2;
    game.playerY = 2;

    game.lifeTileX = -1;
    game.lifeTileY = -1;
    game.lifeTileUsed = false;

    scheduleTreeForLevel();

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    game.monsterWinStreak = 0;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();

    if (ui.log) ui.log.innerHTML = "";
    if (ui.battleLog) ui.battleLog.innerHTML = "";
    logEvent("neutral","Welcome to STICKS.");
    logEvent("neutral","Roll to begin.");

    setAndStoreSkin(getSavedSkin());
    
    // Initialize snowflakes if starting on Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize fire tiles if starting on Fire Stick
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize wind tiles if starting on Sky Stick
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
    } else {
      windTiles = [];
      windWarningTimer = 0;
    }
    
    // Initialize freeze tiles if starting on Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Initialize snakes if starting on Snake Stick
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeMoveTimer = 0;
    }
    
    // Initialize sharks if starting on Sea Stick
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      sharkMoveTimer = 0;
    }
    
    shadowMonsters = [];
    
    // Initialize shadow clones if starting on Victory Stick
    if (currentLevelTheme().name === "Victory Stick"){
      initShadowClones();
    } else {
      shadowClones = [];
      cloneMoveTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset all effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;// Reset hole visibility
    holeVisible = true;
    holeFadeTimer = 0;

    gameSetTimeout(updateScrollHint, 60);
  }

  function commitScoreToLeaderboard(){
    upsertLeaderboardEntry(player.name, game.score, game.level);
  }

  function burstFx(el, emoji, count=26){
    if (!el) return;
    el.innerHTML = "";
    const w = el.clientWidth || 680;
    for (let i=0;i<count;i++){
      const s = document.createElement("span");
      s.textContent = emoji;
      s.style.left = randInt(0, w) + "px";
      s.style.top  = randInt(-20, 30) + "px";
      s.style.animationDuration = (1.2 + Math.random()*0.9) + "s";
      s.style.transform = `translateY(0) rotate(${randInt(0,180)}deg)`;
      el.appendChild(s);
    }
  }

  function winGame(){
    commitScoreToLeaderboard();

    burstFx(ui.winFx, "‚ú®", 34);

    ui.winText.textContent = `YOU WIN ‚Äî ${player.name}\nScore: ${game.score}\n\nThe sticks have been humbled. The hole is satisfied (for now).`;
    ui.winOverlay.style.display = "flex";
    game.inputLocked = true;

    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    setHud("VICTORY STICK!");
    logEvent("win","Victory Stick cleared. You win.");

    spawnSparks(game.holeX, game.holeY, 46, false);
    spawnSparks(game.playerX, game.playerY, 22, false);

    sfxWin();
    startCelebrationMusic(8500);
  }

  function newLevel(){
    if (game.level >= 9){
      winGame();
      updateUI();
      return;
    }

    game.level++;
    applyThemeForLevel();
    
    // Initialize snowflakes for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize wind tiles for Sky Stick theme
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
    } else {
      windTiles = [];
      windWarningTimer = 0;
    }
    
    // Initialize freeze tiles for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Initialize snakes for Snake Stick theme
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeMoveTimer = 0;
    }
    
    // Initialize sharks for Sea Stick theme
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      sharkMoveTimer = 0;
    }
    
    // Initialize shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    // Initialize Victory Stick hazards
    if (currentLevelTheme().name === "Victory Stick"){
      initVictoryHazards();
    }
    }
    
    // Initialize shadow clones if starting on Victory Stick
    if (currentLevelTheme().name === "Victory Stick"){
      initShadowClones();
    } else {
      shadowClones = [];
      cloneMoveTimer = 0;
    }
    
    // Initialize shadow clones for Victory Stick
    if (currentLevelTheme().name === "Victory Stick"){
      initShadowClones();
    } else {
      shadowClones = [];
      cloneMoveTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset special effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;
    
    // Clear trails and particles// Reset hole visibility for new level
    holeVisible = true;
    holeFadeTimer = 0;
    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();
    scheduleTreeForLevel();

    game.actions = 0;
    game.carry = [];

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    logEvent("level",`Level ${game.level}! (${currentLevelTheme().name})`);
    sfxLevelUp();
    setHud(`LEVEL ${game.level}!`);

    commitScoreToLeaderboard();
    updateUI();
  }

  function newGame(fresh=false){
    if (!fresh){
      showNameModal();
      return;
    }
    resetCoreState();
    applyThemeForLevel();
    updateUI();
    startLoop();
  }

  function canRoll(){
    if (game.inputLocked && !game.pendingMonster) return false;
    if (game.pendingMonster) return true;
    if (game.actions > 0) return false;
    return true;
  }

  function rollNormal(){
    const zc = zeroChance(game.level);
    if (Math.random() < zc) return 0;
    return randInt(1,5);
  }

  function rollBonus2d6(){
    const d1 = randInt(1,6);
    const d2 = randInt(1,6);
    return { total: d1 + d2, d1, d2 };
  }

  function doRoll(){
    if (!canRoll()){
      sfxError();
      setHud("Spend Actions first!");
      return;
    }

    ui.diceBox.classList.add("rolling");
    sfxRoll();

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      if (game.pendingMonster){
        resolveMonsterRoll();
        return;
      }

      if (game.bonusActive){
        const r = rollBonus2d6();
        ui.diceFace.textContent = String(r.total);
        ui.diceLabel.textContent = `BONUS üé≤üé≤ (${r.d1}+${r.d2})`;

        game.bonusPendingRoll = false;
        game.bonusMovesDoubled = false;

        game.actions = r.total;
        logEvent("bonus",`Bonus roll: ${r.total}`);
        if (r.total === 12){
          game.bonusExtraRollReady = true;
          logEvent("bonus","Jackpot 12! Extra Bonus roll earned.");
          setHud("12! Extra Bonus roll earned!");
        } else {
          game.bonusExtraRollReady = false;
        }
      } else {
        const r = rollNormal();
        ui.diceFace.textContent = String(r);
        ui.diceLabel.textContent = `Normal üé≤ (0‚Äì5)`;

        if (r === 0){
          logEvent("bad","Rolled 0!");
          sfxZeroBad();
          handleZeroPenalty();
          game.actions = 0;
        } else {
          game.actions = r;
          logEvent("roll",`Rolled ${r}.`);
        }
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
    }, 260);
  }

  function scatterPositionAround(x,y, radius){
    for (let i=0;i<200;i++){
      const nx = clamp(x + randInt(-radius, radius), 0, GRID_W-1);
      const ny = clamp(y + randInt(-radius, radius), 0, GRID_H-1);
      if (isHole(nx,ny)) continue;
      if (isOccupiedByStick(nx,ny)) continue;
      if (nx===game.playerX && ny===game.playerY) continue;
      if (isLifeTile(nx,ny)) continue;
      if (isTreeTile(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    return randomEmptyTile();
  }

  function handleZeroPenalty(){
    if (game.carry.length > 0){
      const dropped = game.carry.splice(0, game.carry.length);
      dropped.forEach(st => {
        const p = scatterPositionAround(game.playerX, game.playerY, 3);
        game.sticks.push({ x:p.x, y:p.y, color: st.color, cursed:false, bonus:false });
      });
      logEvent("bad",`Zero! Dropped ${dropped.length} stick(s).`);
      setHud(`Zero! Dropped ${dropped.length}!`);
    } else {
      const p = scatterPositionAround(game.holeX, game.holeY, 3);
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      game.sticks.push({ x:p.x, y:p.y, color, cursed:false, bonus:false });
      logEvent("bad","Zero! Hole spits out a stick.");
      setHud("Hole spits out a stick!");
    }
    game.holeFlash = 1.0;
  }

  function onBonusStickPickup(){
    game.bonusPendingRoll = true;

    if (game.actions > 0){
      const before = game.actions;
      game.actions *= 2;
      game.bonusMovesDoubled = true;

      logEvent("bonus",`BONUS STICK! Actions doubled: ${before} ‚Üí ${game.actions}.`);
      setHud(`BONUS! ${before}‚Üí${game.actions} (Roll later)`);
      sfxBonus();
      updateUI();
      return;
    }

    game.bonusMovesDoubled = false;
    game.bonusActive = true;

    logEvent("bonus","BONUS STICK! No Actions left ‚Äî Bonus roll now!");
    setHud("BONUS ROLL NOW!");
    sfxBonus();
    updateUI();

    doRoll();
  }

  function promptBonusRollReady(){
    game.bonusActive = true;
    game.bonusMovesDoubled = false;

    ui.diceFace.textContent = "‚Äî";
    ui.diceLabel.textContent = "BONUS READY (2‚Äì12)";
    ui.btnRoll.classList.add("flashRoll");

    logEvent("bonus","Bonus roll ready! Press ROLL.");
    setHud("BONUS ROLL READY!");
    sfxBonus();
    updateUI();
  }

  function exitBonusIfDone(){
    if (game.actions === 0 && !game.bonusExtraRollReady){
      if (game.bonusActive){
        game.bonusActive = false;
        ui.btnRoll.classList.remove("flashRoll");
        logEvent("neutral","Bonus ended.");
        setHud("Bonus ended.");
      }
    }
  }

  function spendAction(){
    if (game.pendingMonster){
      sfxError();
      setHud("Fight the monster first! Press ROLL.");
      return false;
    }
    if (game.actions <= 0){
      sfxError();
      setHud("No Actions. Roll!");
      return false;
    }
    if (activeSpeedBoost > 0){
          activeSpeedBoost--;
          logEvent("info", `Speed boost! ${activeSpeedBoost} free moves left`);
        } else {
          game.actions--;
        }

    if (game.actions === 0){
      if (game.bonusPendingRoll && !game.bonusActive){
        promptBonusRollReady();
      } else {
        exitBonusIfDone();
      }
    }

    updateUI();
    return true;
  }

  function monsterStickValueForStreak(streak){
    if (streak <= 3) return 2;
    return Math.min(12, (streak - 1));
  }

  function resolveMonsterRoll(){
    const pending = game.pendingMonster;
    if (!pending) return;
    const index = pending.index;
    game.pendingMonster = null;

    ui.diceBox.classList.add("rolling");
    sfxRoll();
    logEvent("monster","Monster Stick! Rolling (0‚Äì5)...");

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      const roll = randInt(0,5);
      ui.diceFace.textContent = String(roll);
      ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";

      const s = game.sticks[index];
      stopMonsterDoom();

      if (roll <= 1){
        if (s && s.cursed){
          game.sticks.splice(index,1);
        }
        game.lives = Math.max(0, game.lives - 1);
        spawnSparks(game.playerX, game.playerY, 18, true);

        game.monsterWinStreak = 0;

        logEvent("monster","Monster wins! Lost 1 life. (Streak reset)");
        setHud("MONSTER WINS! -1 LIFE");

        playPacmanDeathSting();

        if (game.lives <= 0){
          ui.monsterEvent.style.display = "none";
          ui.btnRoll.classList.remove("flashRoll");
          updateUI();
          game.inputLocked = false;
          game.pendingMonster = null;
          gameOver();
          return;
        }
      } else {
        game.monsterWinStreak++;
        const streak = game.monsterWinStreak;
        const mult = monsterStickValueForStreak(streak);

        if (s){
          game.sticks.splice(index,1);
          game.carry.push({ color: s.color, value: mult, fromMonster:true, streakAtWin: streak });
        }

        logEvent("bonus",`You beat the monster! Stick is worth ${mult}√ó. (Streak ${streak})`);
        setHud(`MONSTER BEATEN! ${mult}√ó STICK`);
        sfxPickup();
        startCelebrationMusic(6500);

        if (streak === 3){
          if (game.lives < MAX_LIVES){
            game.lives++;
            logEvent("bonus","3√ó Monster streak! +1 life.");
            setHud("+1 LIFE (3√ó STREAK)");
            sfxExtraLife();
            startCelebrationMusic(7500);
          } else {
            logEvent("bonus","3√ó Monster streak (already max lives).");
            setHud("3√ó STREAK (MAX LIVES)");
            startCelebrationMusic(6500);
          }
        }
      }

ui.monsterEvent.style.display = "none";
ui.btnRoll.classList.remove("flashRoll");
game.inputLocked = false;
updateUI();

/* ‚úÖ BUGFIX: if the monster removed the LAST stick and you‚Äôre carrying none,
   the field is cleared but the game never advances. */
if (game.sticks.length === 0 && game.carry.length === 0){
  logEvent("level","Cleared the field!");
  newLevel();
  return;
}

gameSetTimeout(updateScrollHint, 30);

    }, 260);
  }

  function move(dx,dy){
    if (game.inputLocked) return;
    if (!spendAction()) return;
    game.playerX = clamp(game.playerX + dx, 0, GRID_W-1);
    game.playerY = clamp(game.playerY + dy, 0, GRID_H-1);
    beep(220,0.03,"triangle",0.02);
    updateUI();
  }

  function pickOrDrop(){
    if (game.inputLocked) return;
    if (!spendAction()) return;

    if (isTreeTile(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        const cap = carryCap();
        for (let i=0;i<cap;i++){
          const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
          game.carry.push({ color, value:1, fromMagic:true });
        }
        logEvent("bonus",`Tree magic! Instantly filled to ${cap}.`);
        setHud(`TREE LOAD (${cap})`);
        sfxPickup();

        if (game.sticks.length === 0){
          endTree();
        }

        updateUI();
        return;
      }

      game.carry.pop();

      if (game.lives < MAX_LIVES){
        game.lives++;
        logEvent("bonus","Fed the tree. +1 life.");
        setHud("+1 LIFE (TREE)");
        sfxExtraLife();
        startCelebrationMusic(6500);
      } else {
        game.score += TREE_FEED_MAX_POINTS;
        logEvent("bonus",`Fed the tree (max lives). +${TREE_FEED_MAX_POINTS} points.`);
        setHud(`TREE FED (+${TREE_FEED_MAX_POINTS})`);
        sfxPickup();
        commitScoreToLeaderboard();
      }

      endTree();

      if (game.sticks.length === 0 && game.carry.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
        return;
      }

      updateUI();
      return;
    }

    if (isHole(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        sfxError(); setHud("Nothing to deposit."); return;
      }
      const n = game.carry.length;
      let pts = 0;
      for (const st of game.carry){
        let v = st.value || 1;
        if (game.bonusActive) v *= 2;
        pts += v;
      }
      game.score += pts;
      game.carry = [];

      logEvent("deposit",`Deposited ${n} stick(s) (+${pts}).`);
      sfxDeposit();
      setHud(`+${pts} deposited!`);

      game.holePulse = 1.0;
      spawnSparks(game.holeX, game.holeY, 28);

      commitScoreToLeaderboard();

      if (game.sticks.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
      } else {
        updateUI();
      }
      return;
    }

    const idx = game.sticks.findIndex(s => s.x===game.playerX && s.y===game.playerY);
    if (idx >= 0){
      if (game.carry.length >= carryCap()){
        sfxError();
        const cap = carryCap();
        setHud(`MAX STICKS (${cap})`);
        logEvent("warn",`MAX STICKS (${cap}).`);
        return;
      }

      const s = game.sticks[idx];

      if (s.cursed){
        game.pendingMonster = { index: idx };
        game.inputLocked = true;

        logEvent("monster","Monster Stick! Press ROLL (0‚Äì5) to fight.");
        setHud("MONSTER STICK! PRESS ROLL");

        ui.diceFace.textContent = "?";
        ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";
        ui.monsterEventText.textContent =
          `Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a powered stick. Roll 0‚Äì1 and you lose 1 life. (Win streak carries across levels; resets only on a loss.)`;
        ui.monsterEvent.style.display = "flex";
        ui.btnRoll.classList.add("flashRoll");

        sfxMonsterHit();
        playMonsterDoomSting();
        updateUI();
        gameSetTimeout(updateScrollHint, 30);
        return;
      }

      // Check if it's a special stick
      if (s.special){
        pickupSpecialStick(s.special);
        game.sticks.splice(idx,1);return;
      }game.sticks.splice(idx,1);
      game.carry.push({ color:s.color, value:1 });

      sfxPickup();

      if (s.bonus){
        onBonusStickPickup();
      }

      const cap = carryCap();
      if (game.carry.length === cap){
        logEvent("warn",`MAX LOAD (${cap}).`);
        setHud(`MAX LOAD (${cap})`);
      } else {
        logEvent("pickup",`Picked up a stick. (${game.carry.length}/${cap})`);
        setHud(`Picked up (${game.carry.length}/${cap})`);
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
      return;
    }

    if (game.carry.length > 0){
      if (isOccupiedByStick(game.playerX, game.playerY)){
        sfxError(); setHud("Tile already has a stick."); return;
      }

      if (isLifeTile(game.playerX, game.playerY)){
        game.carry.pop();
        game.lifeTileUsed = true;

        if (game.lives < MAX_LIVES){
          game.lives++;
          logEvent("bonus","Secret life tile! +1 life.");
          setHud("+1 LIFE");
          sfxExtraLife();
          startCelebrationMusic(6500);
        } else {
          game.score += LIFE_TILE_MAX_POINTS;
          logEvent("bonus",`Life tile found (max lives). +${LIFE_TILE_MAX_POINTS} points.`);
          setHud(`LIFE TILE (+${LIFE_TILE_MAX_POINTS})`);
          sfxPickup();
          commitScoreToLeaderboard();
        }

        spawnSparks(game.playerX, game.playerY, 18, false);
        updateUI();
        return;
      }

      const st = game.carry.pop();
      game.sticks.push({ x:game.playerX, y:game.playerY, color:st.color, cursed:false, bonus:false });
      sfxPlace();
      logEvent("place","Placed 1 stick.");
      setHud("Placed 1 stick.");
      updateUI();
      return;
    }

    sfxError();
    setHud("No stick here.");
  }

  function gameOver(){
    commitScoreToLeaderboard();

    burstFx(ui.loseFx, "ü™µ", 30);

    const taunts = [
      "The Stick Monster claps slowly. Loudly. Rudely.",
      "The sticks whisper: 'Skill issue.'",
      "The monster does a little dance. It‚Äôs disrespectful.",
      "The hole sighs. The monster cackles."
    ];
    const t = taunts[randInt(0, taunts.length-1)];

    ui.gameOverText.textContent = `GAME OVER ‚Äî ${player.name}\nScore: ${game.score} ‚Ä¢ Level: ${game.level}\n\n${t}`;
    ui.gameOverOverlay.style.display = "flex";
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();
    game.inputLocked = true;

    logEvent("bad", `Game Over. ${t}`);
    setHud("GAME OVER");

    spawnSparks(game.playerX, game.playerY, 26, true);
    spawnSparks(game.holeX, game.holeY, 16, true);

    startDoomMusic(8500);
  }

  function spawnSparks(gx,gy,count=18, evil=false){
    const cx = gx*TILE + TILE/2;
    const cy = gy*TILE + TILE/2;
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      game.sparks.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 24 + Math.random()*20, evil });
    }
  }

  function updateRollButtonState(){
    ui.btnRoll.disabled = (game.inputLocked && !game.pendingMonster) || (game.actions !== 0 && !game.pendingMonster);
  }

  function updateUI(){
    ui.player.textContent = player.name;
    ui.lives.textContent = String(game.lives);
    ui.level.textContent = String(game.level);
    ui.score.textContent = String(game.score);
    ui.actions.textContent = String(game.actions);

    const cap = carryCap();
    ui.carry.textContent = `${game.carry.length}/${cap}`;
    ui.left.textContent = String(game.sticks.length);

    let mode = "NORMAL";
    if (game.bonusActive) mode = game.bonusExtraRollReady ? "BONUS+" : "BONUS";
    else if (game.bonusPendingRoll) mode = "BONUS (PENDING)";
    ui.mode.textContent = mode;

    ui.die.textContent = game.bonusActive ? "2‚Äì12" : "0‚Äì5";

    updateRollButtonState();
  }

  function canSaveLoad(){
    if (ui.infoOverlay.style.display === "flex") return false;
    if (ui.nameOverlay.style.display === "flex") return false;
    if (ui.gameOverOverlay.style.display === "flex") return false;
    if (ui.winOverlay.style.display === "flex") return false;
    if (ui.pauseOverlay.style.display === "flex") return false;
    if (game.pendingMonster) return false;
    return true;
  }

  function serializeGame(){
    return {
      v: 2,
      when: Date.now(),
      playerName: player.name,
      playerSkin: game.playerSkin,
      game: {
        level: game.level,
        lives: game.lives,
        score: game.score,
        actions: game.actions,

        bonusActive: game.bonusActive,
        bonusExtraRollReady: game.bonusExtraRollReady,
        bonusPendingRoll: game.bonusPendingRoll,
        bonusMovesDoubled: game.bonusMovesDoubled,

        playerX: game.playerX,
        playerY: game.playerY,
        carry: game.carry,
        sticks: game.sticks,
        holeX: game.holeX,
        holeY: game.holeY,
        lifeTileX: game.lifeTileX,
        lifeTileY: game.lifeTileY,
        lifeTileUsed: game.lifeTileUsed,

        treeX: game.treeX,
        treeY: game.treeY,
        treeActive: game.treeActive,
        treePhase: game.treePhase,
        treePhaseTimer: game.treePhaseTimer,
        treeSpawnDelay: game.treeSpawnDelay,
        treeSpawnedThisLevel: game.treeSpawnedThisLevel,

        monsterWinStreak: game.monsterWinStreak,

        hudMsg: "",
        hudTimer: 0,
        holePulse: 0,
        holeFlash: 0
      }
    };
  }

  function applySerialized(obj){
    if (!obj || !obj.game) return false;

    setAndStoreName(obj.playerName || "PLAYER1");
    setAndStoreSkin(obj.playerSkin || getSavedSkin());

    const g = obj.game;
    game.level = clamp(Number(g.level)||1, 1, 9);
    game.lives = clamp(Number(g.lives)||3, 0, MAX_LIVES);
    game.score = Math.max(0, Number(g.score)||0);
    game.actions = Math.max(0, Number(g.actions)||0);

    game.bonusActive = !!g.bonusActive;
    game.bonusExtraRollReady = !!g.bonusExtraRollReady;
    game.bonusPendingRoll = !!g.bonusPendingRoll;
    game.bonusMovesDoubled = !!g.bonusMovesDoubled;

    game.playerX = clamp(Number(g.playerX)||2, 0, GRID_W-1);
    game.playerY = clamp(Number(g.playerY)||2, 0, GRID_H-1);

    game.carry = Array.isArray(g.carry) ? g.carry.slice(0, 12) : [];
    game.sticks = Array.isArray(g.sticks) ? g.sticks.map(s => ({
      x: clamp(Number(s.x)||0, 0, GRID_W-1),
      y: clamp(Number(s.y)||0, 0, GRID_H-1),
      color: String(s.color || "#f3f4f6"),
      cursed: !!s.cursed,
      bonus: !!s.bonus
    })) : [];

    game.holeX = clamp(Number(g.holeX)||12, 0, GRID_W-1);
    game.holeY = clamp(Number(g.holeY)||12, 0, GRID_H-1);

    game.lifeTileX = clamp(Number(g.lifeTileX)||-1, -1, GRID_W-1);
    game.lifeTileY = clamp(Number(g.lifeTileY)||-1, -1, GRID_W-1);
    game.lifeTileUsed = !!g.lifeTileUsed;

    game.treeX = clamp(Number(g.treeX)||-1, -1, GRID_W-1);
    game.treeY = clamp(Number(g.treeY)||-1, -1, GRID_W-1);
    game.treeActive = !!g.treeActive;
    game.treePhase = String(g.treePhase || (game.treeActive ? "visible" : "hidden"));
    game.treePhaseTimer = Math.max(0, Number(g.treePhaseTimer)||0);
    
    // Restore level hazards
    fireTiles = Array.isArray(g.fireTiles) ? g.fireTiles : [];
    windTiles = Array.isArray(g.windTiles) ? g.windTiles : [];
    teleportTiles = Array.isArray(g.teleportTiles) ? g.teleportTiles : [];
    darkTiles = Array.isArray(g.darkTiles) ? g.darkTiles : [];
    snakes = Array.isArray(g.snakes) ? g.snakes : [];
    sharks = Array.isArray(g.sharks) ? g.sharks : [];
    shadowMonsters = Array.isArray(g.shadowMonsters) ? g.shadowMonsters : [];
    freezeTiles = Array.isArray(g.freezeTiles) ? g.freezeTiles : [];
    shadowClones = Array.isArray(g.shadowClones) ? g.shadowClones : [];
    
    // If hazards are missing (old save), reinitialize them for current level
    const currentTheme = currentLevelTheme().name;
    if (currentTheme === "Fire Stick" && fireTiles.length === 0){
      initFireTiles();
    }
    if (currentTheme === "Sky Stick" && windTiles.length === 0){
      initWindTiles();
    }
    if (currentTheme === "Spell Stick" && teleportTiles.length === 0){
      initLevelHazards();
    }
    if (currentTheme === "Glow Stick" && darkTiles.length === 0){
      initLevelHazards();
    }
    if (currentTheme === "Snake Stick" && snakes.length === 0){
      initSnakes();
    }
    if (currentTheme === "Sea Stick" && sharks.length === 0){
      initSharks();
    }
    if (currentTheme === "Ice Stick" && freezeTiles.length === 0){
      initFreezeTiles();
    }
    if (currentTheme === "Glow Stick" && shadowMonsters.length === 0){
      initShadowMonsters();
    }
    if (currentTheme === "Victory Stick" && shadowClones.length === 0){
      initShadowClones();
    }
    game.treeSpawnDelay = Math.max(0, Number(g.treeSpawnDelay)||0);
    game.treeSpawnedThisLevel = !!g.treeSpawnedThisLevel;

    game.monsterWinStreak = Math.max(0, Number(g.monsterWinStreak)||0);

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    game.inputLocked = false;
    applyThemeForLevel();
    updateUI();
    setHud("Game loaded!");
    return true;
  }

  function saveGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't save right now.");
      logEvent("warn","Can't save during overlays or monster encounter.");
      return;
    }
    try{
      localStorage.setItem(LS_SAVEGAME, JSON.stringify(serializeGame()));
      logEvent("save","Game saved (this device).");
      setHud("GAME SAVED");
      chord([262,330,392],0.16,0.05,"triangle");
    }catch(_){
      sfxError();
      setHud("Save failed.");
    }
  }

  function loadGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't load right now.");
      logEvent("warn","Can't load during overlays or monster encounter.");
      return;
    }
    try{
      const raw = localStorage.getItem(LS_SAVEGAME);
      if (!raw){
        sfxError();
        setHud("No saved game.");
        logEvent("load","No saved game found.");
        return;
      }
      const obj = JSON.parse(raw);
      const ok = applySerialized(obj);
      if (ok){
        logEvent("load","Game loaded.");
        chord([294,370,440],0.16,0.05,"triangle");
      } else {
        sfxError();
        setHud("Load failed.");
      }
    }catch(_){
      sfxError();
      setHud("Load failed.");
    }
  }

  /* ---- Drawing ---- */

  /* ‚úÖ Casey changes requested:
     - Glow Stick grid: softened + pulses
     - Victory Stick grid: softened (and pulses a bit too)
     - Ice Stick: aesthetically nicer but still consistent (icy gradient + soft sheen + gentle pulse)
  */
  function drawGrid(theme){
    // background
    if (theme.name === "Ice Stick"){
      const g = ctx.createLinearGradient(0,0,CANVAS_W,CANVAS_H);
      g.addColorStop(0, "#f5fbff");
      g.addColorStop(0.55, theme.bg);
      g.addColorStop(1, "#dbeafe");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

      // subtle frost sheen diagonals (static look, very faint)
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.moveTo(-40 + i*90, 40);
        ctx.lineTo(CANVAS_W, CANVAS_H - 80 + i*40);
        ctx.stroke();
      }
      ctx.restore();
    } else {
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    }

    // time for pulse
    const t = ((performance.now ? performance.now() : Date.now()) / 1000);
    const osc = (Math.sin(t*2.8) + 1) / 2; // 0..1

    // base softness per theme
    const isGlow = theme.name === "Glow Stick";
    const isVic  = theme.name === "Victory Stick";
    const isIce  = theme.name === "Ice Stick";

    let baseAlpha = 0.55;
    let pulseAdd  = 0.00;
    let glowAlpha = 0.00;
    let glowBlur  = 0;

    if (isGlow){
      baseAlpha = 0.22;
      pulseAdd  = 0.22;   // noticeable pulse
      glowAlpha = 0.08 + osc*0.06;
      glowBlur  = 12 + osc*8;
    } else if (isVic){
      baseAlpha = 0.26;
      pulseAdd  = 0.16;   // softer pulse than Glow
      glowAlpha = 0.07 + osc*0.05;
      glowBlur  = 10 + osc*6;
    } else if (isIce){
      baseAlpha = 0.18;
      pulseAdd  = 0.14;   // gentle pulse
      glowAlpha = 0.05 + osc*0.04;
      glowBlur  = 8 + osc*5;
    } else {
      baseAlpha = 0.55;
      pulseAdd  = 0.00;
      glowAlpha = 0.00;
      glowBlur  = 0;
    }

    // neon blur pass (softens the grid + gives the pulse)
    if (isGlow || isVic || isIce){
      ctx.save();
      ctx.strokeStyle = theme.grid;
      ctx.shadowColor = theme.grid;
      ctx.shadowBlur = glowBlur;
      ctx.globalAlpha = glowAlpha;
      ctx.lineWidth = 2;

      for (let x=0;x<=GRID_W;x++){
        ctx.beginPath();
        ctx.moveTo(x*TILE + 0.5, 0);
        ctx.lineTo(x*TILE + 0.5, CANVAS_H);
        ctx.stroke();
      }
      for (let y=0;y<=GRID_H;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*TILE + 0.5);
        ctx.lineTo(CANVAS_W, y*TILE + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    // crisp pass (but softened via alpha + pulse)
    ctx.strokeStyle = theme.grid;
    ctx.lineWidth = 1;
    ctx.globalAlpha = clamp(baseAlpha + (osc*pulseAdd), 0.06, 0.72);

    for (let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE + 0.5, 0);
      ctx.lineTo(x*TILE + 0.5, CANVAS_H);
      ctx.stroke();
    }
    for (let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE + 0.5);
      ctx.lineTo(CANVAS_W, y*TILE + 0.5);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
  }

  function drawHole(theme){
    if (!holeVisible) return; // Support for hole fading on higher levels
    
    const cx = game.holeX*TILE + TILE/2;
    const cy = game.holeY*TILE + TILE/2;

    if (game.holePulse > 0) game.holePulse = Math.max(0, game.holePulse - 0.03);
    if (game.holeFlash > 0) game.holeFlash = Math.max(0, game.holeFlash - 0.04);

    const pulse = game.holePulse;
    const flash = game.holeFlash;

    // Theme-specific hole colors with vibrant accents
    let holeColor = "#000000";
    let holeStroke = "#f3f4f6";
    let glowColor = "rgba(243,244,246,0.4)";
    
    if (theme.name === "Sun Stick") {
      holeColor = "#2a1a00";
      holeStroke = "#ffd400";
      glowColor = "rgba(255,212,0,0.6)";
    } else if (theme.name === "Sky Stick") {
      holeColor = "#051a3a";
      holeStroke = "#3aa7ff";
      glowColor = "rgba(58,167,255,0.6)";
    } else if (theme.name === "Fire Stick") {
      holeColor = "#1a0005";
      holeStroke = "#ff5a6a";
      glowColor = "rgba(255,31,58,0.6)";
    } else if (theme.name === "Leaf Stick" || theme.name === "Snake Stick") {
      holeColor = "#001a0a";
      holeStroke = "#39ff95";
      glowColor = "rgba(57,255,149,0.6)";
    } else if (theme.name === "Sea Stick") {
      holeColor = "#051a2e";
      holeStroke = "#00d9ff";
      glowColor = "rgba(0,217,255,0.6)";
    } else if (theme.name === "Spell Stick") {
      holeColor = "#1a0020";
      holeStroke = "#ff69ff";
      glowColor = "rgba(255,105,255,0.6)";
    } else if (theme.name === "Ice Stick") {
      holeColor = "#a0e8ff";
      holeStroke = "#ffffff";
      glowColor = "rgba(255,255,255,0.7)";
    } else if (theme.name === "Glow Stick") {
      holeColor = "#2a1500";
      holeStroke = "#ffb347";
      glowColor = "rgba(255,179,71,0.6)";
    } else if (theme.name === "Victory Stick") {
      holeColor = "#0a0015";
      holeStroke = "#c27bff";
      glowColor = "rgba(194,123,255,0.6)";
    }

    ctx.save();

    if (pulse > 0){
      ctx.globalAlpha = 0.20 + pulse*0.55;
      ctx.fillStyle = theme.accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + pulse*12, 0, Math.PI*2);
      ctx.fill();
    }

    if (flash > 0){
      ctx.globalAlpha = 0.25 + flash*0.55;
      ctx.fillStyle = "#ff1f3a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + flash*10, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;
    
    // Pulsating glow effect
    const pulsePhase = (Date.now() % 1500) / 1500; // 1.5 second pulse cycle
    const pulseIntensity = 0.5 + Math.sin(pulsePhase * Math.PI * 2) * 0.5; // oscillates 0-1
    
    // Outer glow (pulsating)
    const glowRadius = 18 + pulseIntensity * 4;
    const gradient = ctx.createRadialGradient(cx, cy, 6, cx, cy, glowRadius);
    gradient.addColorStop(0, holeColor);
    gradient.addColorStop(0.6, holeColor);
    const glowAlpha = pulseIntensity * 0.3;
    const finalGlow = glowColor.replace(/[\d.]+\)$/, glowAlpha + ')');
    gradient.addColorStop(1, finalGlow);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, glowRadius, 0, Math.PI*2);
    ctx.fill();

    // Main hole body
    ctx.shadowBlur = 0;
    ctx.fillStyle = holeColor;
    ctx.globalAlpha = 0.92;
    ctx.beginPath();
    ctx.arc(cx, cy, 8 + pulse*2, 0, Math.PI*2);
    ctx.fill();
    
    // Refined subtle pulsating outline
    ctx.globalAlpha = 0.85 + pulseIntensity * 0.15;
    ctx.lineWidth = 1.2 + pulseIntensity * 0.3;
    ctx.strokeStyle = holeStroke;
    ctx.shadowColor = holeStroke;
    ctx.shadowBlur = 6 + pulseIntensity * 4;
    ctx.beginPath();
    ctx.arc(cx, cy, 16 + pulse*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawLifeHint(theme){
    if (game.lifeTileUsed) return;
    if (game.carry.length <= 0) return;
    if (game.playerX !== game.lifeTileX || game.playerY !== game.lifeTileY) return;

    const x = game.lifeTileX*TILE;
    const y = game.lifeTileY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*4) + 1) / 2;

    ctx.save();
    ctx.globalAlpha = 0.15 + osc*0.25;
    ctx.strokeStyle = theme.accent;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x+3, y+3, TILE-6, TILE-6);
    ctx.stroke();
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawTree(theme){
    if (!game.treeActive) return;

    if (game.treePhase === "blinking"){
      const blinkOn = (Math.floor(game.treePhaseTimer / 10) % 2) === 0;
      if (!blinkOn) return;
    }

    const x = game.treeX*TILE;
    const y = game.treeY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*5) + 1) / 2;

    ctx.save();

    ctx.globalAlpha = 0.10 + osc*0.18;
    ctx.strokeStyle = "#39ff95";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x + TILE/2, y + TILE/2, 10 + osc*3, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#a16207";
    ctx.fillRect(x + 11, y + 12, 2, 7);
    ctx.fillRect(x + 10, y + 14, 4, 5);

    ctx.fillStyle = "#22c55e";
    ctx.fillRect(x + 8,  y + 8,  8, 2);
    ctx.fillRect(x + 7,  y + 10, 10, 2);
    ctx.fillRect(x + 8,  y + 12, 8, 2);

    ctx.globalAlpha = 0.35 + osc*0.35;
    ctx.fillStyle = theme.accent;
    ctx.fillRect(x + 6, y + 6, 1, 1);
    ctx.fillRect(x + 17, y + 7, 1, 1);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawStick(s){
    const x = s.x*TILE;
    const y = s.y*TILE;
    ctx.save();
    ctx.translate(x + TILE/2, y + TILE/2);

    const theme = currentLevelTheme();
    if (theme.name === "Ice Stick" || theme.name === "Glow Stick" || theme.name === "Victory Stick"){
      ctx.shadowColor = "rgba(0,0,0,0.18)";
      ctx.shadowBlur = 6;
    }

    ctx.strokeStyle = s.color;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(-6, -8);
    ctx.lineTo(7, 9);
    ctx.stroke();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-4, -6);
    ctx.lineTo(5, 7);
    ctx.stroke();
    ctx.globalAlpha = 1;

    if (s.bonus){
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#ffd166";
      ctx.beginPath();
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawPlayer(){
    const cx = game.playerX*TILE + TILE/2;
    const cy = game.playerY*TILE + TILE/2;

    ctx.save();
    ctx.translate(cx, cy);

    const theme = currentLevelTheme();
    const strokeBase = (theme.name === "Ice Stick") ? "#0b0f14" : "#f3f4f6";
    ctx.strokeStyle = strokeBase;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";

    const skin = game.playerSkin || "classic";

    const drawCarryDots = () => {
      const cap = carryCap();
      const carried = game.carry.length;
      const slots = Math.min(6, cap);
      const startX = -((slots-1)*4)/2;
      const isFull = carried >= cap;

      for (let i=0;i<slots;i++){
        ctx.beginPath();
        const filled = i < carried;
        if (isFull){
          ctx.fillStyle = filled ? "#ff1f3a" : "rgba(255,31,58,0.25)";
        } else {
          ctx.fillStyle = filled ? "#ffd166" : "rgba(243,244,246,0.18)";
        }
        ctx.arc(startX + i*4, 17, 1.5, 0, Math.PI*2);
        ctx.fill();
      }
    };

    const drawClassicBody = () => {
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    };

    if (skin === "alien"){
      ctx.beginPath();
      ctx.arc(0, -7, 7, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, -14);
      ctx.lineTo(-6, -19);
      ctx.moveTo(3, -14);
      ctx.lineTo(6, -19);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = "#ffd166";
      ctx.arc(-6, -20, 1.6, 0, Math.PI*2);
      ctx.arc(6, -20, 1.6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = strokeBase;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 3);
      ctx.lineTo(7, 1);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "sally"){
      ctx.beginPath();
      ctx.arc(0, -8, 4.5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(-7, 9);
      ctx.lineTo(7, 9);
      ctx.closePath();
      ctx.fillStyle = strokeBase;
      ctx.globalAlpha = 0.16;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = strokeBase;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(-11, 4);
      ctx.moveTo(7, 2);
      ctx.lineTo(11, 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, 9);
      ctx.lineTo(-6, 13);
      ctx.moveTo(3, 9);
      ctx.lineTo(6, 13);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rick"){
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-4, -11);
      ctx.lineTo(-2, -14);
      ctx.moveTo(-1, -11);
      ctx.lineTo(1, -15);
      ctx.moveTo(2, -11);
      ctx.lineTo(4, -14);
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(-4, -9, 3, 3);
      ctx.rect(1, -9, 3, 3);
      ctx.moveTo(-1, -7.5);
      ctx.lineTo(1, -7.5);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "robot"){
      // Pulsating value for eyes and antenna
      const eyePulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
      const eyeGlow = 0.4 + eyePulse * 0.6;
      
      // head
      ctx.beginPath();
      ctx.rect(-6, -13, 12, 10);
      ctx.stroke();

      // antenna
      ctx.beginPath();
      ctx.moveTo(0, -13);
      ctx.lineTo(0, -18);
      ctx.stroke();
      
      // antenna tip (RED pulsating to match eyes!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 3 + eyePulse * 5;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.beginPath();
      ctx.arc(0, -19, 1.8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.strokeStyle = strokeBase;

      // eyes (RED pulsating glow!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 4 + eyePulse * 6;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.fillRect(-4, -10, 3, 2);
      ctx.fillRect(1, -10, 3, 2);
      ctx.restore();
      
      // Eye outlines
      ctx.beginPath();
      ctx.rect(-4, -10, 3, 2);
      ctx.rect(1, -10, 3, 2);
      ctx.stroke();

      // body
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(0, 9);
      ctx.stroke();

      // arms
      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(7, 2);
      ctx.stroke();

      // legs
      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rex"){
      // Rex Stick - pure simple stick dog!
      ctx.strokeStyle = "#f3f4f6";  // Same white as other stick figures
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      
      // BIG Head (circle outline)
      ctx.beginPath();
      ctx.arc(0, -10, 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // BIG Ears (simple lines sticking up)
      ctx.beginPath();
      ctx.moveTo(-4, -14);
      ctx.lineTo(-5, -18);
      ctx.moveTo(4, -14);
      ctx.lineTo(5, -18);
      ctx.stroke();
      
      // Short body
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(0, 2);
      ctx.stroke();
      
      // Minimal cute legs (just little stubs)
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-2, 2);
      ctx.lineTo(-2, 6);
      ctx.moveTo(2, 2);
      ctx.lineTo(2, 6);
      ctx.stroke();
      
      // Wagging tail! (cute wagging to the right)
      const waggle = Math.sin(Date.now() / 100) * 0.4;
      ctx.save();
      ctx.translate(0, -2);
      ctx.rotate(waggle);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(4, -2, 6, -5);
      ctx.stroke();
      ctx.restore();
      
      drawCarryDots();
    }
    else {
      drawClassicBody();
    }

    ctx.restore();
  }

  function drawSparks(){
    if (!game.sparks.length) return;
    ctx.save();
    for (let i=game.sparks.length-1;i>=0;i--){
      const s = game.sparks[i];
      s.x += s.vx;
      s.y += s.vy;
      s.vx *= 0.96;
      s.vy *= 0.96;
      s.life -= 1;

      const a = clamp(s.life / 40, 0, 1);
      ctx.globalAlpha = 0.15 + a*0.75;
      ctx.fillStyle = s.evil ? "#ff1f3a" : "#f3f4f6";
      ctx.fillRect(s.x, s.y, 2, 2);

      if (s.life <= 0) game.sparks.splice(i,1);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawHudText(){
    if (game.hudTimer > 0 && game.hudMsg){
      game.hudTimer--;
      const t = currentLevelTheme();
      ctx.save();
      ctx.globalAlpha = clamp(game.hudTimer / 60, 0, 1);
      ctx.font = "bold 16px ui-monospace, Menlo, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(game.hudMsg, CANVAS_W/2 + 1, 20 + 1);

      ctx.fillStyle = t.name === "Ice Stick" ? "#0b0f14" : "#f3f4f6";
      ctx.fillText(game.hudMsg, CANVAS_W/2, 20);
      ctx.restore();
    }
  }

  function updateTreeTimers(){
    // freeze during monster battles (as promised in info)
    if (game.pendingMonster) return;

    if (!game.treeSpawnedThisLevel){
      if (game.treeSpawnDelay > 0){
        game.treeSpawnDelay--;
        if (game.treeSpawnDelay <= 0) spawnTreeNow();
      }
      return;
    }

    if (game.treeActive){
      if (game.treePhaseTimer > 0){
        game.treePhaseTimer--;
        if (game.treePhaseTimer <= 0){
          if (game.treePhase === "visible") startTreeBlinking();
          else if (game.treePhase === "blinking") endTree();
        }
      }
    }
  }

  function updateRollButton(){
    ui.btnRoll.disabled = !canRoll() && !game.pendingMonster;
  }

  /* ---- Main loop ---- */
  function loop(){
    rafId = requestAnimationFrame(loop);

    // update
    updateTreeTimers();
    updateRollButton();
    
    // Update fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick" && fireTiles.length > 0){
      updateFireTiles();
    }
    
    // Update freeze tiles for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick" && freezeTiles.length > 0){
      updateFreezeTiles();
    }
    
    // Update level hazards (including wind for Sky Stick)
    updateLevelHazards();
    
    // Update snakes for Snake Stick theme
    if (currentLevelTheme().name === "Snake Stick" && snakes.length > 0){
      updateSnakes();
    }
    
    // Update sharks for Sea Stick theme
    if (currentLevelTheme().name === "Sea Stick" && sharks.length > 0){
      updateSharks();
    }
    
    // Update shadow monsters for Glow Stick theme
    if (currentLevelTheme().name === "Glow Stick" && shadowMonsters.length > 0){
      updateShadowMonsters();
    }
    
    // Update Victory Stick hazards (all hazards!)
    if (currentLevelTheme().name === "Victory Stick"){
      updateVictoryHazards();
    }
    
    // Update shadow clones for Victory Stick theme
    if (currentLevelTheme().name === "Victory Stick" && shadowClones.length > 0){
      updateShadowClones();
    }

    // draw
    const theme = currentLevelTheme();
    drawGrid(theme);
    drawLifeHint(theme);
    drawTree(theme);

    // sticks
    for (const s of game.sticks) drawStick(s);

    // hole + player
    drawHole(theme);
    drawPlayer();

    drawSparks();
    
    // Draw ambient particles (background)
    drawAmbientParticles();
    
    // Draw ice frost on edges
    drawIceFrost();
    
    // Draw level hazards (dark tiles, teleport tiles)
    drawLevelHazards();
    
    // Draw fire tiles for Fire Stick theme
    if (theme.name === "Fire Stick" && fireTiles.length > 0){
      drawFireTiles();
    }
    
    // Draw wind tiles for Sky Stick theme
    if (theme.name === "Sky Stick" && windTiles.length > 0){
      drawWindTiles();
    }
    
    // Draw freeze tiles for Ice Stick theme
    if (theme.name === "Ice Stick" && freezeTiles.length > 0){
      drawFreezeTiles();
    }
    
    // Draw snakes for Snake Stick theme
    if (theme.name === "Snake Stick" && snakes.length > 0){
      drawSnakes();
    }
    
    // Draw sharks for Sea Stick theme
    if (theme.name === "Sea Stick" && sharks.length > 0){
      drawSharks();
    }
    
    // Draw shadow monsters for Glow Stick
    if (theme.name === "Glow Stick" && shadowMonsters.length > 0){
      drawShadowMonsters();
    }
    
    // Draw shadow clones for Victory Stick
    if (theme.name === "Victory Stick" && shadowClones.length > 0){
      drawShadowClones();
    }
    

    // Draw stick pickup particles// Draw special effects (shield, vision)
    drawSpecialEffects();
    
    // Draw snowflakes for Ice Stick theme (foreground)
    if (theme.name === "Ice Stick" && snowflakes.length > 0){
      drawSnowflakes();
    }
    
    drawHudText();
  }

  /* ---- UI + Controls ---- */
  function openInfo(){
    ui.infoOverlay.style.display = "flex";
    game.inputLocked = true;
  }
  function closeInfo(){
    ui.infoOverlay.style.display = "none";
    if (!paused && ui.nameOverlay.style.display !== "flex" &&
        ui.gameOverOverlay.style.display !== "flex" &&
        ui.winOverlay.style.display !== "flex"){
      game.inputLocked = false;
    }
  }

  ui.btnInfo.addEventListener("click", openInfo);
  ui.btnInfoClose.addEventListener("click", closeInfo);

  ui.btnRoll.addEventListener("click", doRoll);
  ui.btnUse.addEventListener("click", pickOrDrop);
  ui.btnNew.addEventListener("click", () => newGame(false));
  ui.btnPause.addEventListener("click", togglePause);
  ui.btnPauseClose.addEventListener("click", togglePause);

  ui.btnSave.addEventListener("click", saveGame);
  ui.btnLoad.addEventListener("click", loadGame);

  ui.btnUp.addEventListener("click", () => move(0,-1));
  ui.btnDown.addEventListener("click", () => move(0,1));
  ui.btnLeft.addEventListener("click", () => move(-1,0));
  ui.btnRight.addEventListener("click", () => move(1,0));

  ui.skin.addEventListener("change", (e) => setAndStoreSkin(e.target.value));

  ui.btnGameOverClose.addEventListener("click", () => {
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });
  ui.btnRestart.addEventListener("click", () => {
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnWinRestart.addEventListener("click", () => {
    ui.winOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnMusic.addEventListener("click", async () => {
    await unlockOnce();
    musicOn = !musicOn;
    ui.btnMusic.textContent = musicOn ? "Music: ON" : "Music: OFF";
    if (musicOn){
      startMusic();
      logEvent("neutral","Music ON.");
    } else {
      stopMusic();
      logEvent("neutral","Music OFF.");
    }
  });

  ui.nameStartBtn.addEventListener("click", startFromNameInput);
  ui.nameUseP1Btn.addEventListener("click", () => { setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); });
  ui.nameUseSavedBtn.addEventListener("click", () => {
    const s = getSavedName();
    setAndStoreName(s || "PLAYER1");
    closeNameModal();
    newGame(true);
  });

  ui.nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){ e.preventDefault(); startFromNameInput(); }
    if (e.key === "Escape"){ e.preventDefault(); setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); }
  });

  document.addEventListener("keydown", (e) => {
    // overlays first
    if (ui.nameOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        setAndStoreName("PLAYER1");
        closeNameModal();
        newGame(true);
      }
      return;
    }
    if (ui.infoOverlay.style.display === "flex"){
      if (e.key === "Escape"){ e.preventDefault(); closeInfo(); }
      return;
    }
    if (ui.gameOverOverlay.style.display === "flex" || ui.winOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        ui.gameOverOverlay.style.display = "none";
        ui.winOverlay.style.display = "none";
        game.inputLocked = false;
        newGame(false);
      }
      return;
    }

    if (e.key === "p" || e.key === "P" || e.key === "Escape"){
      e.preventDefault();
      togglePause();
      return;
    }
    if (paused) return;

    // save/load hotkeys (only when allowed)
    if ((e.key === "s" || e.key === "S") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      saveGame();
      return;
    }
    if ((e.key === "l" || e.key === "L") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      loadGame();
      return;
    }

    if (game.inputLocked && !game.pendingMonster) return;

    if (e.key === "ArrowUp"){ e.preventDefault(); move(0,-1); }
    else if (e.key === "ArrowDown"){ e.preventDefault(); move(0,1); }
    else if (e.key === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if (e.key === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if (e.key === " "){ e.preventDefault(); pickOrDrop(); }
    else if (e.key === "r" || e.key === "R"){ e.preventDefault(); doRoll(); }
    else if (e.key === "s" || e.key === "S"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); saveGame(); } }
    else if (e.key === "l" || e.key === "L"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); loadGame(); } }
  });

  // init
  renderLeaderboard(loadLeaderboard());
  setAndStoreSkin(getSavedSkin());
  const savedName = getSavedName();
  if (savedName) setAndStoreName(savedName);
  applyThemeForLevel();
  updateUI();
  updateScrollHint();

  // always start on name prompt
  showNameModal();
})();
</script>
</body>
</html>

