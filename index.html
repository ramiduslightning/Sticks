<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>STICKS</title>
  <style>
    :root{ color-scheme: dark; }

    body{
      margin:0;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      background:#0b0f14;
      color:#e6edf3;
    }

    .wrap{
      max-width: 1320px;
      margin:0 auto;
      padding:14px;
      display:grid;
      grid-template-columns: 260px 1fr 420px;
      gap:14px;
      align-items:start;
    }

    .gameWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:12px;
    }

    canvas{
      width:100%;
      height:auto;
      border:2px solid var(--lvlBorder, #1f2a37);
      border-radius:12px;
      image-rendering: pixelated;
      background: var(--lvlBg, #070a0e);
      box-shadow: 0 0 0 2px rgba(0,0,0,.15), 0 18px 50px rgba(0,0,0,.35);
      display:block;
      aspect-ratio: 1 / 1;
    }

    .panel{
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:12px;
      padding:12px;
    }

    .panelSticky{
      position: sticky;
      top: 14px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      padding-right: 10px;
    }

    .title{
      font-weight:1000;
      font-size:28px;
      letter-spacing:2px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:#3aa7ff;
      text-shadow:0 2px 4px rgba(58,167,255,0.3);
    }

    .subtitle{
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
      margin-top:6px;
    }

    .hr{ height:1px; background:#1f2a37; margin:10px 0; }

    .log{
      height: 600px;
      overflow:auto;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
      line-height:1.45;
    }
    .log .line{ margin: 0 0 8px 0; }
    .log .line:last-child{ margin-bottom:0; }

    .kv{ display:flex; justify-content:space-between; gap:10px; margin:6px 0; align-items:center; }
    .kv span:first-child{ color:#9fb1c6; }
    .big{ font-size:18px; font-weight:1000; }

    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      font-weight:1000;
      font-size:12px;
      user-select:none;
    }
    
    #uiThemeMini{
      color:#ffffff;
      text-align:center;
    }

    .playerArcade{
      font-size:22px;
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      text-shadow: 0 0 18px rgba(120,180,255,0.18);
      user-select:none;
    }

    .controlsTop{
      display:grid;
      grid-template-columns: 132px 1fr;
      gap:12px;
      align-items:center;
    }

    .diceBox{
      width:132px;
      height:132px;
      border-radius:16px;
      border:2px solid #2b3a4c;
      background: radial-gradient(120px 120px at 40% 35%, #1a2a3c 0%, #0b1220 70%);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .diceGlow{
      position:absolute;
      inset:-40px;
      background: conic-gradient(from 180deg,
        rgba(0,0,0,0),
        rgba(0,0,0,0),
        var(--lvlAccentGlow, rgba(58,167,255,.32)),
        rgba(0,0,0,0)
      );
      opacity:0;
      filter: blur(10px);
      transform: rotate(0deg);
      pointer-events:none;
    }
    .rolling .diceGlow{ opacity:1; animation: spin .32s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .diceFace{
      font-size:52px;
      font-weight:1000;
      line-height:1;
      text-shadow: 0 0 16px var(--lvlAccentShadow, rgba(58,167,255,.25));
      user-select:none;
    }
    .diceLabel{
      margin-top:8px;
      font-size:12px;
      color:#9fb1c6;
      text-align:center;
      line-height:1.25;
      user-select:none;
    }

    .dpadWrap{ margin-top:10px; display:flex; justify-content:center; align-items:center; }
    .dpad{ width:200px; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .dpad button{
      padding:10px 0;
      border-radius:12px;
      color:#e6edf3;
      background: linear-gradient(180deg,#1b2432,#0b1220);
      border:1px solid #2b3a4c;
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.10),
        0 8px 18px rgba(0,0,0,.35);
      font-weight:1000;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      text-shadow: 0 0 14px rgba(255,255,255,0.08);
    }
    .dpad button:hover{ filter: brightness(1.08); }
    .dpad button:active{ transform: translateY(1px); }
    .dpad .empty{ visibility:hidden; }

    .btns{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px;
      margin-top:10px;
    }

    button{
      cursor:pointer;
      border:0;
      padding:11px 10px;
      border-radius:12px;
      font-weight:1000;
      letter-spacing:.2px;
      user-select:none;
      box-shadow: 0 6px 18px rgba(0,0,0,.25);
      transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ filter: brightness(1.08); }
    button:disabled{ opacity:.55; cursor:not-allowed; filter:none; }

    .btn-roll { background: linear-gradient(180deg,#3aa7ff,#1172ff); color:#061018; }
    .btn-roll.ready-to-roll {
      animation: glowRoll 2s ease-in-out infinite;
      position: relative;
    }
    @keyframes glowRoll {
      0%, 100% { box-shadow: 0 0 0 1px rgba(58,167,255,0.5), 0 0 8px rgba(58,167,255,0.3), 0 6px 18px rgba(0,0,0,.25); }
      50% { box-shadow: 0 0 0 1px rgba(58,167,255,0.9), 0 0 16px rgba(58,167,255,0.6), 0 6px 20px rgba(0,0,0,.3); }
    }
    .btn-use  { background: linear-gradient(180deg,#39ff95,#08c46b); color:#061018; }
    .btn-new  { background: linear-gradient(180deg,#ffb347,#ff7a18); color:#1a0f00; }
    .btn-clear{ background: linear-gradient(180deg,#ff5a6a,#ff1f3a); color:#200007; }

    .btn-save { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }
    .btn-load { background: linear-gradient(180deg,#111827,#0b0f14); color:#f3f4f6; border:1px solid #2b3a4c; box-shadow:none; }

    .btn-music{ background: linear-gradient(180deg,#c27bff,#7a35ff); color:#120018; grid-column: 1 / span 2; }
    .btn-info { background: linear-gradient(180deg,#f3f4f6,#cbd5e1); color:#0b0f14; }

    .titleBtns{ display:flex; align-items:center; gap:8px; }
    .btn-mini{
      padding:8px 10px;
      border-radius:12px;
      font-weight:1000;
      box-shadow:none;
      min-width:44px;
      line-height:1;
    }

    @keyframes flashRoll {
      0%   { box-shadow: 0 0 0 0 rgba(255,255,255,0.0); transform: translateY(0); }
      100% { box-shadow: 0 0 0 3px rgba(255,255,255,0.75); transform: translateY(-1px); }
    }
    .flashRoll{ animation: flashRoll 0.55s ease-in-out infinite alternate; }

    .monsterEvent{
      margin-top:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid #ff1f3a;
      background:#1a0509;
      display:flex;
      gap:8px;
      align-items:flex-start;
      font-size:12px;
      line-height:1.35;
    }
    .monsterEventIcon{ font-size:20px; margin-top:2px; }
    .monsterEventTitle{ font-weight:1000; color:#ffb347; margin-bottom:3px; }

    .statsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px 10px;
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #1f2a37;
      background:#0b1220;
    }
    .statsGrid .kv{ margin:0; }
    .statsGrid .big{ font-size:16px; }

    .leaderboard{
      margin-top:10px;
      background:#0b1220;
      border:1px solid #1f2a37;
      border-radius:12px;
      padding:10px;
      font-size:12px;
    }
    .leaderRow{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding:6px 6px;
      border-radius:10px;
    }
    .leaderRow:nth-child(odd){ background: rgba(255,255,255,0.03); }
    .leaderName{ font-weight:1000; letter-spacing:.3px; }
    .leaderMeta{ color:#9fb1c6; }
    .gold { color:#ffd166; }
    .silver { color:#cbd5e1; }
    .bronze { color:#ffb347; }

    .battleFeedWrap{
      margin-top:10px;
      border:1px solid #1f2a37;
      border-radius:12px;
      background:#0b1220;
      padding:10px;
    }
    .battleFeedHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom:8px;
    }
    .battleFeedHeader b{ letter-spacing:.4px; }
    .battleLog{
      max-height: 220px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      border-radius:10px;
      border:1px solid #1f2a37;
      padding:10px;
      background:#070c16;
      font-size:12px;
      line-height:1.45;
    }

    .scrollHint{
      display:none;
      margin-top:8px;
      padding:8px 10px;
      border-radius:12px;
      border:1px dashed #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.25;
      text-align:center;
      user-select:none;
    }
    .scrollHint .arrow{
      display:inline-block;
      font-weight:1000;
      margin-left:6px;
      animation: bob 1.1s ease-in-out infinite;
    }
    @keyframes bob{
      0%,100%{ transform: translateY(0); opacity:.75; }
      50%{ transform: translateY(2px); opacity:1; }
    }

    /* ‚úÖ stick figure selector */
    select{
      padding:9px 10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#39ff95; /* Green like Pick/Drop button */
      font-weight:1000;
      outline:none;
      cursor:pointer;
    }
    select option{
      color:#39ff95; /* Green for options too */
      background:#0b1220;
    }
    select:focus{ box-shadow: 0 0 0 3px rgba(58,167,255,0.18); }

    #infoOverlay,#nameOverlay,#gameOverOverlay,#winOverlay,#pauseOverlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.72);
      z-index:9999;
      align-items:center;
      justify-content:center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .modalBox{
      width:min(780px,94vw);
      background:#0f1720;
      border:2px solid #1f2a37;
      border-radius:16px;
      padding:16px;
      max-height: calc(var(--vh, 1vh) * 92);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      position:relative;
    }
    .modalTitle{ font-weight:1000; letter-spacing:.8px; font-size:18px; }
    .modalText{
      color:#cdd9e5;
      font-size:13px;
      line-height:1.45;
      margin-top:8px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 6px;
      white-space: pre-wrap;
    }
    .modalActions{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      margin-top:14px;
      flex-wrap:wrap;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(15,23,32,0.0), rgba(15,23,32,0.88) 30%, rgba(15,23,32,1));
      padding-top: 10px;
    }
    .modalClose{
      padding:10px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      box-shadow:none;
    }

    /* ‚úÖ Win/Lose presentation */
    .endBanner{
      margin-top:10px;
      border-radius:14px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#0b1220,#070c16);
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      overflow:hidden;
      position:relative;
    }
    .endBanner .bigIcon{
      font-size:34px;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.12));
      animation: pop 0.9s ease-in-out infinite alternate;
      user-select:none;
    }
    @keyframes pop { from{ transform: translateY(0) scale(1); } to{ transform: translateY(-2px) scale(1.04); } }

    .endBanner .endHeadline{
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      font-size:14px;
    }
    .endBanner .endSub{
      color:#9fb1c6;
      font-size:12px;
      margin-top:4px;
      line-height:1.25;
    }

    .fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    .fx span{
      position:absolute;
      font-size:14px;
      opacity:0.9;
      animation: drift 1.6s linear forwards;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.10));
      user-select:none;
    }
    @keyframes drift{
      from{ transform: translateY(0) rotate(0deg); opacity:0.95; }
      to{ transform: translateY(140px) rotate(180deg); opacity:0; }
    }

    .winBanner{
      border-color: rgba(194,123,255,0.65);
      background: radial-gradient(340px 140px at 35% 25%, rgba(194,123,255,0.22) 0%, rgba(7,12,22,1) 65%);
    }
    .loseBanner{
      border-color: rgba(255,90,106,0.7);
      background: radial-gradient(340px 140px at 35% 25%, rgba(255,31,58,0.20) 0%, rgba(7,12,22,1) 65%);
    }

    #nameOverlay input{
      flex:1;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#e6edf3;
      font-weight:1000;
      outline:none;
      font-size:16px;
      letter-spacing:.6px;
      text-transform: uppercase;
    }
    .saveBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #39ff95;
      background: linear-gradient(180deg,#39ff95,#08c46b);
      color:#061018;
      font-weight:1000;
      box-shadow:none;
    }
    .altBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background: linear-gradient(180deg,#f3f4f6,#cbd5e1);
      color:#0b0f14;
      font-weight:1000;
      box-shadow:none;
    }
    .warnBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #ff5a6a;
      background: linear-gradient(180deg,#ff5a6a,#ff1f3a);
      color:#200007;
      font-weight:1000;
      box-shadow:none;
    }
    .hintRow{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid #2b3a4c;
      background:#0b1220;
      color:#9fb1c6;
      font-size:12px;
      line-height:1.35;
    }

    @media (max-width:1200px){
      .wrap{ grid-template-columns:1fr; }
      .log{ height:220px; }
      .controlsTop{ grid-template-columns:1fr; }
      .diceBox{ width:100%; height:120px; }
      .dpad{ width:100%; max-width:240px; }
      .panelSticky{ position: static; max-height: none; overflow: visible; padding-right:12px; }
    }

    @media (max-width:720px){
      .wrap > .panel:first-child{ display:none; }

      body{
        height: calc(var(--vh, 1vh) * 100);
        overflow:hidden;
      }

      .wrap{
        height: calc(var(--vh, 1vh) * 100);
        max-width:none;
        margin:0;
        padding:10px;
        gap:10px;
        grid-template-columns: 1fr;
        grid-template-rows: 1.35fr 1fr;
        align-items:stretch;
      }

      .gameWrap{
        height:100%;
        min-height:0;
      }

      canvas{
        width:auto;
        height:100%;
        max-width:100%;
        max-height:100%;
      }

      .panel-right{
        height:100%;
        min-height:0;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        display:flex;
        flex-direction:column;
        padding-bottom: calc(env(safe-area-inset-bottom) + 90px);
      }

      .controlsScroll{ order:1; }
      .headerBlock{ order:2; margin-top:10px; }
      .headerBlock .hr{ margin:10px 0 0 0; }

      .controlsTop{
        grid-template-columns: 1fr;
        gap:8px;
        margin-top:2px;
      }
      .controlsTop .subtitle{ display:none; }

      .diceBox{
        width:100%;
        height:84px;
        border-radius:14px;
      }
      .diceFace{ font-size:40px; }
      .diceLabel{ font-size:11px; margin-top:4px; }

      .controlsScroll{
        overflow: visible;
        -webkit-overflow-scrolling: auto;
        min-height:auto;
        padding-right:0;
        flex: 0 0 auto;
      }

      .battleFeedWrap{ display:block; }
    }

    @media (min-width:721px){
      .battleFeedWrap{ display:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="title" style="justify-content:center;"><div>Activity</div><span class="badge" id="uiThemeMini">Night Stick</span></div>
      <div class="subtitle">Latest on top. Color = importance.</div>
      <div class="hr"></div>
      <div class="log" id="log"></div>
    </div>

    <div class="gameWrap">
      <canvas id="game"></canvas>
    </div>

    <div class="panel panelSticky panel-right">
      <div class="controlsScroll" id="controlsScroll">
        <div class="controlsTop">
          <div class="diceBox" id="diceBox">
            <div class="diceGlow"></div>
            <div class="diceFace" id="diceFace">‚Äî</div>
            <div class="diceLabel" id="diceLabel">Press Roll</div>
          </div>
          <div class="subtitle">
            <b>Actions</b> = your energy.<br/>
            Spend Actions to <span class="badge">Move</span> or <span class="badge">Pick/Drop</span>.<br/>
            <span style="color:#9fb1c6">Spend Actions before rolling again.</span>
          </div>
        </div>

        <div class="scrollHint" id="scrollHint">
          Swipe up for controls, stats, and battle feed <span class="arrow">‚ñº</span>
        </div>

        <div id="monsterEvent" class="monsterEvent" style="display:none;">
          <div class="monsterEventIcon">üëπ</div>
          <div>
            <div class="monsterEventTitle">Stick Monster Appears!</div>
            <div id="monsterEventText">
              Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a 2√ó stick. Roll 0‚Äì1 and you lose 1 life.
            </div>
          </div>
        </div>

        <div class="dpadWrap" aria-label="D-pad">
          <div class="dpad">
            <button class="empty"></button>
            <button id="btnUp" aria-label="Up">‚ñ≤</button>
            <button class="empty"></button>
            <button id="btnLeft" aria-label="Left">‚óÄ</button>
            <button id="btnDown" aria-label="Down">‚ñº</button>
            <button id="btnRight" aria-label="Right">‚ñ∂</button>
          </div>
        </div>

        <div class="btns">
          <button id="btnRoll" class="btn-roll">üé≤ Roll</button>
          <button id="btnUse" class="btn-use">Pick/Drop</button>
          <button id="btnNew" class="btn-new">New Game</button>
          <button id="btnPause" class="btn-clear">‚è∏ Pause</button>
          <button id="btnMusic" class="btn-music">Music: ON</button>
        </div>

        <div class="hr"></div>

        <div class="kv"><span>Player</span><span id="uiPlayer" class="playerArcade">PLAYER1</span></div>

        <div class="kv"><span>Stick Figure</span>
          <select id="uiSkin" aria-label="Stick Figure">
            <option value="classic">Classic</option>
            <option value="alien">Alien Stick</option>
            <option value="sally">Sally Stick</option>
            <option value="rick">Rick Stick</option>
            <option value="robot">Robo Stick</option>
            <option value="rex">Rex Stick</option>
          </select>
        </div>

        <div class="statsGrid">
          <div class="kv"><span>Lives</span><span id="uiLives" class="big">3</span></div>
          <div class="kv"><span>Level</span><span id="uiLevel" class="big">1</span></div>
          <div class="kv"><span>Score</span><span id="uiScore" class="big">0</span></div>
          <div class="kv"><span>Actions</span><span id="uiActions" class="big">0</span></div>
          <div class="kv"><span>Mode</span><span id="uiMode" class="big">NORMAL</span></div>
          <div class="kv"><span>Die</span><span id="uiDie" class="big">0‚Äì5</span></div>
          <div class="kv"><span>Carrying</span><span id="uiCarry" class="big">0/3</span></div>
          <div class="kv"><span>Sticks left</span><span id="uiLeft" class="big">0</span></div>
        </div>

        <div class="leaderboard" id="leaderboard"></div>

        <div class="battleFeedWrap" id="battleFeedWrap">
          <div class="battleFeedHeader">
            <b>Battle Feed</b>
            <span class="badge">Latest</span>
          </div>
          <div style="color:#9fb1c6; font-size:12px; margin-bottom:8px;">
            Monster wins, deposits, level-ups, and warnings show up here.
          </div>
          <div class="battleLog" id="battleLog"></div>
        </div>

        <div style="height:10px;"></div>
      </div>

      <div class="headerBlock">
        <div class="title">
          <div>STICKS <span class="badge">v2.41</span></div>
          <div class="titleBtns">
            <button class="btn-info btn-mini" id="btnInfo" title="Info">Info</button>
            <button id="btnSave" class="btn-save btn-mini" aria-label="Save Game" title="Save (S)">Save</button>
            <button id="btnLoad" class="btn-load btn-mini" aria-label="Load Game" title="Load (L)">Load</button>
            <button id="btnSkipLevel" class="btn-info btn-mini" aria-label="Skip to Level" title="Skip to Level" style="margin-left:4px;">Level</button>
          </div>
        </div>
        <div class="subtitle">Pick up sticks. Feed the hole. Clear the field. Advance levels.</div>
        <div style="text-align:center; margin:12px 0; padding:12px 8px; background:linear-gradient(135deg, rgba(58,167,255,0.08) 0%, rgba(194,123,255,0.08) 100%); border-radius:8px; border:1px solid rgba(58,167,255,0.15); box-shadow:0 2px 8px rgba(0,0,0,0.1);">
          <div style="font-size:13px; line-height:1.5; font-family:Georgia, serif;">
            <div style="font-weight:700; letter-spacing:2px; color:#3aa7ff; text-shadow:0 1px 2px rgba(0,0,0,0.2); margin-bottom:4px;">RAMIDUS, INC.</div>
            <div style="font-size:10px; color:#9fb1c6; font-style:italic; letter-spacing:0.5px;">A Casey T. Duncan Enterprise</div>
          </div>
        </div>
        <div class="hr"></div>
      </div>
    </div>
  </div>

  <div id="skipLevelPanel" class="modal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:10000; align-items:center; justify-content:center;">
    <div class="modal-content" style="background:#161b22; border:2px solid #3aa7ff; border-radius:12px; padding:30px; max-width:600px; color:#fff;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2 style="margin:0; color:#3aa7ff;">üéØ Skip to Level</h2>
        <button id="closeSkipLevel" style="background:#ff1f3a; color:#fff; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-size:16px; font-weight:600;">‚úï</button>
      </div>
      
      <div style="color:#cdd9e5; margin-bottom:20px; line-height:1.5;">
        Jump to any level! Your progress will be reset.
      </div>
      
      <div id="levelGrid" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(120px, 1fr)); gap:12px;">
        <!-- Levels inserted by JavaScript -->
      </div>
    </div>
  </div>

  <div id="infoOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">How to Play</div>
      <div class="modalText">
        <!-- Intro -->
        <div style="margin:14px 0 12px 0; font-size:14px; color:#cdd9e5; line-height:1.5;">
          <div style="margin-bottom:12px; padding:10px; background:rgba(58,167,255,0.15); border-radius:6px; border-left:3px solid #3aa7ff;"><b style="color:#3aa7ff; font-size:15px;">GOAL:</b> Collect ALL sticks on each level and deposit them in the hole to progress!</div><b>THE BASICS:</b> Roll the dice to get actions, spend actions to move and interact, survive 15 levels of increasing difficulty!
        </div>

        <div class="hr"></div>

        <!-- Dice Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üé≤ THE DICE</b></div>
        <div style="margin:6px 0; line-height:1.5;">Each roll gives you <b>0-5 actions</b> (standard 6-sided die, but 0 instead of 6).</div>
        <div style="margin:6px 0; line-height:1.5;"><span class="badge">Roll 0</span> If carrying sticks, you drop them and they scatter. If carrying none, the hole spits out a stick nearby.</div>
        <div style="margin:6px 0 10px 0; line-height:1.5;">You must <b>spend all actions</b> before rolling again.</div>

        <div class="hr"></div>

        <!-- Actions Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéÆ ACTIONS</b></div>
        <div style="margin:6px 0; line-height:1.5;"><span class="badge">Move</span> Costs 1 action per tile (Arrow Keys or D-Pad)</div>
        <div style="margin:6px 0 10px 0; line-height:1.5;"><span class="badge">Pick/Drop</span> Costs 1 action:
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Pick up a stick if standing on one</li>
            <li style="margin:3px 0;">Drop one stick onto an empty tile</li>
            <li style="margin:3px 0;">Deposit all carried sticks into the hole for points</li>
          </ul>
        </div>

        <div class="hr"></div>

        <!-- Special Features Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéÅ SPECIAL FEATURES</b></div>
        
        <div style="margin:10px 0;"><span class="badge">Bonus Sticks</span> (Yellow glow - multiple per level)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Look for sticks with a <b>subtle yellow glow</b> around them</li>
            <li style="margin:3px 0;">When picked up, your remaining actions are <b>doubled</b></li>
            <li style="margin:3px 0;">When actions hit 0, get a <b>Bonus Roll</b> (2-12 with double dice)</li>
            <li style="margin:3px 0;">During Bonus mode, deposits are worth <b>2√ó</b> points</li>
            <li style="margin:3px 0;">Roll 12 for another bonus roll!</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Secret Life Tile</span> (Pulses when you stand on it with sticks)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Drop a stick on this square to gain <b>+1 life</b></li>
            <li style="margin:3px 0;">If already at max lives, get bonus points instead</li>
            <li style="margin:3px 0;">One per level - find it!</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Power Sticks</span> (Rare special pickups)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;"><b>Speed:</b> Next 10 moves are free (no action cost)</li>
            <li style="margin:3px 0;"><b>Shield:</b> 30 seconds of invincibility to hazards</li>
            <li style="margin:3px 0;"><b>Vision:</b> Reveals secret life tile for 30 seconds</li>
          </ul>
        </div>

        <div style="margin:10px 0;"><span class="badge">Mystery Tree</span> (Appears randomly during levels)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Standing on tree with sticks? Feed 1 stick for <b>+1 life</b></li>
            <li style="margin:3px 0;">At max lives (5)? Get <b>+8 bonus points</b> instead!</li>
            <li style="margin:3px 0;">Standing on tree with no sticks? Get a <b>full load</b> instantly</li>
            <li style="margin:3px 0;">Tree disappears after granting a life or full load</li>
          </ul>
        </div>

        <div style="margin:10px 0 12px 0;"><span class="badge">Stick Monster</span> (Cursed sticks)
          <ul style="margin:6px 0 0 18px; padding:0; color:#cdd9e5; line-height:1.5;">
            <li style="margin:3px 0;">Some sticks are cursed! Picking one triggers a monster battle</li>
            <li style="margin:3px 0;">Roll 2-5 = WIN (keep a powered-up 2√ó stick)</li>
            <li style="margin:3px 0;">Roll 0-1 = LOSE (lose 1 life)</li>
            <li style="margin:3px 0;"><b>Streak bonus:</b> Win 3 in a row for +1 life. Keep winning for 3√ó, 4√ó, 5√ó sticks!</li>
          </ul>
        </div>

        <div class="hr"></div>

        <!-- Goal Section -->
        <div style="margin:12px 0 8px 0;"><b style="color:#3aa7ff;">üéØ GOAL</b></div>
        <div style="margin:6px 0; line-height:1.5; background:rgba(58,167,255,0.1); padding:10px; border-radius:6px; border-left:3px solid #3aa7ff;">
          <div style="margin-bottom:6px;"><b style="color:#3aa7ff;">GOAL:</b> Collect ALL sticks on each level and deposit them in the hole to progress!</div>
          <div><b style="color:#3aa7ff;">HOW:</b> Roll the die, move on the grid, pick up sticks, survive hazards, and feed the hole.</div>
        </div>
        <div style="margin:10px 0 6px 0; line-height:1.5;">Progress through <b>13 themed levels</b>, each with unique challenges. Rack up the highest score!</div>
        <div style="margin:6px 0 12px 0; line-height:1.5; color:#9fb1c6;"><b>Zero in the Hole:</b> Roll a zero while standing in hole and get extra points.</div>

        <div class="hr"></div>

        <!-- Controls -->
        <div style="margin:10px 0; color:#9fb1c6; font-size:12px; line-height:1.6;">
          <b>Controls:</b> Arrow Keys or D-Pad to move ‚Ä¢ Space = Pick/Drop ‚Ä¢ Esc or P = Pause<br/>
          <b>Save/Load:</b> Progress saves automatically on this device
        </div>
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnInfoClose">Close</button>
      </div>
    </div>
  </div>

  <div id="nameOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">ENTER YOUR NAME</div>
      <div class="modalText" style="color:#9fb1c6">Stored only on this device (local browser storage).</div>

      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <input id="nameInput" maxlength="16" placeholder="ENTER NAME"/>
        <button id="nameStartBtn" class="saveBtn">Start</button>
      </div>

      <div class="hintRow" id="savedNameHint" style="display:none;"></div>

      <div class="modalActions" style="justify-content:flex-start;">
        <button id="nameUseSavedBtn" class="altBtn" style="display:none;">Use SAVED</button>
        <button id="nameUseP1Btn" class="warnBtn">Use PLAYER1</button>
      </div>

      <div class="modalText" style="color:#9fb1c6; margin-top:10px;">Press <b>Enter</b> to start ‚Ä¢ <b>Esc</b> uses PLAYER1</div>
    </div>
  </div>

  <div id="pauseOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">PAUSED</div>
      <div class="modalText" style="color:#9fb1c6">
        Game + music are paused.<br/>
        Press <b>Pause</b> again to resume.
      </div>
      <div class="modalActions">
        <button class="modalClose" id="btnPauseClose">Resume</button>
      </div>
    </div>
  </div>

  <div id="gameOverOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">GAME OVER</div>

      <div class="endBanner loseBanner">
        <div class="bigIcon">üíÄ</div>
        <div class="fx" id="loseFx"></div>
      </div>

      <div class="modalText" id="gameOverText">The sticks won this time.</div>
      <div class="modalActions">
        <button class="modalClose" id="btnGameOverClose">Close</button>
        <button class="modalClose" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>

  <div id="winOverlay">
    <div class="modalBox" role="dialog" aria-modal="true">
      <div class="modalTitle">üèÜ VICTORY! üèÜ</div>

      <div class="endBanner winBanner">
        <div class="bigIcon">üèÜ</div>
        <div class="fx" id="winFx"></div>
      </div>

      <div class="modalText" id="winText">You cleared the sticks. The hole is satisfied (for now).</div>
      <div class="modalActions">
        <button class="modalClose" id="btnWinClose">Close</button>
        <button class="modalClose" id="btnWinRestart">Play Again</button>
      </div>
    </div>
  </div>

<script>
(() => {
  function setVhVar(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVhVar();
  window.addEventListener('resize', setVhVar, { passive:true });
  window.addEventListener('orientationchange', setVhVar, { passive:true });

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const randInt = (lo, hi) => Math.floor(Math.random() * (hi - lo + 1)) + lo;

  const LS_PLAYER_NAME  = "sticks_playerName_v3";
  const LS_LEADERBOARD  = "sticks_leaderboard_v1";
  const LS_SAVEGAME     = "sticks_savegame_v1";
  const SS_SCROLLED     = "sticks_scrolled_controls_v1";
  const LS_PLAYER_SKIN  = "sticks_playerSkin_v1";

  /* ---- Level Themes + Stick Names ---- */
  const LEVELS = [
    { name:"Night Stick",   bg:"#070a0e", grid:"#0f1720", border:"#1f2a37", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.35)", accentShadow:"rgba(58,167,255,.28)" },
    { name:"Sparkle Stick", bg:"#ffeef8", grid:"#ffc0e0", border:"#ff69b4", accent:"#ff1493", accentGlow:"rgba(255,20,147,.46)", accentShadow:"rgba(255,105,180,.30)" },
    { name:"Sun Stick",     bg:"#140a03", grid:"#4a3a06", border:"#ffd400", accent:"#ffd400", accentGlow:"rgba(255,212,0,.46)", accentShadow:"rgba(255,212,0,.28)" },
    { name:"Sky Stick",     bg:"#041027", grid:"#0b234a", border:"#1172ff", accent:"#3aa7ff", accentGlow:"rgba(58,167,255,.46)", accentShadow:"rgba(58,167,255,.30)" },
    { name:"Fire Stick",    bg:"#1a0509", grid:"#361017", border:"#ff1f3a", accent:"#ff5a6a", accentGlow:"rgba(255,31,58,.46)", accentShadow:"rgba(255,90,106,.30)" },
    { name:"Mountain Stick", bg:"#2b1f1a", grid:"#5c4a3a", border:"#8b7355", accent:"#a0826d", accentGlow:"rgba(160,130,109,.46)", accentShadow:"rgba(160,130,109,.28)" },
    { name:"Cursed Stick",  bg:"#0a0012", grid:"#1a0a2a", border:"#4a0a6a", accent:"#8b00ff", accentGlow:"rgba(139,0,255,.46)", accentShadow:"rgba(139,0,255,.30)" },
    { name:"Banana Stick",  bg:"#1a2e0a", grid:"#0d1f05", border:"#ffd700", accent:"#ffeb3b", accentGlow:"rgba(255,235,59,.46)", accentShadow:"rgba(255,235,59,.28)" },
    { name:"Ice Stick",     bg:"#d4f1ff", grid:"#87ceeb", border:"#4da6ff", accent:"#ffffff", accentGlow:"rgba(56,189,248,.42)", accentShadow:"rgba(56,189,248,.22)" },
    { name:"Glow Stick",    bg:"#09060f", grid:"#ffb347", border:"#ff7a18", accent:"#ffb347", accentGlow:"rgba(255,122,24,.46)", accentShadow:"rgba(255,122,24,.22)" },
    { name:"Spell Stick",   bg:"#0d0010", grid:"#4a0a3a", border:"#ff1493", accent:"#ff1493", accentGlow:"rgba(255,20,147,.46)", accentShadow:"rgba(255,20,147,.30)" },
    { name:"Sea Stick",     bg:"#001a33", grid:"#003d5c", border:"#0077be", accent:"#00bfff", accentGlow:"rgba(0,191,255,.46)", accentShadow:"rgba(0,191,255,.30)" },
    { name:"Snake Stick",   bg:"#04120a", grid:"#0a2414", border:"#08c46b", accent:"#39ff95", accentGlow:"rgba(57,255,149,.44)", accentShadow:"rgba(57,255,149,.28)" },
    { name:"Spider Stick",  bg:"#0d0a12", grid:"#1a1520", border:"#2d2335", accent:"#8b5cf6", accentGlow:"rgba(139,92,246,.46)", accentShadow:"rgba(139,92,246,.30)" },
    { name:"Victory Stick", bg:"#0a1f0a", grid:"#1a4d2e", border:"#27ae60", accent:"#27ae60", accentGlow:"rgba(39,174,96,.55)", accentShadow:"rgba(39,174,96,.30)" }
  ];

  const STICK_COLORS = [
    "#ff5a6a","#ff1f3a","#ffb347","#ff7a18","#39ff95","#08c46b",
    "#3aa7ff","#1172ff","#c27bff","#7a35ff","#ffd166","#a8dadc",
    "#95d5b2","#ff9f1c","#b08cff","#f3f4f6"
  ];

  const TILE = 24, GRID_W = 24, GRID_H = 24;
  const CANVAS_W = GRID_W * TILE, CANVAS_H = GRID_H * TILE;

  // Snowflakes for Ice Stick theme
  let snowflakes = [];
  
  function initSnowflakes(){
    snowflakes = [];
    for (let i = 0; i < 40; i++){
      snowflakes.push({
        x: Math.random() * CANVAS_W,
        y: Math.random() * CANVAS_H,
        size: 1.5 + Math.random() * 2.5,
        speed: 0.8 + Math.random() * 1.2,
        drift: (Math.random() - 0.5) * 0.6
      });
    }
  }
  
  function updateSnowflakes(){
    for (let flake of snowflakes){
      flake.y += flake.speed;
      flake.x += flake.drift;
      if (flake.y > CANVAS_H){
        flake.y = -5;
        flake.x = Math.random() * CANVAS_W;
      }
      if (flake.x < 0) flake.x = CANVAS_W;
      if (flake.x > CANVAS_W) flake.x = 0;
    }
  }
  
  function drawSnowflakes(){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.shadowColor = "rgba(200,230,255,0.4)";
    ctx.shadowBlur = 3;
    for (let flake of snowflakes){
      ctx.beginPath();
      ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }



  // Fire hazards for Fire Stick theme
  let fireTiles = [];
  let fireWarningTimer = 0;
  const FIRE_WARNING_TIME = 150; // 2 seconds warning
  
  // Sun Stick - Roaming sun character
  let sunCharacter = { x: 0, y: 0, active: false, moveTimer: 0 };
  const positiveMessages = [
    "You got this! ‚òÄÔ∏è",
    "Keep going! üåü",
    "Awesome! ‚ú®",
    "Great job! üí™",
    "You're doing amazing! üéâ",
    "Shine bright! ‚òÄÔ∏è",
    "Stay positive! üòé",
    "Keep shining! ‚≠ê"
  ];
  
  function initSunCharacter(){
    const pos = randomEmptyTile();
    sunCharacter.x = pos.x;
    sunCharacter.y = pos.y;
    sunCharacter.active = true;
    sunCharacter.moveTimer = 0;
  }
  
  function updateSunCharacter(){
    if(currentLevelTheme().name !== "Sun Stick" || !sunCharacter.active) return;
    
    // Don't update during battles
    if(game.pendingMonster || game.inputLocked) return;
    
    // Increment move timer
    sunCharacter.moveTimer++;
    
    // Move every 120 frames (~2 seconds)
    if(sunCharacter.moveTimer < 120){
      return;
    }
    
    sunCharacter.moveTimer = 0;
    
    // Random wander
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
    const dir = dirs[randInt(0, 3)];
    sunCharacter.x = clamp(sunCharacter.x + dir.dx, 0, GRID_W - 1);
    sunCharacter.y = clamp(sunCharacter.y + dir.dy, 0, GRID_H - 1);
    
    // Check if player is within 1 square - give high five!
    const dx = Math.abs(sunCharacter.x - game.playerX);
    const dy = Math.abs(sunCharacter.y - game.playerY);
    const distance = dx + dy;
    
    // Check if not already glowing AND within 1 square
    if(distance === 1 && playerSunGlow === 0){
      // High five! Give mega vibrant gold glow EVERY TIME
      playerSunGlow = 600; // 10 seconds of MEGA glow (60 fps * 10)
      
      const message = positiveMessages[randInt(0, positiveMessages.length - 1)];
      logEvent("sun", "‚òÄÔ∏è " + message + " MEGA SUN POWER!");
      setHud("‚òÄÔ∏è MEGA SUN POWER! ‚òÄÔ∏è");
      
      // Positive ascending notes
      beep(400, 0.08, "sine", 0.15);
      setTimeout(() => beep(500, 0.08, "sine", 0.15), 80);
      setTimeout(() => beep(600, 0.08, "sine", 0.15), 160);
      setTimeout(() => beep(700, 0.1, "sine", 0.2), 240);
      setTimeout(() => beep(800, 0.12, "sine", 0.25), 340);
    }
  }
  
  function drawSunCharacter(){
    if(currentLevelTheme().name !== "Sun Stick" || !sunCharacter.active) return;
    
    const time = Date.now() * 0.001;
    const bob = Math.sin(time * 2) * 1.5;
    
    const cx = sunCharacter.x * TILE + TILE/2;
    const cy = sunCharacter.y * TILE + TILE/2 + bob;
    
    ctx.save();
    ctx.translate(cx, cy);
    
    // HUGE wavy flame-like rays ALL AROUND - STRETCH OUT!
    const pulse = Math.sin(time * 3) * 0.1 + 0.9;
    
    for(let i = 0; i < 16; i++){
      const angle = (i / 16) * Math.PI * 2;
      const waveOffset = Math.sin(time * 2 + i * 0.5) * 0.15;
      
      // Gradient for each ray - yellow to orange
      const rayGrad = ctx.createRadialGradient(0, 0, TILE * 0.3, 0, 0, TILE * 1.2);
      rayGrad.addColorStop(0, '#FFD700');
      rayGrad.addColorStop(0.5, '#FFA500');
      rayGrad.addColorStop(1, 'rgba(255, 140, 0, 0)'); // Fade to transparent
      ctx.fillStyle = rayGrad;
      
      // Draw BIG wavy flame-like ray shape
      ctx.beginPath();
      
      const innerRadius = TILE * 0.32;
      const outerRadius = (TILE * 1.1 + waveOffset * TILE * 0.2) * pulse; // MUCH BIGGER!
      
      // Create flame/wave shape with curves
      const angleWidth = 0.14;
      const angleStart = angle - angleWidth;
      const angleMid = angle;
      const angleEnd = angle + angleWidth;
      
      // Start from inner circle
      ctx.moveTo(Math.cos(angleStart) * innerRadius, Math.sin(angleStart) * innerRadius);
      
      // Curve outward to tip (flame peak) - EXTENDED!
      const tipRadius = outerRadius + Math.sin(i) * TILE * 0.15;
      ctx.quadraticCurveTo(
        Math.cos(angleMid - 0.08) * (innerRadius + outerRadius) * 0.5,
        Math.sin(angleMid - 0.08) * (innerRadius + outerRadius) * 0.5,
        Math.cos(angleMid) * tipRadius,
        Math.sin(angleMid) * tipRadius
      );
      
      // Curve back to inner circle
      ctx.quadraticCurveTo(
        Math.cos(angleMid + 0.08) * (innerRadius + outerRadius) * 0.5,
        Math.sin(angleMid + 0.08) * (innerRadius + outerRadius) * 0.5,
        Math.cos(angleEnd) * innerRadius,
        Math.sin(angleEnd) * innerRadius
      );
      
      ctx.closePath();
      ctx.fill();
      
      // Orange outline for definition
      ctx.strokeStyle = '#FF8C00';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    // Bright yellow-orange circle for sun body with gradient
    const sunGrad = ctx.createRadialGradient(0, -TILE * 0.05, 0, 0, 0, TILE * 0.32);
    sunGrad.addColorStop(0, '#FFFACD'); // Very light yellow highlight
    sunGrad.addColorStop(0.3, '#FFD700'); // Golden
    sunGrad.addColorStop(0.7, '#FFA500'); // Orange
    sunGrad.addColorStop(1, '#FF8C00'); // Dark orange edge
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(0, 0, TILE * 0.32, 0, Math.PI * 2);
    ctx.fill();
    
    // Orange outline on sun body
    ctx.strokeStyle = '#FF8C00';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Sun with sunglasses emoji üòé on top
    ctx.font = "26px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("üòé", 0, 0);
    
    ctx.restore();
  }
  
  // ======= SPARKLE STICK FUNCTIONS =======
  function initSparkleStick(){
    rainbows = [];
    sparkleTrail = 0;
    flowerRain = true; // ALWAYS ACTIVE now!
    flowerRainParticles = [];
    
    // Create ONE rainbow arcing across the board
    rainbows.push({
      x: randInt(3, GRID_W - 8),
      y: randInt(3, GRID_H - 5),
      width: randInt(6, 9),
      height: randInt(3, 5)
    });
  }
  
  function updateSparkleStick(){
    const theme = currentLevelTheme().name;
    if(theme !== "Sparkle Stick" && theme !== "Victory Stick") return;
    
    // Check if player walks through rainbow
    rainbows.forEach(rainbow => {
      const inRainbow = game.playerX >= rainbow.x && game.playerX < rainbow.x + rainbow.width &&
                        game.playerY >= rainbow.y && game.playerY < rainbow.y + rainbow.height;
      if(inRainbow && cupcakeMode === 0){
        cupcakeMode = 600; // 10 seconds of CUPCAKE POWER!
        logEvent("sparkle", "üßÅ CUPCAKE POWER! All sticks worth 2√ó for 10 seconds!");
        setHud("üßÅ CUPCAKE MODE - 2√ó STICKS! üßÅ");
        
        // Sweet magical sound - higher, sweeter tones
        beep(700, 0.08, "sine", 0.25);
        setTimeout(() => beep(900, 0.08, "sine", 0.25), 70);
        setTimeout(() => beep(1100, 0.1, "sine", 0.3), 140);
        setTimeout(() => beep(1300, 0.12, "sine", 0.35), 220);
        setTimeout(() => beep(1500, 0.08, "sine", 0.25), 300);
      }
    });
    
    // Update cupcake mode timer
    if(cupcakeMode > 0){
      cupcakeMode--;
    }
    
    // Update flower rain particles - CONSTANT soft shower
    // Gentler spawn rate for constant effect
    if(Math.random() < 0.15){
      flowerRainParticles.push({
        x: randInt(0, canvas.width),
        y: -10,
        size: randInt(8, 14),
        speed: randInt(1, 2.5),
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 0.08
        // No color stored - determined dynamically when drawing!
      });
    }
    
    // Update particles
    flowerRainParticles = flowerRainParticles.filter(p => {
      p.y += p.speed;
      p.rotation += p.rotSpeed;
      return p.y < canvas.height;
    });
  }
  
  function drawSparkleStick(){
    const theme = currentLevelTheme().name;
    if(theme !== "Sparkle Stick" && theme !== "Victory Stick") return;
    
    ctx.save();
    
    // Draw rainbows - 3D gradient effect
    rainbows.forEach(rainbow => {
      const colors = [
        {base: "#ff0000", light: "#ff6666", dark: "#cc0000"}, // Red
        {base: "#ff7f00", light: "#ffaa55", dark: "#cc6600"}, // Orange
        {base: "#ffff00", light: "#ffff88", dark: "#cccc00"}, // Yellow
        {base: "#00ff00", light: "#66ff66", dark: "#00cc00"}, // Green
        {base: "#0000ff", light: "#6666ff", dark: "#0000cc"}, // Blue
        {base: "#4b0082", light: "#8866cc", dark: "#330055"}, // Indigo
        {base: "#9400d3", light: "#cc66ff", dark: "#6600aa"}  // Violet
      ];
      const cx = rainbow.x * TILE + (rainbow.width * TILE) / 2;
      const cy = rainbow.y * TILE + (rainbow.height * TILE);
      const radius = rainbow.width * TILE / 2;
      
      // Super bright, fun rainbow - NO GREY/SHADOW!
      colors.forEach((color, i) => {
        const arcRadius = radius - i * 7;
        
        // Bright solid colors with white highlights
        ctx.strokeStyle = color.light; // Use light color only - super bright!
        ctx.lineWidth = 9;
        ctx.globalAlpha = 1; // Full opacity
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.arc(cx, cy, arcRadius, Math.PI, 0);
        ctx.stroke();
        
        // White highlight shimmer on top
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 1;
        ctx.beginPath();
        ctx.arc(cx, cy, arcRadius, Math.PI + 0.2, Math.PI + 1);
        ctx.stroke();
      });
      ctx.globalAlpha = 1;
    });
    
    
    // Draw flower rain - simple pink flowers!
    flowerRainParticles.forEach(flower => {
      ctx.save();
      ctx.translate(flower.x, flower.y);
      ctx.rotate(flower.rotation);
      
      ctx.font = `${flower.size}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("üå∏", 0, 0);
      ctx.restore();
    });
    
    ctx.restore();
  }
  
  // ======= CURSED STICK FUNCTIONS =======
  function initCursedStick(){
    ghosts = [];
    skulls = [];
    isSkeletonMode = false;
    smokeParticles = [];
    
    // Create 2-3 ghosts
    const numGhosts = randInt(2, 3);
    for(let i = 0; i < numGhosts; i++){
      ghosts.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        moveTimer: randInt(0, 90),
        float: Math.random() * Math.PI * 2
      });
    }
    
    // Create ONE moving skull that appears/disappears
    skulls.push({
      x: randInt(0, GRID_W - 1),
      y: randInt(0, GRID_H - 1),
      moveTimer: 0,
      rotation: 0,
      visible: true,
      visibleTime: randInt(240, 360), // Start visible for 4-6 seconds
      invisibleTime: randInt(60, 120)
    });
    
    // Create smoke particles
    for(let i = 0; i < 20; i++){
      smokeParticles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: randInt(20, 40),
        speed: Math.random() * 0.5 + 0.2,
        opacity: Math.random() * 0.3
      });
    }
  }
  
  function updateCursedStick(){
    const theme = currentLevelTheme().name;
    if(theme !== "Cursed Stick" && theme !== "Victory Stick") return;
    
    // Update ghosts
    ghosts.forEach(ghost => {
      ghost.float += 0.05;
      ghost.moveTimer++;
      
      if(ghost.moveTimer >= 90){
        ghost.moveTimer = 0;
        // Slow random movement
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        ghost.x = clamp(ghost.x + dir.dx, 0, GRID_W - 1);
        ghost.y = clamp(ghost.y + dir.dy, 0, GRID_H - 1);
      }
      
      // Check collision with player
      if(ghost.x === game.playerX && ghost.y === game.playerY && !isSkeletonMode){
        // TRANSFORM TO SKELETON!
        isSkeletonMode = true;
        logEvent("cursed", "üíÄ Ghost touched you! YOU'RE A SKELETON!");
        logEvent("cursed", "‚ö†Ô∏è All sticks worth 0 points until next deposit!");
        setHud("üíÄ SKELETON MODE! üíÄ");
        
        // Spooky transformation sound
        beep(200, 0.15, "sawtooth", 0.5);
        setTimeout(() => beep(150, 0.15, "sawtooth", 0.55), 100);
        setTimeout(() => beep(100, 0.2, "sawtooth", 0.6), 200);
        setTimeout(() => beep(80, 0.25, "sawtooth", 0.65), 320);
        
        // Remove the ghost that touched player
        const idx = ghosts.indexOf(ghost);
        if(idx > -1) ghosts.splice(idx, 1);
      }
    });
    
    // Update THE skull - appears and disappears on random grids
    skulls.forEach(skull => {
      skull.moveTimer++;
      skull.rotation += 0.05; // Spinning effect
      
      // Disappear/reappear cycle - not too fast (4-6 seconds visible)
      if(skull.visible){
        // Visible for 240-360 frames (4-6 seconds)
        if(skull.moveTimer >= skull.visibleTime){
          skull.visible = false;
          skull.moveTimer = 0;
          skull.invisibleTime = randInt(60, 120); // 1-2 seconds invisible
        }
      } else {
        // Invisible, waiting to reappear
        if(skull.moveTimer >= skull.invisibleTime){
          skull.visible = true;
          skull.moveTimer = 0;
          skull.visibleTime = randInt(240, 360); // 4-6 seconds visible
          // Reappear at random location
          skull.x = randInt(0, GRID_W - 1);
          skull.y = randInt(0, GRID_H - 1);
        }
      }
      
      // Check collision with player - DRAMATIC DEATH!
      if(skull.visible && skull.x === game.playerX && skull.y === game.playerY){
        game.lives--;
        logEvent("death", "üíÄüíÄüíÄ SKULL KILLED YOU! üíÄüíÄüíÄ");
        setHud("‚ò†Ô∏è DEATH! ‚ò†Ô∏è");
        
        // DRAMATIC sound sequence - death scream
        beep(400, 0.2, "sawtooth", 0.7);
        setTimeout(() => beep(300, 0.2, "sawtooth", 0.75), 150);
        setTimeout(() => beep(200, 0.25, "sawtooth", 0.8), 300);
        setTimeout(() => beep(100, 0.3, "sawtooth", 0.85), 480);
        setTimeout(() => beep(50, 0.4, "sawtooth", 0.9), 700);
        
        // Flash the screen
        game.holeFlash = 1.5;
        
        // Skull disappears after killing
        skull.visible = false;
        skull.moveTimer = 0;
        skull.invisibleTime = randInt(180, 300); // 3-5 seconds before reappearing
        
        if(game.lives <= 0){
          gameOver();
        } else {
          updateUI();
        }
      }
    });
    
    // Update smoke
    smokeParticles.forEach(smoke => {
      smoke.y -= smoke.speed;
      if(smoke.y < -smoke.size){
        smoke.y = canvas.height + smoke.size;
        smoke.x = Math.random() * canvas.width;
      }
    });
  }
  
  function drawCursedStick(){
    const theme = currentLevelTheme().name;
    if(theme !== "Cursed Stick" && theme !== "Victory Stick") return;
    
    ctx.save();
    
    // Draw smoke - wispy and atmospheric
    smokeParticles.forEach(smoke => {
      // Multiple small circles for wispy effect
      const gradient = ctx.createRadialGradient(smoke.x, smoke.y, 0, smoke.x, smoke.y, smoke.size);
      gradient.addColorStop(0, `rgba(100, 0, 140, ${smoke.opacity * 0.4})`);
      gradient.addColorStop(0.5, `rgba(80, 0, 120, ${smoke.opacity * 0.2})`);
      gradient.addColorStop(1, `rgba(60, 0, 100, 0)`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(smoke.x, smoke.y, smoke.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Add smaller wispy bits
      ctx.fillStyle = `rgba(100, 0, 140, ${smoke.opacity * 0.15})`;
      ctx.beginPath();
      ctx.arc(smoke.x + 8, smoke.y - 5, smoke.size * 0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(smoke.x - 6, smoke.y + 4, smoke.size * 0.4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Draw THE skull - WHITE, spinning, highly visible (only when visible!)
    skulls.forEach(skull => {
      if(!skull.visible) return; // Don't draw if invisible
      
      const sx = skull.x * TILE + TILE/2;
      const sy = skull.y * TILE + TILE/2;
      
      // Pulsing and rotating
      const pulse = Math.sin(Date.now() * 0.005) * 0.15 + 1.1;
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(skull.rotation); // SPINNING!
      ctx.scale(pulse, pulse);
      
      // White glow for visibility
      ctx.shadowColor = "#ffffff";
      ctx.shadowBlur = 15;
      
      ctx.font = "34px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // White skull with red outline for danger
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 2;
      ctx.fillText("üíÄ", 0, 0);
      ctx.strokeText("üíÄ", 0, 0);
      
      ctx.shadowBlur = 0;
      ctx.restore();
    });
    
    // Draw ghosts - PAC-MAN style classic sheet ghosts
    ghosts.forEach(ghost => {
      const gx = ghost.x * TILE + TILE/2;
      const gy = ghost.y * TILE + TILE/2 + Math.sin(ghost.float) * 3;
      
      ctx.save();
      ctx.translate(gx, gy);
      
      // White glow
      ctx.shadowColor = "#ffffff";
      ctx.shadowBlur = 12;
      ctx.globalAlpha = 0.9;
      
      // Single continuous ghost body (NOT head + sheet)
      ctx.fillStyle = "#f0f0f0"; // Off-white
      ctx.strokeStyle = "#d0d0d0"; // Light gray outline
      ctx.lineWidth = 1.5;
      
      ctx.beginPath();
      
      // Start at bottom left
      ctx.moveTo(-12, 12);
      
      // Wavy bottom (classic ghost bottom with 4 waves)
      ctx.lineTo(-12, 12);
      ctx.quadraticCurveTo(-9, 8, -6, 12);
      ctx.quadraticCurveTo(-3, 16, 0, 12);
      ctx.quadraticCurveTo(3, 8, 6, 12);
      ctx.quadraticCurveTo(9, 16, 12, 12);
      
      // Right side going up
      ctx.lineTo(12, 0);
      
      // Rounded dome top (like Pac-Man ghost)
      ctx.arc(0, 0, 12, 0, Math.PI, true);
      
      // Left side back down
      ctx.lineTo(-12, 12);
      
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Eyes INSIDE the ghost body (not separate)
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#000000";
      
      // Left eye - simple circle
      ctx.beginPath();
      ctx.arc(-4, -3, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Right eye - simple circle
      ctx.beginPath();
      ctx.arc(4, -3, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
      ctx.restore();
    });
    
    ctx.restore();
  }
  
  function initFireTiles(){
    fireTiles = [];
    // Create 8-12 random fire tiles
    const numFires = randInt(8, 12);
    for (let i = 0; i < numFires; i++){
      const x = randInt(0, GRID_W - 1);
      const y = randInt(0, GRID_H - 1);
      fireTiles.push({
        x, y,
        intensity: Math.random() // for animation
      });
    }
  }
  
  let fireCrackleInterval = null;
  let fireRespawnTimer = 0;
  
  function updateFireTiles(){
    // Animate fire intensity
    for (let fire of fireTiles){
      fire.intensity = (fire.intensity + 0.08) % (Math.PI * 2);
    }
    
    // Random respawn (pop up in new locations)
    fireRespawnTimer++;
    if (fireRespawnTimer >= randInt(300, 480)){ // 5-8 seconds
      fireRespawnTimer = 0;
      // Move 2-4 random fire tiles
      const numToMove = randInt(2, 4);
      for (let i = 0; i < numToMove && i < fireTiles.length; i++){
        const fire = fireTiles[randInt(0, fireTiles.length - 1)];
        fire.x = randInt(0, GRID_W - 1);
        fire.y = randInt(0, GRID_H - 1);
        spawnSparks(fire.x, fire.y, 12, false);
      }
      // No sound - just visual sparks (was too cheesy)
    }
    
    // Check if player is on fire tile
    const onFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFire){
      fireWarningTimer++;
      
      // Start continuous crackling sound
      if (!fireCrackleInterval){
        fireCrackleInterval = setInterval(() => {
          if (fireTiles.some(f => f.x === game.playerX && f.y === game.playerY)){
            // Fire crackling
            beep(100 + Math.random() * 80, 0.08, "sawtooth", 0.05);
          }
        }, 300);
      }
      
      if (fireWarningTimer >= FIRE_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          fireWarningTimer = 0;
        } else if (activeShield > 0){
          fireWarningTimer = 0;
          logEvent("info", "Shield protected you from fire!");
          setHud("SHIELD SAVED YOU!");
        } else {
          game.lives--;
          fireWarningTimer = 0;
          logEvent("bad", "Burned by fire! -1 life");
          beep(100, 0.15, "sawtooth", 0.1);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
        }
      } else if (fireWarningTimer === 60){
        logEvent("warn", "Fire burning! Move or lose a life!");
        setHud("BURNING!");
      }
    } else {
      fireWarningTimer = 0;
      if (fireCrackleInterval){
        clearInterval(fireCrackleInterval);
        fireCrackleInterval = null;
      }
    }
  }
  
  function drawFireTiles(){
    ctx.save();
    for (let fire of fireTiles){
      const x = fire.x * TILE + TILE / 2;
      const y = fire.y * TILE + TILE / 2;
      
      // Multiple flame flickers for realistic effect
      const flicker1 = Math.sin(fire.intensity) * 0.4 + 0.6;
      const flicker2 = Math.sin(fire.intensity * 1.7 + 1) * 0.3 + 0.7;
      const flicker3 = Math.sin(fire.intensity * 2.3 + 2) * 0.35 + 0.65;
      
      // Large base glow
      const glowGrad = ctx.createRadialGradient(x, y + 2, 0, x, y + 2, TILE / 2 + 6);
      glowGrad.addColorStop(0, 'rgba(255,180,0,' + (0.6 * flicker1) + ')');
      glowGrad.addColorStop(0.4, 'rgba(255,100,20,' + (0.4 * flicker2) + ')');
      glowGrad.addColorStop(1, 'rgba(255,31,58,0)');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(x, y + 2, TILE / 2 + 6, 0, Math.PI * 2);
      ctx.fill();
      
      // Main flame body (tall, dancing shape)
      const flameHeight = 10 + flicker1 * 4;
      const flameGrad = ctx.createLinearGradient(x, y + 4, x, y - flameHeight);
      flameGrad.addColorStop(0, 'rgba(255,100,0,' + (0.9 * flicker2) + ')');
      flameGrad.addColorStop(0.3, 'rgba(255,150,0,' + (0.85 * flicker1) + ')');
      flameGrad.addColorStop(0.6, 'rgba(255,200,50,' + (0.7 * flicker3) + ')');
      flameGrad.addColorStop(1, 'rgba(255,220,100,0)');
      
      ctx.fillStyle = flameGrad;
      ctx.beginPath();
      ctx.moveTo(x - 6 * flicker1, y + 4);
      ctx.bezierCurveTo(x - 5, y, x - 3 * flicker2, y - flameHeight * 0.7, x - 2, y - flameHeight);
      ctx.bezierCurveTo(x - 1, y - flameHeight - 2, x + 1, y - flameHeight - 2, x + 2, y - flameHeight);
      ctx.bezierCurveTo(x + 3 * flicker3, y - flameHeight * 0.7, x + 5, y, x + 6 * flicker1, y + 4);
      ctx.closePath();
      ctx.fill();
      
      // Hot white core
      ctx.fillStyle = 'rgba(255,255,200,' + (0.8 * flicker2) + ')';
      ctx.beginPath();
      ctx.ellipse(x, y, 3 * flicker1, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Flickering tips
      const tipFlicker = Math.sin(fire.intensity * 3) * 0.5 + 0.5;
      ctx.fillStyle = 'rgba(255,200,50,' + (0.6 * tipFlicker) + ')';
      ctx.beginPath();
      ctx.arc(x - 2 * flicker2, y - flameHeight * 0.8, 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 2 * flicker3, y - flameHeight * 0.9, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw warning indicator if player is on fire
    if (fireWarningTimer > 0){
      const playerOnFire = fireTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFire){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(fireWarningTimer * 0.3) * 0.5 + 0.5;
        
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#ff1f3a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }


  // ================================================================
  // WIND TILES - Sky Stick
  // ================================================================
  let windTiles = [];
  let windWarningTimer = 0;
  let windGustTimer = 0;
  const WIND_WARNING_TIME = 300; // 5 seconds
  
  // Sky Stick - Clouds and Airplane
  let skyClouds = [];
  let cloudTrails = []; // Player trails through clouds
  let airplane = { x: 0, y: 0, active: false, moveTimer: 0, dx: 1, dy: 0 };
  
  function initSkyClouds(){
    skyClouds = [];
    const count = randInt(8, 12);
    for(let i = 0; i < count; i++){
      skyClouds.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        drift: (Math.random() - 0.5) * 0.02
      });
    }
    
    // Init airplane
    airplane.x = randInt(0, GRID_W - 1);
    airplane.y = randInt(0, GRID_H - 1);
    airplane.active = true;
    airplane.moveTimer = 0;
    airplane.dx = Math.random() > 0.5 ? 1 : -1;
    airplane.dy = Math.random() > 0.5 ? 1 : -1;
  }
  
  function updateSkyClouds(){
    // Drift clouds slowly
    skyClouds.forEach(cloud => {
      cloud.x += cloud.drift;
      if(cloud.x < 0) cloud.x = GRID_W - 1;
      if(cloud.x >= GRID_W) cloud.x = 0;
    });
    
    // Check if player walked through a cloud
    const onCloud = skyClouds.some(c => 
      Math.floor(c.x) === game.playerX && c.y === game.playerY
    );
    if(onCloud){
      cloudTrails.push({
        x: game.playerX,
        y: game.playerY,
        lifetime: 120 // 2 seconds
      });
      // Add cloud effect on player
      playerCloudEffect = 180; // 3 seconds on player
    }
    
    // Update cloud trails
    cloudTrails = cloudTrails.filter(trail => {
      trail.lifetime--;
      return trail.lifetime > 0;
    });
    
    // Update airplane
    if(!airplane.carrying){
      airplane.moveTimer++;
      if(airplane.moveTimer >= 90){ // Move every 1.5 seconds (much slower)
        airplane.moveTimer = 0;
        airplane.x = clamp(airplane.x + airplane.dx, 0, GRID_W - 1);
        airplane.y = clamp(airplane.y + airplane.dy, 0, GRID_H - 1);
        
        // Bounce at edges
        if(airplane.x <= 0 || airplane.x >= GRID_W - 1) airplane.dx *= -1;
        if(airplane.y <= 0 || airplane.y >= GRID_H - 1) airplane.dy *= -1;
        
        // Random direction change
        if(Math.random() < 0.1){
          airplane.dx = Math.random() > 0.5 ? 1 : -1;
          airplane.dy = Math.random() > 0.5 ? 1 : -1;
        }
      }
    }
    
    // Check if player hit airplane
    if(airplane.x === game.playerX && airplane.y === game.playerY && !airplane.carrying){
      airplane.carrying = true;
      airplane.tripProgress = 0;
      airplane.tripSteps = 0;
      logEvent("airplane", "‚úàÔ∏è Airplane ride! Taking you on a trip!");
      setHud("AIRPLANE RIDE!");
      beep(600, 0.1, "sine", 0.2);
      setTimeout(() => beep(800, 0.1, "sine", 0.2), 100);
    }
    
    // Animate airplane trip if carrying player
    if(airplane.carrying){
      airplane.tripProgress++;
      if(airplane.tripProgress % 6 === 0){ // Move every ~0.1 seconds during trip
        const oldX = game.playerX;
        const oldY = game.playerY;
        game.playerX = clamp(game.playerX + airplane.dx, 0, GRID_W - 1);
        game.playerY = clamp(game.playerY + airplane.dy, 0, GRID_H - 1);
        
        // Airplane moves with player
        airplane.x = game.playerX;
        airplane.y = game.playerY;
        
        // Check if actually moved
        if(game.playerX !== oldX || game.playerY !== oldY){
          airplane.tripSteps = (airplane.tripSteps || 0) + 1;
        }
        
        if(airplane.tripSteps >= 10){
          // Trip complete! Move airplane 1 square away immediately
          airplane.carrying = false;
          airplane.tripProgress = 0;
          airplane.tripSteps = 0;
          
          // Move airplane 1 square in its direction
          airplane.x = clamp(airplane.x + airplane.dx, 0, GRID_W - 1);
          airplane.y = clamp(airplane.y + airplane.dy, 0, GRID_H - 1);
          airplane.moveTimer = 0; // Resume normal movement
          
          logEvent("airplane", "‚úàÔ∏è Arrived at destination!");
          setHud("DROPPED OFF!");
          beep(500, 0.1, "sine", 0.2);
          updateUI();
        }
      }
    }
  }
  
  function drawSkyClouds(){
    // Draw clouds - new fluffy design
    skyClouds.forEach(cloud => {
      const cx = cloud.x * TILE + TILE/2;
      const cy = cloud.y * TILE + TILE/2;
      
      ctx.save();
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      
      // More natural cloud with 5 overlapping circles
      // Bottom layer
      ctx.beginPath();
      ctx.arc(cx - TILE * 0.3, cy + TILE * 0.05, TILE * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx + TILE * 0.3, cy + TILE * 0.05, TILE * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      // Middle layer
      ctx.beginPath();
      ctx.arc(cx - TILE * 0.1, cy - TILE * 0.05, TILE * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx + TILE * 0.15, cy - TILE * 0.05, TILE * 0.28, 0, Math.PI * 2);
      ctx.fill();
      
      // Top puff
      ctx.beginPath();
      ctx.arc(cx, cy - TILE * 0.2, TILE * 0.26, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
    
    // Draw cloud trails - drag effect
    cloudTrails.forEach(trail => {
      const tx = trail.x * TILE + TILE/2;
      const ty = trail.y * TILE + TILE/2;
      const alpha = trail.lifetime / 120;
      
      ctx.save();
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
      
      // Multiple small circles creating wispy drag effect
      ctx.beginPath();
      ctx.arc(tx - TILE * 0.15, ty, TILE * 0.2 * alpha, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(tx, ty - TILE * 0.05, TILE * 0.18 * alpha, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(tx + TILE * 0.1, ty + TILE * 0.05, TILE * 0.15 * alpha, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
    
    // Draw airplane
    const ax = airplane.x * TILE + TILE/2;
    const ay = airplane.y * TILE + TILE/2;
    
    ctx.save();
    ctx.font = "24px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚úàÔ∏è", ax, ay);
    
    // If carrying player, draw stick figure attached
    if(airplane.carrying){
      ctx.font = "16px Arial";
      ctx.fillText("üßç", ax + TILE * 0.3, ay);
    }
    
    ctx.restore();
  }
  
  function initWindTiles(){
    windTiles = [];
    const num = randInt(6, 10);
    for (let i = 0; i < num; i++){
      windTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        intensity: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateWindTiles(){
    for (let w of windTiles) {
      w.intensity = (w.intensity + 0.12) % (Math.PI * 2);
    }
    
    // Random wind gusts that push player
    windGustTimer++;
    if (windGustTimer >= randInt(180, 360)){ // Every 3-6 seconds
      windGustTimer = 0;
      if (!game.inputLocked && game.actions > 0){
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        const newX = clamp(game.playerX + dir.dx, 0, GRID_W - 1);
        const newY = clamp(game.playerY + dir.dy, 0, GRID_H - 1);
        
        // Don't push into hole
        if (newX !== game.holeX || newY !== game.holeY){
          game.playerX = newX;
          game.playerY = newY;
          beep(250, 0.08, "triangle", 0.05);
          logEvent("info", "Wind gust pushed you!");
          setHud("WIND GUST!");
          spawnSparks(game.playerX, game.playerY, 12, false);
        }
      }
    }
    
    const onWind = windTiles.some(w => w.x === game.playerX && w.y === game.playerY);
    if (onWind){
      windWarningTimer++;
      if (windWarningTimer >= WIND_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          windWarningTimer = 0;
        } else if (activeShield > 0){
          windWarningTimer = 0;
          logEvent("info", "Shield blocked wind!");
          setHud("SHIELD!");
        } else if (game.carry.length > 0){
          // Scatter sticks all over board
          const scattered = game.carry.length;
          for (let stick of game.carry){
            const pos = randomEmptyTile();
            stick.x = pos.x;
            stick.y = pos.y;
            game.sticks.push(stick);
          }
          game.carry = [];
          windWarningTimer = 0;
          logEvent("bad", `Wind scattered ${scattered} sticks across the board!`);
          setHud("SCATTERED!");
          beep(400, 0.15, "sawtooth", 0.10);
          spawnSparks(game.playerX, game.playerY, 25, true);
          updateUI();
        } else {
          // Throw player 4-5 squares
          const distance = randInt(4, 5);
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          let newX = game.playerX;
          let newY = game.playerY;
          for (let i = 0; i < distance; i++){
            const testX = clamp(newX + dir.dx, 0, GRID_W - 1);
            const testY = clamp(newY + dir.dy, 0, GRID_H - 1);
            if (testX === newX && testY === newY) break;
            newX = testX; newY = testY;
          }
          if (newX !== game.playerX || newY !== game.playerY){
            game.playerX = newX; game.playerY = newY;
            logEvent("bad", `Wind threw you ${distance} squares!`);
            setHud("THROWN!");
            beep(350, 0.12, "sine", 0.08);
            spawnSparks(game.playerX, game.playerY, 20, false);
          }
          windWarningTimer = 0;
        }
      } else if (windWarningTimer === 60 || windWarningTimer === 180){
        beep(200, 0.12, "triangle", 0.06);
        logEvent("warn", "Wind trap! Move!");
        setHud("WIND!");
      }
    } else {
      windWarningTimer = 0;
    }
  }
  
  function drawWindTiles(){
    ctx.save();
    for (let w of windTiles){
      const x = w.x * TILE + TILE / 2;
      const y = w.y * TILE + TILE / 2;
      const spin = w.intensity;
      const pulse = Math.sin(spin * 2) * 0.3 + 0.7;
      
      // Swirling base
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      grad.addColorStop(0, 'rgba(200,220,255,' + (0.3 * pulse) + ')');
      grad.addColorStop(1, 'rgba(100,140,200,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Swirl lines
      ctx.strokeStyle = 'rgba(180,200,240,' + (0.5 * pulse) + ')';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++){
        const offset = (spin + i * Math.PI * 0.66) % (Math.PI * 2);
        const radius = 4 + i * 2;
        ctx.beginPath();
        ctx.arc(x, y, radius, offset, offset + Math.PI * 0.8);
        ctx.stroke();
      }
    }
    ctx.restore();
  }

  // ================================================================
  // SNAKES - Snake Stick (chase and drain!)
  // ================================================================
  let snakes = [];
  // Mountain Stick (Level 5)
  let mountains = [];
  let mountainClouds = []; // Floating clouds for Mountain Stick
  
  // Banana Stick (Level 6)
  let bananas = [];
  let monkeys = []; // Changed to array for multiple monkeys
  
  // Mountain Stick (Level 5)
  let rams = [];
  
  let snakeMoveTimer = 0;
  let snakeAttacking = false;
  let snakeAttackTimer = 0;
  const SNAKE_MOVE_INTERVAL = 150; // 2.5 seconds
  const SNAKE_DRAIN_INTERVAL = 180; // 3 seconds
  
  function initSnakes(){
    snakes = [];
    const num = randInt(3, 5);
    for (let i = 0; i < num; i++){
      let x, y, attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY) ||
        Math.abs(x - game.playerX) + Math.abs(y - game.playerY) < 5
      ));
      snakes.push({ x, y, slither: Math.random() * Math.PI * 2 });
    }
  }

  function initMountains(){
    mountains = [];
    const count = randInt(8, 12);
    console.log('üèîÔ∏è Spawning', count, 'mountains');
    for(let i = 0; i < count; i++){
      const pos = randomEmptyTile();
      mountains.push({ x: pos.x, y: pos.y, height: randInt(2, 5) });
    }
    console.log('Mountains:', mountains);
    
    // Add floating clouds for Mountain Stick
    mountainClouds = [];
    const cloudCount = randInt(4, 6);
    for(let i = 0; i < cloudCount; i++){
      mountainClouds.push({
        x: Math.random() * GRID_W,
        y: randInt(0, GRID_H - 1),
        drift: (Math.random() - 0.5) * 0.015
      });
    }
  }

  function initBananas(){
    bananas = [];
    const count = randInt(18, 22); // More bananas like the screenshot!
    console.log('üçå Spawning', count, 'bananas');
    for(let i = 0; i < count; i++){
      const pos = randomEmptyTile();
      bananas.push({ x: pos.x, y: pos.y });
    }
    console.log('Bananas:', bananas);
  }

  function initMonkeys(){
    monkeys = [];
    const count = randInt(2, 3);
    console.log('üêí Spawning', count, 'monkeys');
    for(let i = 0; i < count; i++){
      const pos = randomEmptyTile();
      monkeys.push({
        x: pos.x,
        y: pos.y,
        agitated: false,
        moveTimer: randInt(0, 60), // Stagger movement
        warningSoundTimer: 0
      });
    }
    console.log('Monkeys:', monkeys);
  }

  
  function updateSnakes(){
    if (game.pendingMonster) return;
    
    // Animate slithering
    for (let s of snakes) {
      s.slither = (s.slither + 0.15) % (Math.PI * 2);
    }
    
    // Handle draining if attached
    if (snakeAttacking){
      snakeAttackTimer--;
      if (snakeAttackTimer <= 0){
        snakeAttackTimer = SNAKE_DRAIN_INTERVAL;
        
        if (game.carry.length > 0){
          game.carry.pop();
          logEvent("bad", "Snake drained a stick!");
          setHud("DRAINED!");
          beep(150, 0.08, "sawtooth", 0.04);
          spawnSparks(game.playerX, game.playerY, 15, true);
          updateUI();
        } else {
          // No sticks - take life and disappear
          game.lives--;
          logEvent("bad", "Snake bite! -1 life");
          setHud("SNAKE BITE!");
          beep(100, 0.12, "sawtooth", 0.08);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          
          // Remove the snake
          for (let i = snakes.length - 1; i >= 0; i--){
            if (snakes[i].x === game.playerX && snakes[i].y === game.playerY){
              snakes.splice(i, 1);
              break;
            }
          }
          snakeAttacking = false;
        }
      }
      
      // Check if player moved away
      const stillOn = snakes.some(s => s.x === game.playerX && s.y === game.playerY);
      if (!stillOn){
        snakeAttacking = false;
        logEvent("info", "Escaped snake!");
      }
    }
    
    // Move snakes toward player
    snakeMoveTimer++;
    if (snakeMoveTimer >= SNAKE_MOVE_INTERVAL){
      snakeMoveTimer = 0;
      
      for (let i = snakes.length - 1; i >= 0; i--){
        const s = snakes[i];
        
        // Check if caught player (HOLE IS SACRED)
        if (s.x === game.playerX && s.y === game.playerY &&
            !(game.playerX === game.holeX && game.playerY === game.holeY)){
          if (activeShield > 0){
            logEvent("info", "Shield blocked snake!");
            setHud("SHIELD!");
            snakes.splice(i, 1);
          } else if (!snakeAttacking){
            snakeAttacking = true;
            snakeAttackTimer = SNAKE_DRAIN_INTERVAL;
            logEvent("warn", "Snake attached! Draining sticks!");
            setHud("SNAKE DRAINING!");
            beep(150, 0.1, "sawtooth", 0.06);
          }
          continue;
        }
        
        // Chase player
        const dx = game.playerX - s.x;
        const dy = game.playerY - s.y;
        if (Math.abs(dx) > Math.abs(dy)){
          s.x += dx > 0 ? 1 : -1;
        } else if (Math.abs(dy) > 0){
          s.y += dy > 0 ? 1 : -1;
        }
        s.x = clamp(s.x, 0, GRID_W - 1);
        s.y = clamp(s.y, 0, GRID_H - 1);
      }
    }
  }

  
  // Check if player is on a mountain (Mountain Stick level 5)
  function isOnMountain(x, y){
    if(currentLevelTheme().name !== "Mountain Stick") return null;
    return mountains.find(m => m.x === x && m.y === y);
  }

  function getMountainMovementCost(x, y){
    const mountain = isOnMountain(x, y);
    return mountain ? mountain.height : 1;  // Mountains cost their height to traverse
  }

  
  // Check if player stepped on banana
  function checkBananaSlip(){
    if(currentLevelTheme().name !== "Banana Stick") return;
    
    const banana = bananas.find(b => b.x === game.playerX && b.y === game.playerY);
    if(banana){
      // Slip in random direction 2-4 squares
      const distance = randInt(2, 4);
      const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      const dir = dirs[randInt(0, 3)];
      
      let newX = game.playerX;
      let newY = game.playerY;
      
      for(let i = 0; i < distance; i++){
        newX = clamp(newX + dir.dx, 0, GRID_W - 1);
        newY = clamp(newY + dir.dy, 0, GRID_H - 1);
      }
      
      game.playerX = newX;
      game.playerY = newY;
      
      logEvent("slip", `Slipped on banana! Slid ${distance} squares!`);
      setHud("BANANA SLIP!");
      beep(400, 0.15, "sine", 0.2);
      
      // Remove banana
      bananas = bananas.filter(b => b !== banana);
    }
  }

  // Check monkey collision
  function checkMonkeyCollision(){
    if(currentLevelTheme().name !== "Banana Stick" || !monkey.active) return;
    
    if(monkey.x === game.playerX && monkey.y === game.playerY){
      if(game.carry.length > 0){
        // Drop all sticks
        game.carry.forEach(stick => {
          const pos = randomEmptyTile();
          stick.x = pos.x;
          stick.y = pos.y;
          game.sticks.push(stick);
        });
        game.carry = [];
        logEvent("monkey", "Monkey stole your sticks!");
        setHud("MONKEY STOLE STICKS!");
        beep(200, 0.2, "sawtooth", 0.3);
      } else {
        // No sticks = die
        takeDamage();
        logEvent("death", "Monkey got you!");
      }
    }
  }

  
  // Mountain blocking (for Mountain Stick)
  function canMoveToSquare(x, y, actionsAvailable){
    if(currentLevelTheme().name !== "Mountain Stick") return true;
    
    const mountain = mountains.find(m => m.x === x && m.y === y);
    if(mountain){
      // Need mountain.height actions to move onto mountain
      if(actionsAvailable < mountain.height){
        setHud(`Need ${mountain.height} actions for that mountain!`);
        beep(300, 0.1, "sawtooth", 0.2);
        return false;
      }
    }
    return true;
  }

  // Consume actions when moving onto mountain
  function consumeMountainActions(x, y){
    if(currentLevelTheme().name !== "Mountain Stick") return 1;
    
    const mountain = mountains.find(m => m.x === x && m.y === y);
    if(mountain){
      logEvent("climb", `Climbed mountain (height ${mountain.height})!`);
      return mountain.height;  // Costs mountain.height actions
    }
    return 1;  // Normal squares cost 1 action
  }

  function updateMonkeys(){
    const theme = currentLevelTheme().name;
    if(theme !== "Banana Stick" && theme !== "Victory Stick") return;
    if(monkeys.length === 0) return;
    
    // Don't update monkeys during stick/monster battles
    if(game.pendingMonster || game.inputLocked) return;
    
    monkeys.forEach(monkey => {
      // Decrement cooldown timer
      if(monkey.cooldown > 0){
        monkey.cooldown--;
      }
      
      // Calculate distance to player (Manhattan distance)
      const dx = Math.abs(monkey.x - game.playerX);
      const dy = Math.abs(monkey.y - game.playerY);
      const distance = dx + dy;
      
      // Get agitated if player is within 3 squares (gives ~3-4 seconds warning)
      const wasAgitated = monkey.agitated;
      monkey.agitated = (distance <= 3);
      
      if (monkey.agitated && !wasAgitated){
        // Just became agitated - make monkey sounds!
        logEvent("monkey", "üêí OOK OOK OOK! Monkey is angry! GET AWAY!");
        setHud("‚ö†Ô∏è MONKEY ANGRY - MOVE AWAY!");
        // Monkey screeching sounds
        beep(250, 0.08, "sawtooth", 0.25);
        setTimeout(() => beep(350, 0.08, "sawtooth", 0.22), 80);
        setTimeout(() => beep(280, 0.08, "sawtooth", 0.2), 160);
        setTimeout(() => beep(320, 0.1, "sawtooth", 0.18), 240);
        
        // Initialize warning sound timer
        monkey.warningSoundTimer = 0;
      }
      
      if (!monkey.agitated && wasAgitated){
        // Lost interest - just log it, don't move player
        logEvent("monkey", "üêí Monkey calmed down.");
      }
      
      // Play warning sounds while agitated
      if (monkey.agitated){
        if (!monkey.warningSoundTimer) monkey.warningSoundTimer = 0;
        monkey.warningSoundTimer++;
        
        // Play warning sound every 70 frames (~1.2 seconds) - frequent warnings
        if (monkey.warningSoundTimer % 70 === 0){
          beep(300, 0.06, "sawtooth", 0.15);
          setTimeout(() => beep(350, 0.06, "sawtooth", 0.12), 60);
        }
      }
      
      // Check if monkey is on a banana - occasionally eat it
      const onBanana = bananas.find(b => b.x === monkey.x && b.y === monkey.y);
      if (onBanana && Math.random() < 0.05){ // Reduced chance
        // Eat the banana!
        bananas = bananas.filter(b => b !== onBanana);
        logEvent("monkey", "üêí Monkey ate a banana!");
        beep(400, 0.05, "sine", 0.08);
        beep(500, 0.05, "sine", 0.06);
        // Don't move this turn, just eat
        monkey.moveTimer = 0; // Reset timer
        return;
      }
      
      // Increment move timer
      monkey.moveTimer++;
      
      // Determine move speed based on agitation - SLOWER when agitated for warning time
      const moveInterval = monkey.agitated ? 90 : 120; // Agitated: ~1.5s, Calm: ~2s
      
      // Only move when timer reaches interval
      if (monkey.moveTimer < moveInterval){
        return; // Not time to move yet
      }
      
      // Reset timer
      monkey.moveTimer = 0;
      
      if (monkey.agitated){
        // When agitated, move one square toward player
        const dirs = [];
        
        if (monkey.x < game.playerX && monkey.x < GRID_W - 1) dirs.push({dx: 1, dy: 0});
        if (monkey.x > game.playerX && monkey.x > 0) dirs.push({dx: -1, dy: 0});
        if (monkey.y < game.playerY && monkey.y < GRID_H - 1) dirs.push({dx: 0, dy: 1});
        if (monkey.y > game.playerY && monkey.y > 0) dirs.push({dx: 0, dy: -1});
        
        if (dirs.length > 0){
          const dir = dirs[randInt(0, dirs.length - 1)];
          monkey.x = clamp(monkey.x + dir.dx, 0, GRID_W - 1);
          monkey.y = clamp(monkey.y + dir.dy, 0, GRID_H - 1);
        }
      } else {
        // When calm, wander randomly around the board
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        const newX = clamp(monkey.x + dir.dx, 0, GRID_W - 1);
        const newY = clamp(monkey.y + dir.dy, 0, GRID_H - 1);
        monkey.x = newX;
        monkey.y = newY;
      }
      
      // Check if this monkey caught player - AUTOMATIC BATTLE!
      if(monkey.x === game.playerX && monkey.y === game.playerY){
        // Mark this monkey as having encountered player (with cooldown check)
        if(!monkey.battling && !monkey.cooldown){
          monkey.battling = true;
          monkey.cooldown = 180; // 3 second cooldown before can battle again
          
          if(game.carry.length > 0){
            // Monkey takes sticks and moves away
            game.carry.forEach(stick => {
              const pos = randomEmptyTile();
              stick.x = pos.x;
              stick.y = pos.y;
              game.sticks.push(stick);
            });
            game.carry = [];
            logEvent("monkey", "üêí MONKEY STOLE YOUR STICKS!");
            setHud("STICKS STOLEN!");
            // Dramatic descending sound
            beep(600, 0.15, "sawtooth", 0.35);
            setTimeout(() => beep(400, 0.15, "sawtooth", 0.35), 100);
            setTimeout(() => beep(200, 0.2, "sawtooth", 0.4), 200);
            
            // Move monkey away
            const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
            for(let i = 0; i < 3; i++){
              const dir = dirs[randInt(0, 3)];
              monkey.x = clamp(monkey.x + dir.dx, 0, GRID_W - 1);
              monkey.y = clamp(monkey.y + dir.dy, 0, GRID_H - 1);
            }
            monkey.battling = false;
            monkey.agitated = false;
            
            updateUI();
          } else {
            // AUTOMATIC BATTLE! Player has advantage (0-2 = lose, 3-5 = win)
            const roll = randInt(0, 5);
            logEvent("roll", `üé≤ Auto-rolled ${roll} vs Monkey!`);
            
            if(roll <= 2){
              // LOSE (0-2) - monkey takes a life and moves away
              game.lives--;
              logEvent("death", "üêí Monkey wins! Lost a life!");
              setHud("MONKEY WINS!");
              
              // Dramatic defeat sound - lower, sadder notes
              beep(400, 0.15, "sawtooth", 0.4);
              setTimeout(() => beep(300, 0.15, "sawtooth", 0.45), 120);
              setTimeout(() => beep(200, 0.18, "sawtooth", 0.5), 240);
              setTimeout(() => beep(150, 0.2, "sawtooth", 0.55), 380);
              setTimeout(() => beep(100, 0.25, "sawtooth", 0.6), 540);
              
              // Move monkey away
              const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
              for(let i = 0; i < 3; i++){
                const dir = dirs[randInt(0, 3)];
                monkey.x = clamp(monkey.x + dir.dx, 0, GRID_W - 1);
                monkey.y = clamp(monkey.y + dir.dy, 0, GRID_H - 1);
              }
              monkey.battling = false;
              monkey.agitated = false;
              
              // 3-5 second pause with warning before monkey can attack again
              const pauseTime = randInt(3000, 5000);
              game.inputLocked = true;
              logEvent("warning", "‚ö†Ô∏è MOVE AWAY! Monkey will attack again soon!");
              setHud("‚ö†Ô∏è MOVE NOW!");
              
              // DRAMATIC URGENT WARNING SOUND - GET OUT OF THERE!
              beep(800, 0.1, "square", 0.5);
              setTimeout(() => beep(600, 0.1, "square", 0.5), 100);
              setTimeout(() => beep(800, 0.1, "square", 0.5), 200);
              setTimeout(() => beep(600, 0.1, "square", 0.5), 300);
              setTimeout(() => beep(900, 0.15, "square", 0.6), 400);
              setTimeout(() => beep(500, 0.15, "square", 0.6), 550);
              setTimeout(() => beep(1000, 0.2, "square", 0.7), 700);
              
              setTimeout(() => {
                game.inputLocked = false;
                logEvent("warning", "Monkey can attack again - stay alert!");
              }, pauseTime);
              
              if(game.lives <= 0){
                gameOver();
              } else {
                updateUI();
              }
            } else {
              // WIN (3-5) - player has advantage!
              const funMessages = [
                "üçå Monkey has been MASHED!",
                "üçå Monkey SQUASHED!",
                "üçå Monkey goes BANANAS... and loses!",
                "üçå Monkey DEFEATED!",
                "üçå Monkey MUSHED!"
              ];
              const msg = funMessages[randInt(0, funMessages.length - 1)];
              
              // BANANA BOOST! Double carry capacity
              bananaMode = true;
              
              logEvent("victory", "üçå BANANA BUNDLE is BORN! üçå");
              logEvent("info", "üí™ You can now carry TWICE the sticks!");
              logEvent("info", "üéâ Lasts until you deposit at the hole!");
              setHud("üçå BANANA BUNDLE! üçå");
              
              // Remove monkey
              const idx = monkeys.indexOf(monkey);
              if(idx > -1) monkeys.splice(idx, 1);
              
              // FUN CELEBRATORY TRANSFORMATION MUSIC!
              beep(400, 0.08, "sine", 0.25);
              setTimeout(() => beep(500, 0.08, "sine", 0.25), 60);
              setTimeout(() => beep(600, 0.08, "sine", 0.3), 120);
              setTimeout(() => beep(700, 0.08, "sine", 0.3), 180);
              setTimeout(() => beep(800, 0.1, "sine", 0.35), 240);
              setTimeout(() => beep(900, 0.1, "sine", 0.35), 310);
              setTimeout(() => beep(1000, 0.12, "sine", 0.4), 380);
              setTimeout(() => beep(1200, 0.12, "sine", 0.4), 460);
              // Extra celebration burst!
              setTimeout(() => beep(800, 0.08, "sine", 0.3), 550);
              setTimeout(() => beep(1000, 0.08, "sine", 0.3), 610);
              setTimeout(() => beep(1200, 0.1, "sine", 0.35), 670);
              setTimeout(() => beep(1400, 0.12, "sine", 0.4), 740);
              
              updateUI();
            }
          }
        }
      }
    });
  }

  
  function drawSnakes(){
    ctx.save();
    for (let s of snakes){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const so = Math.sin(s.slither);
      const sp = Math.sin(s.slither + Math.PI * 0.5);
      
      // Dark body outline
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x - 14, y + so * 2);
      ctx.bezierCurveTo(x - 10, y - so * 3, x - 5, y + sp * 2, x, y);
      ctx.bezierCurveTo(x + 5, y - sp * 2, x + 10, y + so * 3, x + 14, y - so * 2);
      ctx.stroke();
      
      // Green body
      ctx.strokeStyle = '#39ff95';
      ctx.lineWidth = 3.5;
      ctx.beginPath();
      ctx.moveTo(x - 14, y + so * 2);
      ctx.bezierCurveTo(x - 10, y - so * 3, x - 5, y + sp * 2, x, y);
      ctx.bezierCurveTo(x + 5, y - sp * 2, x + 10, y + so * 3, x + 14, y - so * 2);
      ctx.stroke();
      
      // Head
      ctx.save();
      ctx.translate(x + 14, y - so * 2);
      ctx.fillStyle = '#39ff95';
      ctx.strokeStyle = '#0a2414';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(5, 0);
      ctx.lineTo(0, 4);
      ctx.lineTo(-3, 0);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Red eyes
      ctx.fillStyle = '#ff1f3a';
      ctx.beginPath();
      ctx.arc(1, -1.5, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1, 1.5, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Tongue (flicks)
      if (Math.sin(s.slither * 3) > 0.3){
        ctx.strokeStyle = '#ff5a6a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(7, -1.5);
        ctx.moveTo(5, 0);
        ctx.lineTo(7, 1.5);
        ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();
  }

  function drawMountains(){
    const theme = currentLevelTheme().name;
    if(theme !== "Mountain Stick" && theme !== "Victory Stick") return;
    if(mountains.length === 0) return;
    
    mountains.forEach(m => {
      const cx = m.x * TILE + TILE/2;
      const cy = m.y * TILE + TILE/2;
      
      // Check if player is currently on this mountain
      const isOnThisMountain = game.mountainTraversal && 
                               game.mountainTraversal.x === m.x && 
                               game.mountainTraversal.y === m.y;
      
      ctx.save();
      
      // Highlight if player is on this mountain - brown theme
      if (isOnThisMountain){
        ctx.fillStyle = "rgba(139, 115, 85, 0.4)";
        ctx.fillRect(m.x * TILE, m.y * TILE, TILE, TILE);
      }
      
      // Mountain triangle (brown)
      ctx.fillStyle = "#5c4a3a";
      ctx.strokeStyle = "#8b7355";
      ctx.lineWidth = 2;
      
      ctx.beginPath();
      ctx.moveTo(cx, cy - TILE*0.4);  // peak
      ctx.lineTo(cx - TILE*0.4, cy + TILE*0.3);  // bottom left
      ctx.lineTo(cx + TILE*0.4, cy + TILE*0.3);  // bottom right
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Snow cap on peak (white triangle)
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.moveTo(cx, cy - TILE*0.4);  // peak
      ctx.lineTo(cx - TILE*0.15, cy - TILE*0.15);  // left
      ctx.lineTo(cx + TILE*0.15, cy - TILE*0.15);  // right
      ctx.closePath();
      ctx.fill();
      
      // Height number - show remaining if on this mountain, otherwise show total
      if (isOnThisMountain){
        // Show remaining actions needed - white with brown outline for visibility
        ctx.strokeStyle = "#6B4423";
        ctx.lineWidth = 4;
        ctx.font = "bold 18px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.strokeText(game.mountainTraversal.remaining, cx, cy + 2);
        ctx.fillStyle = "#FFFFFF";
        ctx.fillText(game.mountainTraversal.remaining, cx, cy + 2);
        
        // Add "CLIMB" text above - raised higher to not block number
        ctx.font = "bold 11px monospace";
        ctx.strokeStyle = "#3d2f1f";
        ctx.lineWidth = 3;
        ctx.strokeText("CLIMB", cx, cy - TILE*0.35);
        ctx.fillStyle = "#FFE4B5";
        ctx.fillText("CLIMB", cx, cy - TILE*0.35);
      } else {
        // Show original height
        ctx.fillStyle = "#a0826d";
        ctx.font = "bold 12px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(m.height, cx, cy + 2);
      }
      
      ctx.restore();
    });
  }

  function drawBananas(){
    const theme = currentLevelTheme().name;
    if(theme !== "Banana Stick" && theme !== "Victory Stick") return;
    if(bananas.length === 0) return; // Don't draw if no bananas
    
    const time = Date.now() * 0.001;
    
    bananas.forEach(b => {
      const cx = b.x * TILE + TILE/2;
      const cy = b.y * TILE + TILE/2;
      
      ctx.save();
      ctx.translate(cx, cy);
      
      // Fun wiggle rotation - each banana wiggles uniquely
      const wiggle = Math.sin(time * 2 + b.x + b.y) * 0.15; // Gentle back-and-forth
      ctx.rotate(wiggle);
      
      // Banana emoji
      ctx.font = "20px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("üçå", 0, 0);
      
      // STRONGER color overlay to dull the bananas more
      ctx.globalCompositeOperation = 'multiply';
      ctx.globalAlpha = 0.5; // Increased from 0.25 to 0.5
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
      gradient.addColorStop(0, 'rgba(100, 150, 30, 0.6)'); // Darker green overlay
      gradient.addColorStop(0.5, 'rgba(154, 205, 50, 0.5)'); // Yellow-green
      gradient.addColorStop(1, 'rgba(180, 180, 60, 0.3)'); // Muted yellow-brown
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
      
      ctx.restore();
    });
  }

  function drawMonkeys(){
    const theme = currentLevelTheme().name;
    if(theme !== "Banana Stick" && theme !== "Victory Stick") return;
    if(monkeys.length === 0) return;
    
    const time = Date.now() * 0.001;
    
    monkeys.forEach(monkey => {
      // Animation values
      const bob = Math.sin(time * 2 + monkey.x + monkey.y) * 2; // Unique bob per monkey
      
      const cx = monkey.x * TILE + TILE/2;
      const cy = monkey.y * TILE + TILE/2 + bob;
      
      ctx.save();
      
      // If agitated, show yellow pulsing glow (banana theme)
      if (monkey.agitated){
      const pulse = (Math.sin(time * 8) + 1) / 2;
      const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, TILE * 0.9);
      gradient.addColorStop(0, `rgba(255,215,0,${0.4 + pulse * 0.4})`); // Gold warning
      gradient.addColorStop(1, "rgba(255,215,0,0)");
      ctx.fillStyle = gradient;
      ctx.fillRect(monkey.x * TILE, monkey.y * TILE, TILE, TILE);
      
      // Angry marks when agitated - yellow/orange
      ctx.strokeStyle = `rgba(255,165,0,${0.7 + pulse * 0.3})`; // Orange
      ctx.lineWidth = 2;
      const angleOffset = time * 4;
      for (let i = 0; i < 3; i++){
        const angle = angleOffset + (i * Math.PI * 2 / 3);
        const x1 = cx + Math.cos(angle) * TILE * 0.4;
        const y1 = cy + Math.sin(angle) * TILE * 0.4;
        const x2 = cx + Math.cos(angle) * TILE * 0.55;
        const y2 = cy + Math.sin(angle) * TILE * 0.55;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
    
    // Draw custom monkey head - LARGER SIZE
    // Head (brown circle)
    ctx.fillStyle = "#8B6914";
    ctx.beginPath();
    ctx.arc(cx, cy, TILE * 0.45, 0, Math.PI * 2);
    ctx.fill();
    
    // Face/muzzle (tan/beige oval)
    ctx.fillStyle = "#D2B48C";
    ctx.beginPath();
    ctx.ellipse(cx, cy + TILE * 0.1, TILE * 0.28, TILE * 0.26, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes (animated blink)
    const blink = Math.sin(time * 3) > 0.95 ? 0.3 : 1; // Occasional blink
    ctx.fillStyle = monkey.agitated ? "#FFD700" : "#000000"; // Yellow eyes when agitated
    ctx.beginPath();
    ctx.ellipse(cx - TILE * 0.15, cy - TILE * 0.06, TILE * 0.06, TILE * 0.08 * blink, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(cx + TILE * 0.15, cy - TILE * 0.06, TILE * 0.06, TILE * 0.08 * blink, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eye highlights
    if (blink > 0.5){
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(cx - TILE * 0.13, cy - TILE * 0.1, TILE * 0.025, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(cx + TILE * 0.17, cy - TILE * 0.1, TILE * 0.025, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Nose (small brown dot)
    ctx.fillStyle = "#654321";
    ctx.beginPath();
    ctx.arc(cx, cy + TILE * 0.06, TILE * 0.05, 0, Math.PI * 2);
    ctx.fill();
    
    // Mouth
    ctx.strokeStyle = "#654321";
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (monkey.agitated){
      // Angry mouth - frown
      ctx.arc(cx, cy + TILE * 0.23, TILE * 0.13, 0.2, Math.PI - 0.2);
    } else {
      // Happy mouth - smile
      ctx.arc(cx, cy + TILE * 0.06, TILE * 0.15, 0.3, Math.PI - 0.3);
    }
    ctx.stroke();
    
    // Ears
    ctx.fillStyle = "#8B6914";
    ctx.beginPath();
    ctx.arc(cx - TILE * 0.41, cy - TILE * 0.13, TILE * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + TILE * 0.41, cy - TILE * 0.13, TILE * 0.15, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner ears (lighter)
    ctx.fillStyle = "#D2B48C";
    ctx.beginPath();
    ctx.arc(cx - TILE * 0.41, cy - TILE * 0.13, TILE * 0.09, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(cx + TILE * 0.41, cy - TILE * 0.13, TILE * 0.09, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    }); // End forEach monkey
  }


  // ================================================================
  // RAM - Mountain Stick
  // ================================================================
  
  function initRams(){
    rams = [];
    const count = randInt(3, 5);
    console.log('üêè Spawning', count, 'rams');
    for(let i = 0; i < count; i++){
      const pos = randomEmptyTile();
      rams.push({ 
        x: pos.x, 
        y: pos.y, 
        moveTimer: randInt(0, 100) // Stagger their movement
      });
    }
    console.log('Rams:', rams);
  }
  
  function updateRams(){
    const theme = currentLevelTheme().name;
    if(theme !== "Mountain Stick" && theme !== "Victory Stick") return;
    if(rams.length === 0) return;
    
    // Don't update during battles
    if(game.pendingMonster || game.inputLocked) return;
    
    rams.forEach(ram => {
      // Check if player is within 1 square - rams get aggressive!
      const dx = Math.abs(ram.x - game.playerX);
      const dy = Math.abs(ram.y - game.playerY);
      const distance = dx + dy;
      
      // If within 1 square, DEFINITELY charge!
      if(distance === 1){
        // Ram charges immediately towards player
        const dirs = [];
        if (ram.x < game.playerX) dirs.push({dx: 1, dy: 0});
        if (ram.x > game.playerX) dirs.push({dx: -1, dy: 0});
        if (ram.y < game.playerY) dirs.push({dx: 0, dy: 1});
        if (ram.y > game.playerY) dirs.push({dx: 0, dy: -1});
        
        if(dirs.length > 0){
          const dir = dirs[randInt(0, dirs.length - 1)];
          ram.x = clamp(ram.x + dir.dx, 0, GRID_W - 1);
          ram.y = clamp(ram.y + dir.dy, 0, GRID_H - 1);
        }
      } else {
        // Normal wandering behavior
        // Increment move timer
        ram.moveTimer++;
        
        // Move every 100 frames (~1.6 seconds)
        if (ram.moveTimer < 100){
          return;
        }
        
        // Reset timer
        ram.moveTimer = 0;
        
        // Random wander
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        ram.x = clamp(ram.x + dir.dx, 0, GRID_W - 1);
        ram.y = clamp(ram.y + dir.dy, 0, GRID_H - 1);
      }
      
      // Check if ram hit the player
      if(ram.x === game.playerX && ram.y === game.playerY){
        // Ram sound - low thumping
        beep(150, 0.12, "sawtooth", 0.3);
        setTimeout(() => beep(180, 0.1, "sawtooth", 0.25), 80);
        
        if (game.carry.length > 0){
          // Scatter all sticks!
          game.carry.forEach(stick => {
            const pos = randomEmptyTile();
            stick.x = pos.x;
            stick.y = pos.y;
            game.sticks.push(stick);
          });
          const scattered = game.carry.length;
          game.carry = [];
          logEvent("ram", `üêè Ram scattered ${scattered} stick(s)!`);
          setHud("RAM ATTACK!");
          updateUI();
        } else {
          // Knock player 3-5 squares in random direction (more aggressive!)
          const knockDist = randInt(3, 5);
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const knockDir = dirs[randInt(0, 3)];
          
          for (let i = 0; i < knockDist; i++){
            game.playerX = clamp(game.playerX + knockDir.dx, 0, GRID_W - 1);
            game.playerY = clamp(game.playerY + knockDir.dy, 0, GRID_H - 1);
          }
          logEvent("ram", `üêè Ram knocked you ${knockDist} squares!`);
          setHud("KNOCKED BACK!");
          updateUI();
        }
      }
    });
  }
  
  function drawMountainClouds(){
    const theme = currentLevelTheme().name;
    if(theme !== "Mountain Stick" && theme !== "Victory Stick") return;
    if(mountainClouds.length === 0) return;
    
    // Update cloud positions
    mountainClouds.forEach(cloud => {
      cloud.x += cloud.drift;
      if(cloud.x < -0.5) cloud.x = GRID_W;
      if(cloud.x > GRID_W) cloud.x = -0.5;
    });
    
    // Draw clouds - same style as Sky Stick
    mountainClouds.forEach(cloud => {
      const cx = cloud.x * TILE + TILE/2;
      const cy = cloud.y * TILE + TILE/2;
      
      ctx.save();
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      
      // 5 overlapping circles for fluffy cloud
      ctx.beginPath();
      ctx.arc(cx - TILE * 0.3, cy + TILE * 0.05, TILE * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx + TILE * 0.3, cy + TILE * 0.05, TILE * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx - TILE * 0.1, cy - TILE * 0.05, TILE * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx + TILE * 0.15, cy - TILE * 0.05, TILE * 0.28, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(cx, cy - TILE * 0.2, TILE * 0.26, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
  }
  
  function drawRams(){
    const theme = currentLevelTheme().name;
    if(theme !== "Mountain Stick" && theme !== "Victory Stick") return;
    if(rams.length === 0) return;
    
    const time = Date.now() * 0.001;
    
    rams.forEach(ram => {
      const bob = Math.sin(time * 1.8 + ram.x + ram.y) * 1.5;
      
      const cx = ram.x * TILE + TILE/2;
      const cy = ram.y * TILE + TILE/2 + bob;
      
      ctx.save();
      
      // Goat emoji üêê
      ctx.font = "28px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("üêê", cx, cy);
      
      // Add semi-transparent brown overlay to dull the brightness
      ctx.fillStyle = "rgba(107, 85, 72, 0.25)"; // Brown with transparency
      ctx.beginPath();
      ctx.arc(cx, cy, TILE * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
  }


  // ================================================================
  // FREEZE ZONES - Ice Stick
  // ================================================================
  let freezeTiles = [];
  let freezeWarningTimer = 0;
  const FREEZE_WARNING_TIME = 150; // 2.5 seconds like fire
  
  function initFreezeTiles(){
    freezeTiles = [];
    const num = randInt(10, 14);
    for (let i = 0; i < num; i++){
      freezeTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        shimmer: Math.random() * Math.PI * 2
      });
    }
  }
  
  let freezeChimeInterval = null;
  let windSoundInterval = null;
  
  function updateFreezeTiles(){
    // Animate shimmer + slow drift
    for (let f of freezeTiles){
      f.shimmer = (f.shimmer + 0.08) % (Math.PI * 2);
      
      // Slow drift
      if (!f.driftTimer) f.driftTimer = randInt(120, 180);
      f.driftTimer--;
      if (f.driftTimer <= 0){
        f.driftTimer = randInt(120, 180); // 2-3 seconds
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        f.x = clamp(f.x + dir.dx, 0, GRID_W - 1);
        f.y = clamp(f.y + dir.dy, 0, GRID_H - 1);
      }
    }
    
    const onFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
    if (onFreeze){
      freezeWarningTimer++;
      
      // Start continuous chime
      if (!freezeChimeInterval){
        freezeChimeInterval = setInterval(() => {
          if (freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY)){
            // LOUD ice warning
            beep(900, 0.15, "sine", 0.10);
          }
        }, 350);
      }
      
      if (freezeWarningTimer >= FREEZE_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          freezeWarningTimer = 0;
        } else if (activeShield > 0){
          freezeWarningTimer = 0;
          logEvent("info", "Shield blocked freeze!");
          setHud("SHIELD!");
        } else {
          game.lives--;
          freezeWarningTimer = 0;
          logEvent("bad", "Frozen! -1 life");
          setHud("FROZEN!");
          beep(400, 0.12, "sine", 0.08);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
        }
      } else if (freezeWarningTimer === 60){
        logEvent("warn", "Freezing! Move!");
        setHud("FREEZING!");
      }
    } else {
      freezeWarningTimer = 0;
      if (freezeChimeInterval){
        clearInterval(freezeChimeInterval);
        freezeChimeInterval = null;
      }
    }
  }
  
  function startIceWindSound(){
    if (!windSoundInterval){
      // Removed wind sound - was too distracting
      windSoundInterval = true; // Just mark as started
    }
  }
  
  function stopIceWindSound(){
    if (windSoundInterval){
      clearInterval(windSoundInterval);
      windSoundInterval = null;
    }
  }
  
  function drawFreezeTiles(){
    ctx.save();
    for (let f of freezeTiles){
      const x = f.x * TILE + TILE / 2;
      const y = f.y * TILE + TILE / 2;
      const pulse = Math.sin(f.shimmer) * 0.5 + 0.5;
      
      // Icy base glow
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
      grad.addColorStop(0, 'rgba(200,230,255,' + (0.6 + pulse * 0.2) + ')');
      grad.addColorStop(1, 'rgba(100,180,230,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Ice crystal spikes (6 directions)
      ctx.strokeStyle = 'rgba(255,255,255,' + (0.7 + pulse * 0.3) + ')';
      ctx.lineWidth = 2;
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 4 + pulse * 4;
      for (let i = 0; i < 6; i++){
        const angle = (Math.PI / 3) * i + f.shimmer;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      
      // Center crystal
      ctx.fillStyle = 'rgba(200,230,255,' + (0.8 + pulse * 0.2) + ')';
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Warning indicator
    if (freezeWarningTimer > 0){
      const playerOnFreeze = freezeTiles.some(f => f.x === game.playerX && f.y === game.playerY);
      if (playerOnFreeze){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(freezeWarningTimer * 0.3) * 0.5 + 0.5;
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#38bdf8';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
    
    ctx.restore();
  }

  // ================================================================
  // SHADOW MONSTERS - Glow Stick (roaming killers!)
  // ================================================================
  let shadowMonsters = [];
  
  function initShadowMonsters(){
    shadowMonsters = [];
    const num = randInt(1, 3);
    for (let i = 0; i < num; i++){
      let x, y, attempts = 0;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
        attempts++;
      } while (attempts < 50 && (
        (x === game.playerX && y === game.playerY) ||
        (x === game.holeX && y === game.holeY)
      ));
      shadowMonsters.push({
        x, y,
        pulse: Math.random() * Math.PI * 2,
        moveTimer: randInt(60, 120)
      });
    }
  }
  
  function updateShadowMonsters(){
    if (game.pendingMonster) return;
    
    for (let i = shadowMonsters.length - 1; i >= 0; i--){
      const m = shadowMonsters[i];
      m.pulse = (m.pulse + 0.1) % (Math.PI * 2);
      
      m.moveTimer--;
      if (m.moveTimer <= 0){
        m.moveTimer = randInt(60, 120);
        
        // 60% chance to chase player, 40% random movement
        if (Math.random() < 0.6){
          // Chase player
          const dx = game.playerX - m.x;
          const dy = game.playerY - m.y;
          if (Math.abs(dx) > Math.abs(dy)){
            m.x = clamp(m.x + Math.sign(dx), 0, GRID_W - 1);
          } else {
            m.y = clamp(m.y + Math.sign(dy), 0, GRID_H - 1);
          }
        } else {
          // Random roaming
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          m.x = clamp(m.x + dir.dx, 0, GRID_W - 1);
          m.y = clamp(m.y + dir.dy, 0, GRID_H - 1);
        }
      }
      
      if (m.x === game.playerX && m.y === game.playerY &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield blocked shadow!");
          setHud("SHIELD!");
          shadowMonsters.splice(i, 1);
        } else {
          game.lives--;
          logEvent("bad", "Shadow monster! -1 life");
          setHud("SHADOW KILL!");
          // Scary death sound
          beep(100, 0.15, "sawtooth", 0.12);
          setTimeout(() => beep(60, 0.20, "sawtooth", 0.15), 80);
          setTimeout(() => beep(40, 0.25, "sawtooth", 0.18), 160);
          spawnSparks(game.playerX, game.playerY, 22, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          shadowMonsters.splice(i, 1);
        }
      }
    }
  }
  
  function drawShadowMonsters(){
    ctx.save();
    for (let m of shadowMonsters){
      const x = m.x * TILE + TILE / 2;
      const y = m.y * TILE + TILE / 2;
      const pulse = Math.sin(m.pulse) * 0.5 + 0.5;
      
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, 10);
      grad.addColorStop(0, 'rgba(80,40,0,0.8)');
      grad.addColorStop(1, 'rgba(40,20,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, 10, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.fillStyle = '#ffb347';
      ctx.shadowColor = '#ffb347';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(x - 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x + 3, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ================================================================
  // SNOWMAN - Ice Stick chasing enemy
  // ================================================================
  let snowman = null;
  
  function initSnowman(){
    let x, y;
    do {
      x = randInt(0, GRID_W - 1);
      y = randInt(0, GRID_H - 1);
    } while ((x === game.playerX && y === game.playerY) || (x === game.holeX && y === game.holeY));
    snowman = { x, y, moveTimer: 90, bobTimer: 0 };
  }
  
  function updateSnowman(){
    if (!snowman || game.pendingMonster) return;
    snowman.bobTimer = (snowman.bobTimer + 0.1) % (Math.PI * 2);
    snowman.moveTimer--;
    if (snowman.moveTimer <= 0){
      snowman.moveTimer = 90;
      const dx = game.playerX - snowman.x;
      const dy = game.playerY - snowman.y;
      if (Math.abs(dx) > Math.abs(dy)){
        snowman.x = clamp(snowman.x + Math.sign(dx), 0, GRID_W - 1);
      } else {
        snowman.y = clamp(snowman.y + Math.sign(dy), 0, GRID_H - 1);
      }
    }
    if (snowman.x === game.playerX && snowman.y === game.playerY && !(game.playerX === game.holeX && game.playerY === game.holeY)){
      if (activeShield > 0){
        logEvent("info", "Shield melted snowman!");
        setHud("SHIELD!");
        snowman = null;
        initSnowman();
      } else if (game.carry.length > 0){
        const stolen = game.carry.length;
        game.carry = [];
        logEvent("bad", "Snowman stole " + stolen + " sticks!");
        setHud("SNOWMAN!");
        beep(300, 0.12, "sine", 0.08);
        spawnSparks(game.playerX, game.playerY, 18, true);
        updateUI();
        snowman = null;
        initSnowman();
      } else {
        game.lives--;
        logEvent("bad", "Frozen by snowman! -1 life");
        setHud("SNOWMAN!");
        
        // Dramatic frozen death sound - descending doom
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = "triangle";
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
        gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.6);
        
        spawnSparks(game.playerX, game.playerY, 30, true);
        if (game.lives <= 0) gameOver();
        else updateUI();
        snowman = null;
        initSnowman();
      }
    }
  }
  
  function drawSnowman(){
    if (!snowman) return;
    const x = snowman.x * TILE + TILE / 2;
    const y = snowman.y * TILE + TILE / 2;
    const bob = Math.sin(snowman.bobTimer) * 1.5;
    ctx.save();
    ctx.translate(x, y + bob);
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = "#001f3f";
    ctx.beginPath();
    ctx.ellipse(0, 15, 9, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#d0e8ff";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, 6, 7.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -3, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(0, -10.5, 4.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = "#1a1a1a";
    ctx.beginPath();
    ctx.arc(-2.2, -11.2, 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(2.2, -11.2, 1.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#ff6b35";
    ctx.beginPath();
    ctx.moveTo(0, -9.7);
    ctx.lineTo(3.8, -9);
    ctx.lineTo(0, -8.2);
    ctx.fill();
    ctx.strokeStyle = "#8b4513";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-5.2, -1.5);
    ctx.lineTo(-9, -4.5);
    ctx.moveTo(5.2, -1.5);
    ctx.lineTo(9, -4.5);
    ctx.stroke();
    ctx.restore();
  }

  // ================================================================
  // SPIDER WEBS - Spider Stick (sticky traps)
  // ================================================================
  let spiderWebs = [];
  
  function initSpiderWebs(){
    spiderWebs = [];
    const num = randInt(4, 6);
    for (let i = 0; i < num; i++){
      spiderWebs.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        pulse: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSpiderWebs(){
    for (let i = spiderWebs.length - 1; i >= 0; i--){
      const web = spiderWebs[i];
      web.pulse = (web.pulse + 0.05) % (Math.PI * 2);
      
      if (web.x === game.playerX && web.y === game.playerY && 
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield broke through web!");
          setHud("SHIELD!");
          spiderWebs.splice(i, 1); // Remove web
        } else if (!game.webbed){
          // Lose all remaining actions immediately
          const lostActions = game.actions;
          game.actions = 0;
          game.webbed = true;
          
          if (lostActions > 0){
            logEvent("bad", `TRAPPED IN WEB! Lost ${lostActions} actions. Next roll will be halved!`);
            setHud("WEB TRAP!");
            beep(200, 0.10, "sawtooth", 0.06);
          } else {
            logEvent("bad", "Stuck in web! Next roll will be halved!");
            setHud("WEBBED!");
            beep(200, 0.10, "sawtooth", 0.06);
          }
          
          // REMOVE the web after it traps you (single use)
          spiderWebs.splice(i, 1);
          
          updateUI();
        }
      }
    }
  }
  
  function drawSpiderWebs(){
    for (let web of spiderWebs){
      const x = web.x * TILE + TILE / 2;
      const y = web.y * TILE + TILE / 2;
      const pulse = Math.sin(web.pulse) * 0.3 + 0.7;
      
      ctx.save();
      ctx.globalAlpha = 0.4 + pulse * 0.2;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1.5;
      
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI * 2 / 8) * i;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * 10, y + Math.sin(angle) * 10);
        ctx.stroke();
      }
      
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.restore();
    }
  }
  
  // ================================================================
  // SPIDERS - Spider Stick (fast chasers)
  // ================================================================
  let spiders = [];
  
  function initSpiders(){
    spiders = [];
    const num = randInt(2, 3);
    for (let i = 0; i < num; i++){
      let x, y;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
      } while ((x === game.playerX && y === game.playerY) || 
               (x === game.holeX && y === game.holeY) ||
               (snowman && x === snowman.x && y === snowman.y));
      spiders.push({ x, y, moveTimer: 90, legTimer: 0 });
    }
  }
  
  function updateSpiders(){
    if (game.pendingMonster) return;
    
    for (let i = spiders.length - 1; i >= 0; i--){
      const spider = spiders[i];
      spider.legTimer = (spider.legTimer + 0.2) % (Math.PI * 2);
      spider.moveTimer--;
      
      if (spider.moveTimer <= 0){
        spider.moveTimer = 90;
        const dx = game.playerX - spider.x;
        const dy = game.playerY - spider.y;
        if (Math.abs(dx) > Math.abs(dy)){
          spider.x = clamp(spider.x + Math.sign(dx), 0, GRID_W - 1);
        } else {
          spider.y = clamp(spider.y + Math.sign(dy), 0, GRID_W - 1);
        }
      }
      
      if (spider.x === game.playerX && spider.y === game.playerY &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield crushed spider!");
          setHud("SHIELD!");
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        } else if (game.carry.length > 0){
          const stolen = game.carry.length;
          game.carry = [];
          logEvent("bad", "Spider wrapped " + stolen + " sticks!");
          setHud("SPIDER!");
          
          // Spider wrapping sound - quick descending buzz
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(600, audioCtx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.25);
          gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
          osc.start(audioCtx.currentTime);
          osc.stop(audioCtx.currentTime + 0.25);
          
          spawnSparks(game.playerX, game.playerY, 25, true);
          updateUI();
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        } else {
          game.lives--;
          logEvent("bad", "Spider bite! -1 life");
          setHud("SPIDER BITE!");
          
          // Dramatic spider death sound - multi-tone doom chord
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          
          // Low ominous tone
          const osc1 = audioCtx.createOscillator();
          const gain1 = audioCtx.createGain();
          osc1.connect(gain1);
          gain1.connect(audioCtx.destination);
          osc1.type = "sawtooth";
          osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
          osc1.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.5);
          gain1.gain.setValueAtTime(0.2, audioCtx.currentTime);
          gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
          
          // Mid creepy tone
          const osc2 = audioCtx.createOscillator();
          const gain2 = audioCtx.createGain();
          osc2.connect(gain2);
          gain2.connect(audioCtx.destination);
          osc2.type = "square";
          osc2.frequency.setValueAtTime(200, audioCtx.currentTime);
          osc2.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
          gain2.gain.setValueAtTime(0.15, audioCtx.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
          
          // High screech
          const osc3 = audioCtx.createOscillator();
          const gain3 = audioCtx.createGain();
          osc3.connect(gain3);
          gain3.connect(audioCtx.destination);
          osc3.type = "sine";
          osc3.frequency.setValueAtTime(800, audioCtx.currentTime);
          osc3.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
          gain3.gain.setValueAtTime(0.12, audioCtx.currentTime);
          gain3.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
          
          osc1.start(audioCtx.currentTime);
          osc1.stop(audioCtx.currentTime + 0.5);
          osc2.start(audioCtx.currentTime);
          osc2.stop(audioCtx.currentTime + 0.5);
          osc3.start(audioCtx.currentTime);
          osc3.stop(audioCtx.currentTime + 0.3);
          
          spawnSparks(game.playerX, game.playerY, 30, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          spiders.splice(i, 1);
          if (spiders.length === 0) initSpiders();
        }
      }
    }
  }
  
  function drawSpiders(){
    for (let spider of spiders){
      const x = spider.x * TILE + TILE / 2;
      const y = spider.y * TILE + TILE / 2;
      const legWave = Math.sin(spider.legTimer);
      
      ctx.save();
      ctx.translate(x, y);
      
      // 8 animated legs (4 pairs)
      ctx.strokeStyle = "#f0f0f0";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      for (let i = 0; i < 4; i++){
        // Alternate leg movement for walking effect
        const leftPhase = legWave + (i * Math.PI / 2);
        const rightPhase = legWave + (i * Math.PI / 2) + Math.PI;
        const leftWiggle = Math.sin(leftPhase) * 2;
        const rightWiggle = Math.sin(rightPhase) * 2;
        
        // Left legs (bent at joint)
        ctx.beginPath();
        ctx.moveTo(-3, -1 + i);
        ctx.lineTo(-6, -3 + i * 2 + leftWiggle);
        ctx.lineTo(-10, -1 + i * 2.5);
        ctx.stroke();
        
        // Right legs (bent at joint)
        ctx.beginPath();
        ctx.moveTo(3, -1 + i);
        ctx.lineTo(6, -3 + i * 2 + rightWiggle);
        ctx.lineTo(10, -1 + i * 2.5);
        ctx.stroke();
      }
      
      // Body (round, hairy spider)
      ctx.fillStyle = "#1a0d24";
      ctx.strokeStyle = "#8b5cf6";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Add some hair texture
      ctx.strokeStyle = "#4c1d95";
      ctx.lineWidth = 1;
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI * 2 / 8) * i;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 3, Math.sin(angle) * 3);
        ctx.lineTo(Math.cos(angle) * 5, Math.sin(angle) * 5);
        ctx.stroke();
      }
      
      // Head (smaller segment)
      ctx.fillStyle = "#2d1a3d";
      ctx.strokeStyle = "#8b5cf6";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, -6, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Multiple red eyes (spider-like)
      ctx.fillStyle = "#ff0000";
      ctx.shadowColor = "#ff0000";
      ctx.shadowBlur = 3;
      // Top eyes
      ctx.beginPath();
      ctx.arc(-1.5, -7, 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1.5, -7, 0.8, 0, Math.PI * 2);
      ctx.fill();
      // Bottom eyes (smaller)
      ctx.beginPath();
      ctx.arc(-1, -5.5, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1, -5.5, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      ctx.restore();
    }
  }
  
  // ================================================================
  // SKUNKS + STINK CLOUDS - Skunk Stick
  // ================================================================
  let skunks = [];
  let stinkClouds = [];
  
  function initSkunks(){
    skunks = [];
    const num = randInt(2, 3);
    for (let i = 0; i < num; i++){
      let x, y;
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
      } while ((x === game.playerX && y === game.playerY) || 
               (x === game.holeX && y === game.holeY));
      skunks.push({ x, y, moveTimer: 80, sprayTimer: 180, waddle: 0 });
    }
  }
  
  function updateSkunks(){
    if (game.pendingMonster) return;
    
    for (let skunk of skunks){
      skunk.waddle = (skunk.waddle + 0.15) % (Math.PI * 2);
      skunk.moveTimer--;
      skunk.sprayTimer--;
      
      if (skunk.moveTimer <= 0){
        skunk.moveTimer = 80;
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        skunk.x = clamp(skunk.x + dir.dx, 0, GRID_W - 1);
        skunk.y = clamp(skunk.y + dir.dy, 0, GRID_H - 1);
      }
      
      const dx = Math.abs(skunk.x - game.playerX);
      const dy = Math.abs(skunk.y - game.playerY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 4 && skunk.sprayTimer <= 0){
        skunk.sprayTimer = 180;
        stinkClouds.push({
          x: skunk.x, y: skunk.y,
          radius: 0, maxRadius: 3,
          lifetime: 300, pulse: 0, damageTimer: 0
        });
        logEvent("info", "Skunk sprayed! Avoid the cloud!");
        setHud("SKUNK SPRAY!");
        beep(150, 0.08, "sawtooth", 0.05);
      }
    }
    
    for (let i = stinkClouds.length - 1; i >= 0; i--){
      const cloud = stinkClouds[i];
      cloud.pulse = (cloud.pulse + 0.1) % (Math.PI * 2);
      cloud.lifetime--;
      
      if (cloud.radius < cloud.maxRadius){
        cloud.radius += 0.15;
      }
      
      const dx = Math.abs(cloud.x - game.playerX);
      const dy = Math.abs(cloud.y - game.playerY);
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < cloud.radius && !(game.playerX === game.holeX && game.playerY === game.holeY)){
        cloud.damageTimer++;
        if (cloud.damageTimer % 30 === 0){
          beep(300, 0.06, "sine", 0.04);
        }
        if (cloud.damageTimer > 180){
          if (activeShield > 0){
            logEvent("info", "Shield blocked stink!");
            setHud("SHIELD!");
          } else {
            game.lives--;
            logEvent("bad", "Poisoned by stink! -1 life");
            setHud("POISONED!");
            beep(250, 0.15, "sine", 0.10);
            spawnSparks(game.playerX, game.playerY, 22, true);
            if (game.lives <= 0) gameOver();
            else updateUI();
          }
          cloud.damageTimer = 0;
        }
      } else {
        cloud.damageTimer = 0;
      }
      
      if (cloud.lifetime <= 0){
        stinkClouds.splice(i, 1);
      }
    }
  }
  
  function drawSkunks(){
    for (let skunk of skunks){
      const x = skunk.x * TILE + TILE / 2;
      const y = skunk.y * TILE + TILE / 2;
      const waddle = Math.sin(skunk.waddle) * 1;
      
      ctx.save();
      ctx.translate(x, y + waddle);
      
      // Tail (big and fluffy, held up)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.ellipse(-2, -8, 4, 6, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // White stripe on tail
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(-2, -8, 2, 5, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Body (fat oval)
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.ellipse(0, 1, 7, 4.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Two white stripes from head to tail (classic skunk pattern)
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.moveTo(-2, -2);
      ctx.lineTo(-3, 1);
      ctx.lineTo(-2.5, 4);
      ctx.lineTo(-1.5, 4);
      ctx.lineTo(-1, 1);
      ctx.lineTo(-1.5, -2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(2, -2);
      ctx.lineTo(3, 1);
      ctx.lineTo(2.5, 4);
      ctx.lineTo(1.5, 4);
      ctx.lineTo(1, 1);
      ctx.lineTo(1.5, -2);
      ctx.fill();
      
      // Head (small, pointed)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.arc(6, -1, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // White face stripe
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.moveTo(6, -3);
      ctx.lineTo(5.5, 1);
      ctx.lineTo(6.5, 1);
      ctx.lineTo(6, -3);
      ctx.fill();
      
      // Nose
      ctx.fillStyle = "#ff69b4";
      ctx.beginPath();
      ctx.arc(8, -1, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      // Eyes (small black dots)
      ctx.fillStyle = "#1a1a1a";
      ctx.beginPath();
      ctx.arc(7, -2, 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(7, 0, 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Feet (tiny)
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(-4, 3, 2, 1);
      ctx.fillRect(2, 3, 2, 1);
      
      ctx.restore();
    }
  }
  
  function drawStinkClouds(){
    for (let cloud of stinkClouds){
      const x = cloud.x * TILE + TILE / 2;
      const y = cloud.y * TILE + TILE / 2;
      const pulse = Math.sin(cloud.pulse) * 0.2 + 0.8;
      const radius = cloud.radius * TILE;
      
      ctx.save();
      
      // Multiple overlapping smoke puffs for realistic smog
      const puffs = 8;
      for (let i = 0; i < puffs; i++){
        const angle = (Math.PI * 2 / puffs) * i + cloud.pulse;
        const dist = (radius * 0.4) + Math.sin(cloud.pulse + i) * (radius * 0.2);
        const puffX = x + Math.cos(angle) * dist;
        const puffY = y + Math.sin(angle) * dist;
        const puffSize = radius * 0.5 + Math.sin(cloud.pulse * 2 + i) * (radius * 0.1);
        
        ctx.globalAlpha = 0.15 + pulse * 0.1;
        const grad = ctx.createRadialGradient(puffX, puffY, 0, puffX, puffY, puffSize);
        grad.addColorStop(0, 'rgba(150,200,30,0.6)');
        grad.addColorStop(0.4, 'rgba(132,204,22,0.4)');
        grad.addColorStop(1, 'rgba(100,150,10,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Center dense cloud
      ctx.globalAlpha = 0.25 + pulse * 0.15;
      const centerGrad = ctx.createRadialGradient(x, y, 0, x, y, radius * 0.6);
      centerGrad.addColorStop(0, 'rgba(180,220,40,0.7)');
      centerGrad.addColorStop(0.5, 'rgba(132,204,22,0.5)');
      centerGrad.addColorStop(1, 'rgba(100,150,10,0)');
      ctx.fillStyle = centerGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Add some swirly wisps
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = "#a8d944";
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      for (let i = 0; i < 3; i++){
        const angle = (Math.PI * 2 / 3) * i + cloud.pulse * 0.5;
        ctx.beginPath();
        ctx.arc(x + Math.cos(angle) * radius * 0.3, 
                y + Math.sin(angle) * radius * 0.3, 
                radius * 0.4, angle, angle + Math.PI);
        ctx.stroke();
      }
      
      ctx.restore();
    }
  }

  // ================================================================
  // SHARKS - Sea Stick (Frogger-style lane patrol!)
  // ================================================================
  let sharks = [];
  let bubbles = [];
  let scubaDiver = null; // Aesthetic swimming diver
  
  function initSharks(){
    sharks = [];
    const numLanes = 5;
    const laneHeight = Math.floor(GRID_H / numLanes);
    
    for (let i = 0; i < 5; i++){
      const lane = Math.floor(Math.random() * numLanes);
      const y = lane * laneHeight + Math.floor(laneHeight / 2);
      const direction = Math.random() > 0.5 ? 1 : -1;
      const x = direction > 0 ? randInt(0, 5) : randInt(GRID_W - 5, GRID_W - 1);
      
      sharks.push({
        x, y,
        direction,
        speed: 0.08 + Math.random() * 0.06,
        lane,
        wiggle: Math.random() * Math.PI * 2
      });
    }
    
    // Init bubbles
    bubbles = [];
    for (let i = 0; i < 15; i++){
      bubbles.push({
        x: Math.random() * CANVAS_W,
        y: Math.random() * CANVAS_H,
        size: 1 + Math.random() * 2,
        speed: 0.3 + Math.random() * 0.5
      });
    }
    
    // Init scuba diver - just swims around for aesthetics
    scubaDiver = {
      x: randInt(0, GRID_W - 1),
      y: randInt(0, GRID_H - 1),
      targetX: randInt(0, GRID_W - 1),
      targetY: randInt(0, GRID_H - 1),
      moveTimer: 0,
      swimAngle: 0,
      flipX: false
    };
  }
  
  function updateSharks(){
    if (game.pendingMonster) return;
    
    for (let i = sharks.length - 1; i >= 0; i--){
      const s = sharks[i];
      s.wiggle = (s.wiggle + 0.1) % (Math.PI * 2);
      
      s.x += s.direction * s.speed;
      
      if (s.direction > 0 && s.x > GRID_W + 2){
        s.x = -2;
      } else if (s.direction < 0 && s.x < -2){
        s.x = GRID_W + 2;
      }
      
      // Check collision (HOLE IS SACRED) - must be on exact same tile
      const dx = Math.abs(s.x - game.playerX);
      const dy = Math.abs(s.y - game.playerY);
      if (dx < 0.8 && dy < 0.8 &&
          !(game.playerX === game.holeX && game.playerY === game.holeY)){
        if (activeShield > 0){
          logEvent("info", "Shield blocked shark!");
          setHud("SHIELD!");
          sharks.splice(i, 1); // Remove shark after shield block
        } else {
          game.lives--;
          logEvent("bad", "Shark attack! -1 life");
          setHud("SHARK BITE!");
          
          // Dramatic shark attack sound - deep underwater doom
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          
          // Deep rumbling bass (shark approaching)
          const bass = audioCtx.createOscillator();
          const bassGain = audioCtx.createGain();
          bass.connect(bassGain);
          bassGain.connect(audioCtx.destination);
          bass.type = "sawtooth";
          bass.frequency.setValueAtTime(60, audioCtx.currentTime);
          bass.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.6);
          bassGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
          bassGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
          
          // Bite crunch (harsh impact)
          const crunch = audioCtx.createOscillator();
          const crunchGain = audioCtx.createGain();
          crunch.connect(crunchGain);
          crunchGain.connect(audioCtx.destination);
          crunch.type = "square";
          crunch.frequency.setValueAtTime(150, audioCtx.currentTime + 0.15);
          crunch.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.35);
          crunchGain.gain.setValueAtTime(0.2, audioCtx.currentTime + 0.15);
          crunchGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
          
          // High screech (fear/pain)
          const screech = audioCtx.createOscillator();
          const screechGain = audioCtx.createGain();
          screech.connect(screechGain);
          screechGain.connect(audioCtx.destination);
          screech.type = "sine";
          screech.frequency.setValueAtTime(900, audioCtx.currentTime + 0.15);
          screech.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.45);
          screechGain.gain.setValueAtTime(0.15, audioCtx.currentTime + 0.15);
          screechGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.45);
          
          bass.start(audioCtx.currentTime);
          bass.stop(audioCtx.currentTime + 0.6);
          crunch.start(audioCtx.currentTime + 0.15);
          crunch.stop(audioCtx.currentTime + 0.35);
          screech.start(audioCtx.currentTime + 0.15);
          screech.stop(audioCtx.currentTime + 0.45);
          
          spawnSparks(game.playerX, game.playerY, 35, true);
          if (game.lives <= 0) gameOver();
          else updateUI();
          
          // Give brief invincibility (1 second) after hit
          game.inputLocked = true;
          setTimeout(() => { game.inputLocked = false; }, 1000);
          
          // Remove this shark after hitting
          sharks.splice(i, 1);
        }
      }
    }
    
    // Update bubbles
    for (let b of bubbles){
      b.y -= b.speed;
      if (b.y < -10){
        b.y = CANVAS_H + 10;
        b.x = Math.random() * CANVAS_W;
      }
    }
    
    // Update scuba diver - aesthetic swimming (VERY SLOW)
    if(scubaDiver){
      scubaDiver.moveTimer++;
      scubaDiver.swimAngle += 0.02; // Swimming animation (very slow)
      
      // Move towards target
      const dx = scubaDiver.targetX - scubaDiver.x;
      const dy = scubaDiver.targetY - scubaDiver.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if(distance > 0.1){
        // Smooth swimming towards target (much slower)
        const speed = 0.008;
        scubaDiver.x += (dx / distance) * speed;
        scubaDiver.y += (dy / distance) * speed;
        
        // Flip direction based on movement
        scubaDiver.flipX = dx < 0;
      } else {
        // Reached target, pick a new one
        scubaDiver.targetX = randInt(0, GRID_W - 1);
        scubaDiver.targetY = randInt(0, GRID_H - 1);
      }
    }
  }
  
  function drawSharks(){
    ctx.save();
    
    // Water overlay
    ctx.globalAlpha = 0.15;
    const waterGrad = ctx.createLinearGradient(0, 0, 0, CANVAS_H);
    waterGrad.addColorStop(0, 'rgba(0,100,200,0.3)');
    waterGrad.addColorStop(1, 'rgba(0,50,150,0.5)');
    ctx.fillStyle = waterGrad;
    ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);
    ctx.globalAlpha = 1;
    
    // Bubbles
    ctx.fillStyle = 'rgba(200,230,255,0.4)';
    for (let b of bubbles){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Sharks
    for (let s of sharks){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const wiggle = Math.sin(s.wiggle) * 2;
      
      ctx.save();
      ctx.translate(x, y + wiggle);
      if (s.direction < 0) ctx.scale(-1, 1);
      
      // Body
      ctx.fillStyle = '#4a6b8a';
      ctx.beginPath();
      ctx.ellipse(0, 0, 14, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Fin
      ctx.fillStyle = '#3a5b7a';
      ctx.beginPath();
      ctx.moveTo(-2, -6);
      ctx.lineTo(2, -10);
      ctx.lineTo(4, -6);
      ctx.fill();
      
      // Tail
      ctx.beginPath();
      ctx.moveTo(-14, 0);
      ctx.lineTo(-18, -4);
      ctx.lineTo(-16, 0);
      ctx.lineTo(-18, 4);
      ctx.fill();
      
      // Eye
      ctx.fillStyle = '#ff3333';
      ctx.beginPath();
      ctx.arc(8, -2, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Teeth
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(10, 1);
      ctx.lineTo(12, 3);
      ctx.moveTo(8, 1);
      ctx.lineTo(10, 3);
      ctx.stroke();
      
      ctx.restore();
    }
    
    // Draw modern scuba diver - aesthetic only!
    if(scubaDiver){
      const dx = scubaDiver.x * TILE + TILE / 2;
      const dy = scubaDiver.y * TILE + TILE / 2;
      const swimBob = Math.sin(scubaDiver.swimAngle) * 2;
      
      ctx.save();
      ctx.translate(dx, dy + swimBob);
      if(scubaDiver.flipX) ctx.scale(-1, 1);
      
      // Body (wetsuit - dark blue/black)
      ctx.fillStyle = '#1a1a2e';
      ctx.beginPath();
      ctx.ellipse(0, 0, 6, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Tank on back (gray)
      ctx.fillStyle = '#4a4a5a';
      ctx.fillRect(-2, -4, 2, 6);
      
      // Head/mask (tan skin with blue mask)
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(0, -8, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Diving mask (cyan blue)
      ctx.fillStyle = '#00bfff';
      ctx.beginPath();
      ctx.arc(0, -8, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Mask glass shine
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(-1, -9, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // Fins (bright orange/red)
      ctx.fillStyle = '#ff6347';
      const finAngle = Math.sin(scubaDiver.swimAngle * 2) * 0.3;
      
      // Left fin
      ctx.save();
      ctx.translate(-4, 8);
      ctx.rotate(finAngle);
      ctx.fillRect(-2, 0, 4, 6);
      ctx.restore();
      
      // Right fin
      ctx.save();
      ctx.translate(4, 8);
      ctx.rotate(-finAngle);
      ctx.fillRect(-2, 0, 4, 6);
      ctx.restore();
      
      // Arms (swimming motion)
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 2;
      const armSwing = Math.sin(scubaDiver.swimAngle * 2) * 0.5;
      ctx.beginPath();
      ctx.moveTo(-6, 0);
      ctx.lineTo(-10, 2 + armSwing * 3);
      ctx.moveTo(6, 0);
      ctx.lineTo(10, 2 - armSwing * 3);
      ctx.stroke();
      
      // Bubbles from tank
      if(Math.random() < 0.1){
        bubbles.push({
          x: dx - 2,
          y: dy - 4,
          size: 1 + Math.random(),
          speed: 0.5 + Math.random() * 0.3
        });
      }
      
      ctx.restore();
    }
    
    ctx.restore();
  }

  // ================================================================

  // ================================================================
  // VICTORY STICK - Moving & Timed Lasers + Large Robotic Tank!
  // ================================================================
  let laserWalls = [];
  let victoryTank = null;
  
  function initVictoryLasers(){
    laserWalls = [];
    
    // Create 2 laser walls that MOVE to new positions
    for(let i = 0; i < 2; i++){
      const isVertical = Math.random() > 0.5;
      
      if(isVertical){
        laserWalls.push({
          type: 'vertical',
          x: randInt(2, GRID_W - 3),
          movable: true,
          active: false,
          ghostly: false,
          ghostlyTimer: 0,
          ghostlyDuration: 120, // 2 seconds vapor preview
          activeTimer: 0,
          activeDuration: 180, // 3 seconds active
          inactiveTimer: randInt(0, 180),
          inactiveDuration: 240
        });
      } else {
        laserWalls.push({
          type: 'horizontal',
          y: randInt(2, GRID_H - 3),
          movable: true,
          active: false,
          ghostly: false,
          ghostlyTimer: 0,
          ghostlyDuration: 120,
          activeTimer: 0,
          activeDuration: 180,
          inactiveTimer: randInt(0, 180),
          inactiveDuration: 240
        });
      }
    }
    
    // Create 2 TIMED BEAM lasers (stationary, shoot beams periodically)
    for(let i = 0; i < 2; i++){
      const isVertical = Math.random() > 0.5;
      
      if(isVertical){
        laserWalls.push({
          type: 'vertical',
          x: randInt(2, GRID_W - 3),
          movable: false,
          timed: true, // This one shoots timed beams!
          active: false,
          beamActive: false,
          beamTimer: 0,
          beamDuration: 90, // Beam lasts 1.5 seconds
          cycleTimer: randInt(0, 180), // Staggered start
          cycleDuration: 240, // Fires every 4 seconds
          warningTimer: 0,
          warningDuration: 60 // 1 second warning
        });
      } else {
        laserWalls.push({
          type: 'horizontal',
          y: randInt(2, GRID_H - 3),
          movable: false,
          timed: true,
          active: false,
          beamActive: false,
          beamTimer: 0,
          beamDuration: 90,
          cycleTimer: randInt(0, 180),
          cycleDuration: 240,
          warningTimer: 0,
          warningDuration: 60
        });
      }
    }
    
    // Create LARGE ROBOTIC tank
    const startPos = {x: randInt(1, GRID_W - 2), y: randInt(1, GRID_H - 2)};
    
    victoryTank = {
      x: startPos.x,
      y: startPos.y,
      moveTimer: 0,
      moveInterval: 120, // Moves every 2 seconds
      float: 0,
      beamActive: false,
      beamTimer: 0,
      beamWarning: 0,
      powerUpTimer: 0, // For power-up animation
      rotation: 0,
      shootRange: 8 // Can shoot from 8 squares away!
    };
  }
  
  function updateVictoryLasers(){
    if(currentLevelTheme().name !== "Victory Stick") return;
    
    // FREEZE ALL HAZARDS during monster battles!
    if(game.pendingMonster || game.inputLocked) return;
    
    // Update laser walls
    laserWalls.forEach(wall => {
      if(wall.movable){
        // MOVING lasers
        if(!wall.ghostly && !wall.active){
          wall.inactiveTimer++;
          if(wall.inactiveTimer >= wall.inactiveDuration){
            // Move to NEW position!
            if(wall.type === 'vertical'){
              wall.x = randInt(2, GRID_W - 3);
            } else {
              wall.y = randInt(2, GRID_H - 3);
            }
            
            wall.inactiveTimer = 0;
            wall.ghostly = true;
            wall.ghostlyTimer = 0;
            beep(500, 0.06, "sine", 0.1);
          }
        } else if(wall.ghostly){
          // Vapor preview phase - NO COLLISION YET!
          wall.ghostlyTimer++;
          if(wall.ghostlyTimer >= wall.ghostlyDuration){
            wall.ghostly = false;
            wall.active = true;
            wall.activeTimer = 0;
            beep(800, 0.1, "sine", 0.15);
          }
        } else if(wall.active){
          // Fully active - CAN KILL!
          wall.activeTimer++;
          
          let hit = false;
          if(wall.type === 'vertical' && wall.x === game.playerX){
            hit = true;
          }
          if(wall.type === 'horizontal' && wall.y === game.playerY){
            hit = true;
          }
          
          if(hit){
            // Check shield first!
            if(activeShield > 0){
              logEvent("info", "Shield absorbed laser!");
              setHud("üõ°Ô∏è LASER BLOCKED!");
              spawnSparks(game.playerX, game.playerY, 20, false);
              
              // Still move laser to new position
              wall.active = false;
              wall.ghostly = false;
              wall.inactiveTimer = 0;
              
              if(wall.type === 'vertical'){
                wall.x = randInt(2, GRID_W - 3);
              } else {
                wall.y = randInt(2, GRID_H - 3);
              }
            } else {
              // No shield - take damage!
              game.lives--;
              logEvent("death", "‚ö° VAPORIZED BY LASER WALL! ‚ö°");
              setHud("‚ò†Ô∏è LASER VAPORIZED YOU! ‚ò†Ô∏è");
              
              startDoomMusic(3000);
              
              // DRAMATIC LASER DEATH SOUND!
              beep(1800, 0.2, "square", 0.7);
              setTimeout(() => beep(1400, 0.18, "square", 0.7), 60);
              setTimeout(() => beep(1000, 0.16, "square", 0.7), 120);
              setTimeout(() => beep(600, 0.14, "square", 0.7), 180);
              setTimeout(() => beep(200, 0.2, "square", 0.7), 240);
              
              game.holeFlash = 2.0;
              spawnSparks(game.playerX, game.playerY, 45, true);
              
              // MOVE LASER TO NEW POSITION so player doesn't die again immediately!
              wall.active = false;
              wall.ghostly = false;
              wall.inactiveTimer = 0;
              
              if(wall.type === 'vertical'){
                wall.x = randInt(2, GRID_W - 3);
              } else {
                wall.y = randInt(2, GRID_H - 3);
              }
              
              if(game.lives <= 0){
                gameOver();
              } else {
                updateUI();
              }
            }
          }
          
          if(wall.activeTimer >= wall.activeDuration){
            wall.active = false;
            wall.activeTimer = 0;
            wall.inactiveTimer = 0;
            beep(400, 0.06, "sine", 0.08);
          }
        }
      } else if(wall.timed){
        // TIMED BEAM lasers (like shark lanes - shoot beams periodically)
        wall.cycleTimer++;
        
        if(!wall.beamActive && wall.warningTimer === 0){
          if(wall.cycleTimer >= wall.cycleDuration){
            wall.warningTimer = wall.warningDuration;
            wall.cycleTimer = 0;
            beep(600, 0.08, "sine", 0.12);
          }
        } else if(wall.warningTimer > 0){
          wall.warningTimer--;
          if(wall.warningTimer === 0){
            wall.beamActive = true;
            wall.beamTimer = 0;
            beep(900, 0.12, "sine", 0.18);
          }
        } else if(wall.beamActive){
          wall.beamTimer++;
          
          // Check collision when beam is active
          let hit = false;
          if(wall.type === 'vertical' && wall.x === game.playerX){
            hit = true;
          }
          if(wall.type === 'horizontal' && wall.y === game.playerY){
            hit = true;
          }
          
          if(hit){
            // Check shield first!
            if(activeShield > 0){
              logEvent("info", "Shield absorbed timed beam!");
              setHud("üõ°Ô∏è BEAM BLOCKED!");
              spawnSparks(game.playerX, game.playerY, 20, false);
              
              // Still deactivate beam
              wall.beamActive = false;
              wall.beamTimer = 0;
            } else {
              // No shield - take damage!
              game.lives--;
              logEvent("death", "‚ö° DISINTEGRATED BY BEAM! ‚ö°");
              setHud("‚ò†Ô∏è BEAM DISINTEGRATED YOU! ‚ò†Ô∏è");
              
              startDoomMusic(3000);
              
              // DRAMATIC BEAM DEATH SOUND!
              beep(1800, 0.2, "square", 0.7);
              setTimeout(() => beep(1400, 0.18, "square", 0.7), 60);
              setTimeout(() => beep(1000, 0.16, "square", 0.7), 120);
              setTimeout(() => beep(600, 0.14, "square", 0.7), 180);
              setTimeout(() => beep(200, 0.2, "square", 0.7), 240);
              
              game.holeFlash = 2.0;
              spawnSparks(game.playerX, game.playerY, 45, true);
              
              // DEACTIVATE BEAM IMMEDIATELY to prevent multi-kill!
              wall.beamActive = false;
              wall.beamTimer = 0;
              
              if(game.lives <= 0){
                gameOver();
              } else {
                updateUI();
              }
            }
          }
          
          if(wall.beamTimer >= wall.beamDuration){
            wall.beamActive = false;
            wall.beamTimer = 0;
            beep(400, 0.06, "sine", 0.08);
          }
        }
      }
    });
    
    // Update LARGE ROBOTIC tank
    if(victoryTank){
      victoryTank.float = (victoryTank.float + 0.05) % (Math.PI * 2);
      
      // Tank CHASES player
      victoryTank.moveTimer++;
      if(victoryTank.moveTimer > victoryTank.moveInterval){
        victoryTank.moveTimer = 0;
        
        const dx = game.playerX - victoryTank.x;
        const dy = game.playerY - victoryTank.y;
        
        if(Math.abs(dx) >= Math.abs(dy)){
          if(dx > 0 && victoryTank.x < GRID_W - 1){
            victoryTank.x++;
          } else if(dx < 0 && victoryTank.x > 0){
            victoryTank.x--;
          }
        } else {
          if(dy > 0 && victoryTank.y < GRID_H - 1){
            victoryTank.y++;
          } else if(dy < 0 && victoryTank.y > 0){
            victoryTank.y--;
          }
        }
      }
      
      const dx = game.playerX - victoryTank.x;
      const dy = game.playerY - victoryTank.y;
      victoryTank.rotation = Math.atan2(dy, dx);
      
      // Power-up animation
      if(victoryTank.powerUpTimer > 0){
        victoryTank.powerUpTimer--;
      }
      
      // RED Beam mechanic
      if(!victoryTank.beamActive){
        victoryTank.beamWarning++;
        if(victoryTank.beamWarning > randInt(180, 300)){
          victoryTank.beamActive = true;
          victoryTank.beamTimer = 0;
          victoryTank.beamWarning = 0;
          victoryTank.powerUpTimer = 90; // Start power-up animation
          
          // FUN POWER-UP SOUND!
          beep(400, 0.1, "sine", 0.15);
          setTimeout(() => beep(500, 0.1, "sine", 0.18), 100);
          setTimeout(() => beep(600, 0.1, "sine", 0.2), 200);
          setTimeout(() => beep(800, 0.12, "sine", 0.25), 300);
          setTimeout(() => beep(1000, 0.15, "sine", 0.3), 400);
          
          logEvent("warn", "Tank powering up!");
          setHud("‚ö†Ô∏è TANK CHARGING!");
        }
      } else {
        victoryTank.beamTimer++;
        
        // Fun laser charging sound
        if(victoryTank.beamTimer > 90 && victoryTank.beamTimer < 110){
          if(victoryTank.beamTimer % 5 === 0){
            beep(1000 + Math.random() * 300, 0.03, "sawtooth", 0.2);
          }
        }
        
        // Beam fires
        if(victoryTank.beamTimer > 90){
          const beamLength = victoryTank.shootRange;
          const angle = victoryTank.rotation;
          
          let playerInBeam = false;
          for(let i = 1; i <= beamLength; i++){
            const checkX = Math.round(victoryTank.x + Math.cos(angle) * i);
            const checkY = Math.round(victoryTank.y + Math.sin(angle) * i);
            
            if(checkX === game.playerX && checkY === game.playerY){
              playerInBeam = true;
              break;
            }
          }
          
          if(playerInBeam){
            // MUCH MORE REASONABLE ODDS - roll 0-19
            // 0 = TELEPORT (5% chance - 1/20) - Very rare!
            // 1-19 = MISS (95% chance - 19/20) - Usually miss!
            // NO KILL - removed completely, too punishing
            const roll = randInt(0, 19);
            
            // Check shield first!
            if(activeShield > 0){
              logEvent("info", "Shield deflected tank beam!");
              setHud("üõ°Ô∏è BEAM DEFLECTED!");
              spawnSparks(game.playerX, game.playerY, 15, false);
            } else if(roll === 0){
              // TELEPORT - Beam relocates you (rare!)
              const newPos = randomEmptyTile();
              game.playerX = newPos.x;
              game.playerY = newPos.y;
              
              logEvent("info", "Tank beam teleported you!");
              setHud("‚ö° RELOCATED! ‚ö°");
              
              // Teleport sound
              const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              osc.type = "sine";
              osc.frequency.setValueAtTime(800, audioCtx.currentTime);
              osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
              gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
              gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
              osc.start();
              osc.stop(audioCtx.currentTime + 0.3);
              
              spawnSparks(game.playerX, game.playerY, 25, false);
            }
            // else: roll 1-19 = MISS (95% chance) - beam passes harmlessly!
          }
          
          if(victoryTank.beamTimer >= 120){
            victoryTank.beamActive = false;
            victoryTank.beamTimer = 0;
          }
        }
      }
    }
  }
  
  function drawVictoryLasers(){
    if(currentLevelTheme().name !== "Victory Stick") return;
    
    ctx.save();
    
    // Draw laser walls
    laserWalls.forEach(wall => {
      if(wall.type === 'vertical'){
        const sx = wall.x * TILE + TILE / 2;
        
        if(wall.timed){
          // TIMED BEAM laser - draw emitter
          const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
          
          // Emitter base (top of screen)
          ctx.fillStyle = '#27ae60';
          ctx.strokeStyle = '#52ffa8';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(sx, 15, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // Warning glow
          if(wall.warningTimer > 0){
            const warnPulse = Math.sin(wall.warningTimer * 0.2) * 0.5 + 0.5;
            ctx.shadowColor = "#ffeb3b";
            ctx.shadowBlur = 15 * warnPulse;
            ctx.fillStyle = `rgba(255, 235, 59, ${0.3 + warnPulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(sx, 15, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
          
          // Beam when active
          if(wall.beamActive){
            const beamPulse = Math.sin(Date.now() * 0.015) * 0.2 + 0.8;
            
            // IMPRESSIVE beam effect!
            ctx.shadowColor = "#27ae60";
            ctx.shadowBlur = 25;
            
            // Outer glow
            const outerGrad = ctx.createLinearGradient(sx, 15, sx, CANVAS_H);
            outerGrad.addColorStop(0, `rgba(39, 174, 96, ${beamPulse * 0.9})`);
            outerGrad.addColorStop(1, `rgba(39, 174, 96, ${beamPulse * 0.7})`);
            ctx.strokeStyle = outerGrad;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(sx, 15);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
            
            // Inner core
            const coreGrad = ctx.createLinearGradient(sx, 15, sx, CANVAS_H);
            coreGrad.addColorStop(0, `rgba(82, 255, 168, ${beamPulse})`);
            coreGrad.addColorStop(1, `rgba(82, 255, 168, ${beamPulse * 0.8})`);
            ctx.strokeStyle = coreGrad;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(sx, 15);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
            
            // Bright center
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(200, 255, 220, ${beamPulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(sx, 15);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
          }
        } else {
          // MOVING laser
          if(wall.ghostly){
            // VAPOR preview (solid transparent, NOT dashed!)
            const vaporPulse = Math.sin(wall.ghostlyTimer * 0.08) * 0.3 + 0.5;
            const alpha = 0.2 + vaporPulse * 0.3;
            
            // Vapor effect - multiple layers
            for(let i = 0; i < 3; i++){
              const offset = i * 2;
              const layerAlpha = alpha * (1 - i * 0.2);
              ctx.strokeStyle = `rgba(39, 174, 96, ${layerAlpha})`;
              ctx.lineWidth = 6 - i;
              ctx.shadowColor = "#27ae60";
              ctx.shadowBlur = 15 + vaporPulse * 10;
              ctx.beginPath();
              ctx.moveTo(sx - offset, 0);
              ctx.lineTo(sx - offset, CANVAS_H);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(sx + offset, 0);
              ctx.lineTo(sx + offset, CANVAS_H);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
          } else if(wall.active){
            // Fully active laser - IMPRESSIVE!
            const pulse = Math.sin(Date.now() * 0.008) * 0.2 + 0.8;
            
            ctx.shadowColor = "#27ae60";
            ctx.shadowBlur = 25;
            ctx.strokeStyle = `rgba(39, 174, 96, ${pulse * 0.9})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(sx, 0);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
            
            ctx.shadowBlur = 15;
            ctx.strokeStyle = `rgba(82, 255, 168, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(sx, 0);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(200, 255, 220, ${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(sx, 0);
            ctx.lineTo(sx, CANVAS_H);
            ctx.stroke();
          }
        }
      } else {
        // Horizontal laser
        const sy = wall.y * TILE + TILE / 2;
        
        if(wall.timed){
          // TIMED BEAM laser emitter
          const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
          
          ctx.fillStyle = '#27ae60';
          ctx.strokeStyle = '#52ffa8';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(15, sy, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          if(wall.warningTimer > 0){
            const warnPulse = Math.sin(wall.warningTimer * 0.2) * 0.5 + 0.5;
            ctx.shadowColor = "#ffeb3b";
            ctx.shadowBlur = 15 * warnPulse;
            ctx.fillStyle = `rgba(255, 235, 59, ${0.3 + warnPulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(15, sy, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          }
          
          if(wall.beamActive){
            const beamPulse = Math.sin(Date.now() * 0.015) * 0.2 + 0.8;
            
            ctx.shadowColor = "#27ae60";
            ctx.shadowBlur = 25;
            
            const outerGrad = ctx.createLinearGradient(15, sy, CANVAS_W, sy);
            outerGrad.addColorStop(0, `rgba(39, 174, 96, ${beamPulse * 0.9})`);
            outerGrad.addColorStop(1, `rgba(39, 174, 96, ${beamPulse * 0.7})`);
            ctx.strokeStyle = outerGrad;
            ctx.lineWidth = 10;
            ctx.beginPath();
            ctx.moveTo(15, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
            
            const coreGrad = ctx.createLinearGradient(15, sy, CANVAS_W, sy);
            coreGrad.addColorStop(0, `rgba(82, 255, 168, ${beamPulse})`);
            coreGrad.addColorStop(1, `rgba(82, 255, 168, ${beamPulse * 0.8})`);
            ctx.strokeStyle = coreGrad;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(15, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(200, 255, 220, ${beamPulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(15, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
          }
        } else {
          // MOVING laser
          if(wall.ghostly){
            const vaporPulse = Math.sin(wall.ghostlyTimer * 0.08) * 0.3 + 0.5;
            const alpha = 0.2 + vaporPulse * 0.3;
            
            for(let i = 0; i < 3; i++){
              const offset = i * 2;
              const layerAlpha = alpha * (1 - i * 0.2);
              ctx.strokeStyle = `rgba(39, 174, 96, ${layerAlpha})`;
              ctx.lineWidth = 6 - i;
              ctx.shadowColor = "#27ae60";
              ctx.shadowBlur = 15 + vaporPulse * 10;
              ctx.beginPath();
              ctx.moveTo(0, sy - offset);
              ctx.lineTo(CANVAS_W, sy - offset);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(0, sy + offset);
              ctx.lineTo(CANVAS_W, sy + offset);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
          } else if(wall.active){
            const pulse = Math.sin(Date.now() * 0.008) * 0.2 + 0.8;
            
            ctx.shadowColor = "#27ae60";
            ctx.shadowBlur = 25;
            ctx.strokeStyle = `rgba(39, 174, 96, ${pulse * 0.9})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(0, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
            
            ctx.shadowBlur = 15;
            ctx.strokeStyle = `rgba(82, 255, 168, ${pulse})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(200, 255, 220, ${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, sy);
            ctx.lineTo(CANVAS_W, sy);
            ctx.stroke();
          }
        }
      }
    });
    
    // Draw LARGE ROBOTIC tank (TWICE as large!)
    if(victoryTank){
      const tx = victoryTank.x * TILE + TILE / 2;
      const ty = victoryTank.y * TILE + TILE / 2;
      const hover = Math.sin(victoryTank.float) * 2;
      
      ctx.save();
      ctx.translate(tx, ty + hover);
      
      // Metallic glow
      const glowPulse = Math.sin(victoryTank.float * 2) * 0.3 + 0.7;
      ctx.globalAlpha = 0.25 * glowPulse;
      const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 35);
      outerGlow.addColorStop(0, 'rgba(200,200,220,0.6)');
      outerGlow.addColorStop(1, 'rgba(200,200,220,0)');
      ctx.fillStyle = outerGlow;
      ctx.beginPath();
      ctx.arc(0, 0, 35, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // Power-up glow effect
      if(victoryTank.powerUpTimer > 0){
        const powerPulse = victoryTank.powerUpTimer / 90;
        ctx.shadowColor = '#ff3232';
        ctx.shadowBlur = 20 * powerPulse;
        ctx.globalAlpha = 0.4 * powerPulse;
        ctx.fillStyle = 'rgba(255, 50, 50, 0.3)';
        ctx.beginPath();
        ctx.arc(0, 0, 30 * powerPulse, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }
      
      // LARGE ROBOTIC hexagonal body - TWICE as big!
      
      // VIBRANT RED AURA around the tank body
      const redGlowPulse = Math.sin(victoryTank.float * 3) * 0.4 + 0.6;
      const redGlowAlpha = victoryTank.beamActive ? 0.7 : 0.5; // Much more vibrant!
      
      // Outer glow layer
      ctx.globalAlpha = redGlowAlpha * redGlowPulse * 0.6;
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 30;
      ctx.strokeStyle = `rgba(255, 30, 30, ${redGlowAlpha * 0.8})`;
      ctx.lineWidth = 6;
      ctx.beginPath();
      for(let i = 0; i < 6; i++){
        const angle = (i / 6) * Math.PI * 2;
        const x = Math.cos(angle) * 24; // Larger glow
        const y = Math.sin(angle) * 24;
        if(i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
      
      // Inner glow layer (brighter)
      ctx.shadowBlur = 15;
      ctx.strokeStyle = `rgba(255, 60, 60, ${redGlowAlpha})`;
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i = 0; i < 6; i++){
        const angle = (i / 6) * Math.PI * 2;
        const x = Math.cos(angle) * 22;
        const y = Math.sin(angle) * 22;
        if(i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      
      // Main metallic body
      ctx.shadowColor = '#c0c0d0';
      ctx.shadowBlur = 12 * glowPulse;
      
      // Metallic silver gradient
      const metalGrad = ctx.createRadialGradient(-4, -4, 0, 0, 0, 20);
      metalGrad.addColorStop(0, '#f0f0f8'); // Bright silver
      metalGrad.addColorStop(0.4, '#d0d0e0'); // Mid silver
      metalGrad.addColorStop(1, '#909098'); // Dark silver
      ctx.fillStyle = metalGrad;
      ctx.strokeStyle = '#e8e8f0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let i = 0; i < 6; i++){
        const angle = (i / 6) * Math.PI * 2;
        const x = Math.cos(angle) * 20; // TWICE as large (was 10)
        const y = Math.sin(angle) * 20;
        if(i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      ctx.shadowBlur = 0;
      
      // RED FLOWING VEINS - animated energy coursing through the tank!
      const veinPulse = Math.sin(victoryTank.float * 3) * 0.4 + 0.6;
      const veinAlpha = 0.3 + veinPulse * 0.4;
      const veinGlow = victoryTank.beamActive ? veinAlpha * 1.5 : veinAlpha;
      const flowOffset = (Date.now() * 0.02) % 10; // Flowing animation offset
      
      ctx.strokeStyle = `rgba(255, 50, 50, ${veinGlow})`;
      ctx.lineWidth = 1.5;
      ctx.shadowColor = '#ff3232';
      ctx.shadowBlur = 6 + veinPulse * 6;
      ctx.setLineDash([4, 6]); // Dashed lines
      ctx.lineDashOffset = -flowOffset; // Animate the dash flow!
      
      // Diagonal veins (flowing from edges to center)
      ctx.beginPath();
      ctx.moveTo(-14, -8);
      ctx.lineTo(-4, 0);
      ctx.lineTo(-14, 8);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(14, -8);
      ctx.lineTo(4, 0);
      ctx.lineTo(14, 8);
      ctx.stroke();
      
      // Vertical center vein (flowing downward)
      ctx.lineDashOffset = -flowOffset * 1.5; // Different speed
      ctx.beginPath();
      ctx.moveTo(0, -16);
      ctx.lineTo(0, -8);
      ctx.moveTo(0, 8);
      ctx.lineTo(0, 16);
      ctx.stroke();
      
      // Horizontal veins (flowing inward)
      ctx.lineDashOffset = -flowOffset * 0.8; // Different speed
      ctx.beginPath();
      ctx.moveTo(-10, -4);
      ctx.lineTo(10, -4);
      ctx.moveTo(-10, 4);
      ctx.lineTo(10, 4);
      ctx.stroke();
      
      ctx.setLineDash([]); // Reset dashed lines
      ctx.shadowBlur = 0;
      
      // Robotic panel details
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-12, 0);
      ctx.lineTo(12, 0);
      ctx.moveTo(0, -12);
      ctx.lineTo(0, 12);
      ctx.stroke();
      
      // Corner rivets
      for(let i = 0; i < 6; i++){
        const angle = (i / 6) * Math.PI * 2;
        const x = Math.cos(angle) * 16;
        const y = Math.sin(angle) * 16;
        ctx.fillStyle = '#a0a0b0';
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Rotating turret
      ctx.save();
      ctx.rotate(victoryTank.rotation);
      
      // Large turret base
      const turretGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, 12);
      turretGrad.addColorStop(0, '#e0e0e8');
      turretGrad.addColorStop(1, '#a0a0b0');
      ctx.fillStyle = turretGrad;
      ctx.strokeStyle = '#f0f0f8';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI * 2); // Larger turret
      ctx.fill();
      ctx.stroke();
      
      // Larger cannon barrel
      const cannonGrad = ctx.createLinearGradient(0, -4, 0, 4);
      cannonGrad.addColorStop(0, '#d0d0e0');
      cannonGrad.addColorStop(0.5, '#909098');
      cannonGrad.addColorStop(1, '#b0b0c0');
      ctx.fillStyle = cannonGrad;
      ctx.strokeStyle = '#c0c0d0';
      ctx.lineWidth = 1;
      ctx.fillRect(0, -4, 24, 8); // Larger cannon (was 18x6)
      ctx.strokeRect(0, -4, 24, 8);
      
      // Metallic cannon opening (no goofy red nose!)
      ctx.shadowColor = '#909098';
      ctx.shadowBlur = 3;
      const tipGrad = ctx.createRadialGradient(24, 0, 0, 24, 0, 4);
      tipGrad.addColorStop(0, '#606068'); // Dark metallic center
      tipGrad.addColorStop(0.6, '#808088'); // Mid tone
      tipGrad.addColorStop(1, '#a0a0b0'); // Outer edge
      ctx.fillStyle = tipGrad;
      ctx.beginPath();
      ctx.arc(24, 0, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Barrel rim highlight
      ctx.strokeStyle = '#c0c0d0';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(24, 0, 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      ctx.restore();
      ctx.globalAlpha = 1;
      
      // IMPRESSIVE RED BEAM!
      if(victoryTank.beamActive && victoryTank.beamTimer > 90){
        const beamAlpha = Math.sin(victoryTank.beamTimer * 0.2) * 0.1 + 0.25;
        const beamLength = victoryTank.shootRange * TILE;
        const beamPulse = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
        
        ctx.save();
        ctx.rotate(victoryTank.rotation);
        
        // Outer glow layer
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 30;
        const outerBeamGrad = ctx.createLinearGradient(24, 0, beamLength, 0);
        outerBeamGrad.addColorStop(0, `rgba(255, 50, 50, ${(beamAlpha + 0.15) * beamPulse})`);
        outerBeamGrad.addColorStop(1, `rgba(200, 30, 30, ${beamAlpha * beamPulse})`);
        ctx.fillStyle = outerBeamGrad;
        ctx.fillRect(24, -6, beamLength, 12);
        
        // Middle layer
        const midBeamGrad = ctx.createLinearGradient(24, 0, beamLength, 0);
        midBeamGrad.addColorStop(0, `rgba(255, 100, 100, ${(beamAlpha + 0.2) * beamPulse})`);
        midBeamGrad.addColorStop(1, `rgba(255, 50, 50, ${beamAlpha * beamPulse})`);
        ctx.fillStyle = midBeamGrad;
        ctx.fillRect(24, -4, beamLength, 8);
        
        // Core beam
        ctx.shadowBlur = 0;
        const coreBeamGrad = ctx.createLinearGradient(24, 0, beamLength, 0);
        coreBeamGrad.addColorStop(0, `rgba(255, 200, 200, ${beamPulse})`);
        coreBeamGrad.addColorStop(1, `rgba(255, 150, 150, ${beamPulse * 0.7})`);
        ctx.fillStyle = coreBeamGrad;
        ctx.fillRect(24, -2, beamLength, 4);
        
        ctx.restore();
        ctx.globalAlpha = 1;
      }
      
      ctx.restore();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // ================================================================
  // SUN BURSTS - Sun Stick (steal sticks!)
  // ================================================================
  // SUN BURSTS - Sun Stick (steal sticks!)
  // ================================================================
  let sunBurstTiles = [];
  let sunBurstWarningTimer = 0;
  let playerSunGlow = 0;
  let playerCloudEffect = 0; // Cloud drag effect on player
  let bananaMode = false; // Banana boost from defeating monkey
  
  // Sparkle Stick variables
  let rainbows = [];
  let sparkleTrail = 0; // Replaced by cupcakeMode
  let flowerRain = false; // Flower rain active
  let flowerRainParticles = [];
  let cupcakeMode = 0; // Timer for cupcake transformation (10 seconds)
  
  // Cursed Stick variables
  let ghosts = [];
  let skulls = [];
  let isSkeletonMode = false; // Player transformed into skeleton
  let smokeParticles = [];
  const SUNBURST_WARNING_TIME = 150; // 2.5 seconds
  
  function initSunBursts(){
    sunBurstTiles = [];
    const num = randInt(7, 9); // Even more suns!
    for (let i = 0; i < num; i++){
      let x, y;
      // Make sure sun doesn't spawn in the hole
      do {
        x = randInt(0, GRID_W - 1);
        y = randInt(0, GRID_H - 1);
      } while (x === game.holeX && y === game.holeY);
      
      sunBurstTiles.push({
        x: x,
        y: y,
        pulse: Math.random() * Math.PI * 2,
        rotation: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateSunBursts(){
    for (let b of sunBurstTiles){
      b.pulse = (b.pulse + 0.08) % (Math.PI * 2);
      b.rotation = (b.rotation + 0.02) % (Math.PI * 2); // Slow rotation
    }
    
    const onBurst = sunBurstTiles.some(b => b.x === game.playerX && b.y === game.playerY);
    if (onBurst){
      sunBurstWarningTimer++;
      
      // Trigger sun glow effect immediately when stepping on sun
      if (sunBurstWarningTimer === 1){
        playerSunGlow = 180; // 3 seconds glow effect
      }
      
      if (sunBurstWarningTimer >= SUNBURST_WARNING_TIME){
        // HOLE IS SACRED
        if (game.playerX === game.holeX && game.playerY === game.holeY){
          sunBurstWarningTimer = 0;
        } else if (activeShield > 0){
          sunBurstWarningTimer = 0;
          logEvent("info", "Shield blocked sun burst!");
          setHud("SHIELD!");
        } else if (game.carry.length > 0){
          // Check if board is empty (no sticks left on field)
          const sticksOnBoard = game.sticks.length;
          const sticksCarried = game.carry.length;
          
          if (sticksOnBoard === 0){
            // Board is empty! Player was carrying the last stick(s) - level complete!
            game.carry = [];
            sunBurstWarningTimer = 0;
            logEvent("bonus", "Sun burst took your last sticks! Board cleared - advancing!");
            setHud("LEVEL COMPLETE!");
            beep(700, 0.15, "sine", 0.10);
            spawnSparks(game.playerX, game.playerY, 30, false);
            gameSetTimeout(() => {
              game.level++;
              newLevel();
            }, 800);
          } else {
            // There are still sticks on the board - take carried sticks normally
            const lost = game.carry.length;
            game.carry = [];
            sunBurstWarningTimer = 0;
            logEvent("bad", `Sun burst stole ${lost} sticks!`);
            setHud("SUN BURST!");
            beep(500, 0.12, "sine", 0.08);
            spawnSparks(game.playerX, game.playerY, 22, true);
            updateUI();
          }
        } else {
          sunBurstWarningTimer = 0;
        }
      } else if (sunBurstWarningTimer === 60 || sunBurstWarningTimer === 120){
        beep(450, 0.1, "sine", 0.06);
        logEvent("warn", "Sun burst! Move!");
        setHud("SUN BURST!");
      }
    } else {
      sunBurstWarningTimer = 0;
    }
  }
  
  function drawSunBursts(){
    ctx.save();
    for (let b of sunBurstTiles){
      const x = b.x * TILE + TILE / 2;
      const y = b.y * TILE + TILE / 2;
      const pulse = Math.sin(b.pulse) * 0.2 + 0.8;
      
      ctx.save();
      ctx.translate(x, y);
      
      // Outer atmospheric glow
      ctx.globalAlpha = 0.15 * pulse;
      const atmosphereGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 22);
      atmosphereGrad.addColorStop(0, 'rgba(255,240,200,0.3)');
      atmosphereGrad.addColorStop(0.7, 'rgba(255,200,100,0.15)');
      atmosphereGrad.addColorStop(1, 'rgba(255,150,0,0)');
      ctx.fillStyle = atmosphereGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 22, 0, Math.PI * 2);
      ctx.fill();
      
      // Rotating corona rays (8 wavy rays)
      ctx.globalAlpha = 0.5 + pulse * 0.2;
      ctx.rotate(b.rotation);
      ctx.strokeStyle = '#ffb347';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      
      for (let i = 0; i < 8; i++){
        const angle = (Math.PI * 2 / 8) * i;
        const rayLength = 9 + Math.sin(b.pulse + i) * 2;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * 7, Math.sin(angle) * 7);
        ctx.lineTo(Math.cos(angle) * rayLength, Math.sin(angle) * rayLength);
        ctx.stroke();
      }
      
      // Main sun sphere (layered gradient for depth)
      ctx.globalAlpha = 1;
      
      // Outer orange layer
      const outerSphere = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
      outerSphere.addColorStop(0, '#fff9e6');
      outerSphere.addColorStop(0.4, '#ffeb3b');
      outerSphere.addColorStop(0.7, '#ffc107');
      outerSphere.addColorStop(1, '#ff9800');
      ctx.fillStyle = outerSphere;
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Bright core
      ctx.globalAlpha = 0.9;
      const coreGlow = ctx.createRadialGradient(-1, -1, 0, 0, 0, 5);
      coreGlow.addColorStop(0, '#ffffff');
      coreGlow.addColorStop(0.5, '#fffacd');
      coreGlow.addColorStop(1, 'rgba(255,235,59,0)');
      ctx.fillStyle = coreGlow;
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // Hot spots (surface details)
      ctx.globalAlpha = 0.4 + pulse * 0.2;
      ctx.fillStyle = '#fff176';
      ctx.beginPath();
      ctx.arc(-2, -3, 1.5, 0, Math.PI * 2);
      ctx.arc(3, 1, 1, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    // Warning indicator
    if (sunBurstWarningTimer > 0){
      const onBurst = sunBurstTiles.some(b => b.x === game.playerX && b.y === game.playerY);
      if (onBurst){
        const px = game.playerX * TILE + TILE / 2;
        const py = game.playerY * TILE + TILE / 2;
        const warningPulse = Math.sin(sunBurstWarningTimer * 0.3) * 0.5 + 0.5;
        ctx.globalAlpha = 0.4 + warningPulse * 0.4;
        ctx.strokeStyle = '#ffd400';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, TILE / 2 + 2, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Special power-up sticks
  let activeSpeedBoost = 0; // Remaining free moves
  let activeShield = 0; // Remaining shield time in frames (1800 = 30 seconds)
  let visionRevealed = false; // Whether vision stick revealed the secret
  let visionTimer = 0; // How long vision effect lasts (1800 = 30 seconds)
  
  function pickupSpecialStick(type){
    if (type === "speed"){
      activeSpeedBoost = 10;
      logEvent("bonus", "SPEED STICK! Next 10 moves are free!");
      setHud("SPEED BOOST!");
      playSpeedStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "shield"){
      activeShield = 1800; // 30 seconds
      logEvent("bonus", "SHIELD STICK! 30 sec immunity!");
      setHud("SHIELD ACTIVE!");
      playShieldStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    } else if (type === "vision"){
      visionRevealed = true;
      visionTimer = 1800; // 30 seconds
      logEvent("bonus", "VISION STICK! 30 sec reveal!");
      setHud("VISION ACTIVATED!");
      playVisionStickSound();
      spawnSparks(game.playerX, game.playerY, 24, false);
    }
  }
  
  function updateSpecialEffects(){
    if (activeShield > 0) activeShield--;
    if (visionTimer > 0){
      visionTimer--;
      if (visionTimer <= 0) visionRevealed = false;
    }
  }
  
  function drawSpecialEffects(){
    // Draw shield indicator around player
    if (activeShield > 0){
      const px = game.playerX * TILE + TILE / 2;
      const py = game.playerY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
      
      ctx.save();
      ctx.strokeStyle = '#3aa7ff';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4 + pulse * 0.3;
      ctx.shadowColor = '#3aa7ff';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(px, py, TILE / 2 + 4, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
    
    // Draw vision effect - pulsing glow on secret square
    if (visionRevealed && !game.lifeTileUsed){
      const sx = game.lifeTileX * TILE + TILE / 2;
      const sy = game.lifeTileY * TILE + TILE / 2;
      const pulse = Math.sin(Date.now() / 150) * 0.5 + 0.5;
      
      ctx.save();
      ctx.globalAlpha = 0.3 + pulse * 0.4;
      const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, TILE);
      gradient.addColorStop(0, 'rgba(255,212,0,0.8)');
      gradient.addColorStop(1, 'rgba(255,212,0,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(game.lifeTileX * TILE, game.lifeTileY * TILE, TILE, TILE);
      ctx.restore();
    }
  }


  // Level-specific hazards
  let darkTiles = [];
  let darkTileTimer = 0;
  let teleportTiles = [];
  let teleportMoveTimer = 0;
  let holeFlashTimer = 0;
  let holeMoveTimer = 0;
  
  function initLevelHazards(){
    windGustTimer = 0;
    darkTiles = [];
    darkTileTimer = 0;
    teleportTiles = [];
    
    const theme = currentLevelTheme().name;
    
    // Sky Stick: No setup needed, wind happens randomly
    
    // Glow Stick: Create tiles that can go dark
    if (theme === "Glow Stick"){
      darkTileTimer = randInt(180, 420); // 3-7 seconds until first dark
    }
    
    // Spell Stick: Create 5-8 MOVING teleport tiles + moving hole
    if (theme === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900); // 10-15 seconds
      holeFlashTimer = 0;
    }
  }
  
  function updateLevelHazards(){
    const theme = currentLevelTheme().name;
    
    // Sky Stick: Random wind gusts
    if (theme === "Sky Stick"){
      windGustTimer++;
      if (windGustTimer >= randInt(180, 360)){ // Every 3-6 seconds
        windGustTimer = 0;
        if (!game.inputLocked && game.actions > 0){
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          const newX = clamp(game.playerX + dir.dx, 0, GRID_W - 1);
          const newY = clamp(game.playerY + dir.dy, 0, GRID_H - 1);
          
          // Don't push into hole
          if (newX !== game.holeX || newY !== game.holeY){
            game.playerX = newX;
            game.playerY = newY;
        
            logEvent("info", "Wind gust pushed you!");
            setHud("WIND GUST!");
            spawnSparks(game.playerX, game.playerY, 12, false);
          }
        }
      }
    }
    
    // Glow Stick: Tiles go dark periodically
    if (theme === "Glow Stick"){
      if (darkTiles.length === 0){
        darkTileTimer--;
        if (darkTileTimer <= 0){
          // Create 4-8 dark tiles
          const numDark = randInt(4, 8);
          for (let i = 0; i < numDark; i++){
            darkTiles.push({
              x: randInt(0, GRID_W - 1),
              y: randInt(0, GRID_H - 1),
              life: 180 + randInt(0, 120) // 3-5 seconds
            });
          }
          logEvent("info", "Some tiles went dark!");
        }
      } else {
        // Update existing dark tiles
        for (let i = darkTiles.length - 1; i >= 0; i--){
          darkTiles[i].life--;
          if (darkTiles[i].life <= 0){
            darkTiles.splice(i, 1);
          }
        }
        if (darkTiles.length === 0){
          darkTileTimer = randInt(180, 420); // Reset timer
        }
      }
    }
    
    // Spell Stick: MOVING teleport tiles + MOVING hole
    if (theme === "Spell Stick"){
      // Animate and move teleport tiles
      for (let tile of teleportTiles){
        tile.glow = (tile.glow + 0.08) % (Math.PI * 2);
        
        // Move teleports
        tile.moveTimer--;
        if (tile.moveTimer <= 0){
          tile.moveTimer = randInt(180, 360); // 3-6 seconds
          const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
          const dir = dirs[randInt(0, 3)];
          tile.x = clamp(tile.x + dir.dx, 0, GRID_W - 1);
          tile.y = clamp(tile.y + dir.dy, 0, GRID_H - 1);
        }
      }
      
      // Check if player stepped on teleport (flash warning 1 sec before)
      const onTeleport = teleportTiles.find(t => t.x === game.playerX && t.y === game.playerY);
      if (onTeleport && !onTeleport.flashWarning){
        onTeleport.flashWarning = 60; // 1 second warning
      }
      if (onTeleport && onTeleport.flashWarning > 0){
        onTeleport.flashWarning--;
        if (onTeleport.flashWarning === 0){
          // Teleport!
          let newX, newY;
          do {
            newX = randInt(0, GRID_W - 1);
            newY = randInt(0, GRID_H - 1);
          } while ((newX === game.holeX && newY === game.holeY) || 
                   (newX === game.playerX && newY === game.playerY));
          
          spawnSparks(game.playerX, game.playerY, 18, false);
          game.playerX = newX;
          game.playerY = newY;
          spawnSparks(game.playerX, game.playerY, 18, false);
          logEvent("info", "Teleported!");
          setHud("TELEPORT!");
          beep(550, 0.1, "sine", 0.08);
          delete onTeleport.flashWarning;
        }
      }
      
      // Moving hole
      holeMoveTimer--;
      if (holeMoveTimer <= 180 && holeMoveTimer > 0){
        // Flash warning (last 3 seconds)
        holeFlashTimer++;
      }
      if (holeMoveTimer <= 0){
        // Move hole!
        let newHoleX, newHoleY;
        do {
          newHoleX = randInt(0, GRID_W - 1);
          newHoleY = randInt(0, GRID_H - 1);
        } while (newHoleX === game.holeX && newHoleY === game.holeY);
        
        spawnSparks(game.holeX, game.holeY, 24, false);
        game.holeX = newHoleX;
        game.holeY = newHoleY;
        spawnSparks(game.holeX, game.holeY, 24, false);
        holeMoveTimer = randInt(600, 900);
        holeFlashTimer = 0;
        logEvent("info", "Hole teleported!");
        setHud("HOLE MOVED!");
      }
    }
  }
  
  function drawLevelHazards(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    // Draw dark tiles for Glow Stick
    if (theme === "Glow Stick" && darkTiles.length > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      for (let tile of darkTiles){
        ctx.fillRect(tile.x * TILE, tile.y * TILE, TILE, TILE);
      }
    }
    
    // Draw teleport tiles for Spell Stick
    if (theme === "Spell Stick" && teleportTiles.length > 0){
      for (let tile of teleportTiles){
        const x = tile.x * TILE + TILE / 2;
        const y = tile.y * TILE + TILE / 2;
        const pulse = Math.sin(tile.glow) * 0.5 + 0.5;
        
        // Teleport glow
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2 + 4);
        gradient.addColorStop(0, 'rgba(255,105,255,' + (0.4 + pulse * 0.3) + ')');
        gradient.addColorStop(1, 'rgba(255,105,255,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, TILE / 2 + 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Teleport symbol (spiral)
        ctx.strokeStyle = 'rgba(255,105,255,' + (0.6 + pulse * 0.4) + ')';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < Math.PI * 4; i += 0.3){
          const r = (i / (Math.PI * 4)) * 6;
          const px = x + Math.cos(i + tile.glow) * r;
          const py = y + Math.sin(i + tile.glow) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }
    
    ctx.restore();
  }


  // Theme-specific ambient particles
  let ambientParticles = [];
  
  function initAmbientParticles(){
    ambientParticles = [];
    const theme = currentLevelTheme().name;
    
    // Sun Stick: Light rays
    if (theme === "Sun Stick"){
      for (let i = 0; i < 5; i++){
        ambientParticles.push({
          type: 'sunray',
          x: randInt(0, CANVAS_W),
          y: -20,
          angle: Math.random() * 0.4 - 0.2,
          speed: 0.3 + Math.random() * 0.3,
          opacity: Math.random() * 0.3 + 0.1
        });
      }
    }
    
    // Snake Stick: No particles (snakes are the hazard)
    
    // Victory Stick: Green fireflies
    if (theme === "Victory Stick"){
      for (let i = 0; i < 20; i++){
        ambientParticles.push({
          type: 'firefly',
          x: Math.random() * CANVAS_W,
          y: Math.random() * CANVAS_H,
          size: 1 + Math.random() * 1.5,
          glow: Math.random() * Math.PI * 2,
          glowSpeed: 0.03 + Math.random() * 0.04,
          drift: Math.random() * Math.PI * 2,
          driftSpeed: 0.01 + Math.random() * 0.01
        });
      }
    }
  }
  
  let shootingStarTimer = randInt(180, 360);
  
  // Night Stick: Glowing 5-point stars on grid
  let starGridTiles = [];
  let playerGlowTimer = 0;
  let ufo = null;
  
  function initStarGrid(){
    starGridTiles = [];
    const numStars = randInt(8, 12);
    for (let i = 0; i < numStars; i++){
      starGridTiles.push({
        x: randInt(0, GRID_W - 1),
        y: randInt(0, GRID_H - 1),
        twinkle: Math.random() * Math.PI * 2
      });
    }
  }
  
  function updateStarGrid(){
    for (let s of starGridTiles){
      s.twinkle = (s.twinkle + 0.05) % (Math.PI * 2);
      
      // Check if player touched star
      if (s.x === game.playerX && s.y === game.playerY){
        playerGlowTimer = 180; // 3 seconds glow
        spawnSparks(game.playerX, game.playerY, 12, false);
        beep(800, 0.08, "sine", 0.05);
      }
    }
    
    if (playerGlowTimer > 0) playerGlowTimer--;
  }
  
  function drawStarGrid(){
    ctx.save();
    
    // Draw stars on grid
    for (let s of starGridTiles){
      const x = s.x * TILE + TILE / 2;
      const y = s.y * TILE + TILE / 2;
      const twinkle = Math.sin(s.twinkle) * 0.5 + 0.5;
      
      // Glow
      ctx.globalAlpha = 0.2 + twinkle * 0.3;
      const grad = ctx.createRadialGradient(x, y, 0, x, y, TILE / 2);
      grad.addColorStop(0, 'rgba(255,220,100,0.6)');
      grad.addColorStop(1, 'rgba(255,220,100,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, y, TILE / 2, 0, Math.PI * 2);
      ctx.fill();
      
      // 5-point star
      ctx.globalAlpha = 0.7 + twinkle * 0.3;
      ctx.fillStyle = '#ffd166';
      ctx.shadowColor = '#ffd166';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      const size = 4;
      for (let i = 0; i < 5; i++){
        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
        const px = x + Math.cos(angle) * size;
        const py = y + Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
        
        const innerAngle = angle + Math.PI / 5;
        const ipx = x + Math.cos(innerAngle) * (size * 0.4);
        const ipy = y + Math.sin(innerAngle) * (size * 0.4);
        ctx.lineTo(ipx, ipy);
      }
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // ================================================================
  // UFO - Night Stick (roaming abductor)
  // ================================================================
  
  function initUFO(){
    console.log("üõ∏ initUFO() called!");
    ufo = {
      x: randInt(0, GRID_W - 1),
      y: randInt(0, GRID_H - 1),
      moveTimer: 0,
      beamActive: false,
      beamTimer: 0,
      beamWarning: 0,
      float: 0
    };
    console.log("üõ∏ UFO created at position:", ufo.x, ufo.y);
  }
  
  function updateUFO(){
    if (!ufo) return;
    
    ufo.float = (ufo.float + 0.08) % (Math.PI * 2);
    
    // Move UFO randomly every 4-6 seconds
    ufo.moveTimer++;
    if (ufo.moveTimer > randInt(240, 360)){
      ufo.moveTimer = 0;
      const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
      const dir = dirs[randInt(0, 3)];
      ufo.x = clamp(ufo.x + dir.dx, 0, GRID_W - 1);
      ufo.y = clamp(ufo.y + dir.dy, 0, GRID_H - 1);
    }
    
    // Beam mechanic
    if (!ufo.beamActive){
      ufo.beamWarning++;
      if (ufo.beamWarning > randInt(180, 300)){ // 3-5 seconds
        ufo.beamActive = true;
        ufo.beamTimer = 0;
        ufo.beamWarning = 0;
        logEvent("warn", "UFO charging beam!");
        setHud("UFO ALERT!");
        beep(600, 0.1, "sine", 0.06);
      }
    } else {
      ufo.beamTimer++;
      
      // Warning beeps
      if (ufo.beamTimer === 30 || ufo.beamTimer === 60){
        beep(700, 0.08, "sine", 0.05);
      }
      
      // Beam fires - check if player is in the beam (same column AND below UFO)
      if (ufo.beamTimer > 90){
        // Player must be in same column AND below the UFO (where the beam actually is)
        if (game.playerX === ufo.x && game.playerY > ufo.y &&
            !(game.playerX === game.holeX && game.playerY === game.holeY)){
          if (activeShield > 0){
            logEvent("info", "Shield blocked UFO beam!");
            setHud("SHIELD!");
          } else {
            // Teleport player randomly
            const newPos = randomEmptyTile();
            game.playerX = newPos.x;
            game.playerY = newPos.y;
            logEvent("info", "UFO beam teleported you!");
            setHud("ABDUCTED!");
            
            // Sci-fi teleport sound
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = "sine";
            osc.frequency.setValueAtTime(800, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
            
            spawnSparks(game.playerX, game.playerY, 25, false);
          }
        }
        ufo.beamActive = false;
        ufo.beamTimer = 0;
      }
    }
  }
  
  function drawUFO(){
    if (!ufo){
      console.log("üõ∏ drawUFO() called but ufo is null!");
      return;
    }
    
    const x = ufo.x * TILE + TILE / 2;
    const y = ufo.y * TILE + TILE / 2;
    const bob = Math.sin(ufo.float) * 2;
    
    ctx.save();
    ctx.translate(x, y + bob);
    
    // UFO as black glowing triangle craft
    const glowPulse = Math.sin(ufo.float * 2) * 0.3 + 0.7;
    
    // Outer glow aura
    ctx.globalAlpha = 0.2 * glowPulse;
    const outerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
    outerGlow.addColorStop(0, 'rgba(100,100,255,0.4)');
    outerGlow.addColorStop(1, 'rgba(100,100,255,0)');
    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(0, 0, 25, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Main triangle body (black with subtle edge glow)
    ctx.save();
    ctx.rotate(ufo.float * 0.5); // Slow rotation
    
    // Triangle shadow/glow
    ctx.shadowColor = '#6464ff';
    ctx.shadowBlur = 8 * glowPulse;
    
    // Black triangle body
    ctx.fillStyle = '#0a0a0a';
    ctx.strokeStyle = '#1a1a2e';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, -10);  // Top point
    ctx.lineTo(-9, 6);   // Bottom left
    ctx.lineTo(9, 6);    // Bottom right
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Soft white lights on corners
    const cornerLightAlpha = 0.7 + glowPulse * 0.3;
    ctx.globalAlpha = cornerLightAlpha;
    
    // Top corner light
    const topGrad = ctx.createRadialGradient(0, -10, 0, 0, -10, 3);
    topGrad.addColorStop(0, 'rgba(255,255,255,1)');
    topGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = topGrad;
    ctx.beginPath();
    ctx.arc(0, -10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Bottom left corner light
    const leftGrad = ctx.createRadialGradient(-9, 6, 0, -9, 6, 3);
    leftGrad.addColorStop(0, 'rgba(255,255,255,1)');
    leftGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = leftGrad;
    ctx.beginPath();
    ctx.arc(-9, 6, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Bottom right corner light
    const rightGrad = ctx.createRadialGradient(9, 6, 0, 9, 6, 3);
    rightGrad.addColorStop(0, 'rgba(255,255,255,1)');
    rightGrad.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = rightGrad;
    ctx.beginPath();
    ctx.arc(9, 6, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Red center light (brighter when beam active)
    ctx.globalAlpha = ufo.beamActive ? 1 : 0.6;
    const centerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 4);
    centerGrad.addColorStop(0, 'rgba(255,50,50,1)');
    centerGrad.addColorStop(0.5, 'rgba(255,0,0,0.8)');
    centerGrad.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = centerGrad;
    ctx.beginPath();
    ctx.arc(0, 0, 4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    ctx.globalAlpha = 1;
    
    // RED BEAM (subtle, matches center light)
    if (ufo.beamActive){
      const beamAlpha = Math.sin(ufo.beamTimer * 0.2) * 0.08 + 0.18; // More subtle pulse
      
      // Inner soft beam (matches center light intensity)
      const beamGrad = ctx.createLinearGradient(0, 6, 0, 100);
      beamGrad.addColorStop(0, `rgba(255, 50, 50, ${beamAlpha + 0.12})`); // Softer at top
      beamGrad.addColorStop(1, `rgba(200, 30, 30, ${beamAlpha})`); // Darker red at bottom
      ctx.fillStyle = beamGrad;
      ctx.beginPath();
      ctx.moveTo(-3, 6);
      ctx.lineTo(-8, 400);
      ctx.lineTo(8, 400);
      ctx.lineTo(3, 6);
      ctx.closePath();
      ctx.fill();
      
      // Subtle edge glow (not too bright)
      ctx.strokeStyle = "rgba(255, 50, 50, 0.4)";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      // Very subtle outer glow
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#cc0000";
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }
  
  function drawPlayerGlow(){
    if (playerGlowTimer <= 0) return;
    
    const px = game.playerX * TILE + TILE / 2;
    const py = game.playerY * TILE + TILE / 2;
    const pulse = Math.sin(playerGlowTimer * 0.2) * 0.5 + 0.5;
    
    ctx.save();
    ctx.globalAlpha = 0.3 + pulse * 0.4;
    const grad = ctx.createRadialGradient(px, py, 0, px, py, TILE);
    grad.addColorStop(0, 'rgba(255,220,100,0.8)');
    grad.addColorStop(1, 'rgba(255,220,100,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(px, py, TILE, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha = 1;
  } // 3-6 seconds (more frequent!)
  
  function updateAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    // Shooting stars for Night Stick
    if (theme === "Night Stick"){
      shootingStarTimer--;
      if (shootingStarTimer <= 0){
        shootingStarTimer = randInt(600, 1200);
        ambientParticles.push({
          type: 'shootingStar',
          x: Math.random() * CANVAS_W,
          y: Math.random() * (CANVAS_H / 2),
          vx: 2 + Math.random() * 2,
          vy: 0.8 + Math.random() * 1,
          life: 60 + Math.random() * 40
        });
      }
    }
    
    // Remove dead shooting stars
    ambientParticles = ambientParticles.filter(p => p.type !== 'shootingStar' || p.life > 0);
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        p.y += p.speed;
        if (p.y > CANVAS_H + 50){
          p.y = -50;
          p.x = randInt(0, CANVAS_W);
        }
      } else if (p.type === 'star'){
        p.twinkle += p.twinkleSpeed;
      } else if (p.type === 'firefly'){
        p.glow += p.glowSpeed;
        p.drift += p.driftSpeed;
        p.x += Math.sin(p.drift) * 0.3;
        p.y += Math.cos(p.drift * 1.3) * 0.2;
        // Wrap around screen
        if(p.x < 0) p.x = CANVAS_W;
        if(p.x > CANVAS_W) p.x = 0;
        if(p.y < 0) p.y = CANVAS_H;
        if(p.y > CANVAS_H) p.y = 0;
      } else if (p.type === 'shootingStar'){
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
      }
    }
  }
  
  function drawAmbientParticles(){
    const theme = currentLevelTheme().name;
    
    ctx.save();
    
    // Remove dead shooting stars
    ambientParticles = ambientParticles.filter(p => p.type !== 'shootingStar' || p.life > 0);
    
    for (let p of ambientParticles){
      if (p.type === 'sunray'){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.globalAlpha = p.opacity * 0.3;
        
        // Wide beam shape (not stick-like)
        const gradient = ctx.createLinearGradient(0, 0, 0, 60);
        gradient.addColorStop(0, 'rgba(255,212,0,0.6)');
        gradient.addColorStop(1, 'rgba(255,212,0,0)');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.lineTo(-4, 60);
        ctx.lineTo(4, 60);
        ctx.lineTo(8, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      } else if (p.type === 'star' || p.type === 'firefly'){
        if(p.type === 'firefly'){
          // Green firefly for Victory Stick
          const glow = Math.sin(p.glow) * 0.5 + 0.5;
          ctx.globalAlpha = 0.4 + glow * 0.4;
          ctx.fillStyle = '#27ae60'; // Green
          ctx.shadowColor = '#52ffa8';
          ctx.shadowBlur = 8 * glow;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          // Purple star for other levels
          const twinkle = Math.sin(p.twinkle) * 0.5 + 0.5;
          ctx.globalAlpha = 0.3 + twinkle * 0.5;
          ctx.fillStyle = '#c27bff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Star points
          if (twinkle > 0.5){
            ctx.strokeStyle = '#c27bff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p.x - p.size * 2, p.y);
            ctx.lineTo(p.x + p.size * 2, p.y);
            ctx.moveTo(p.x, p.y - p.size * 2);
            ctx.lineTo(p.x, p.y + p.size * 2);
            ctx.stroke();
          }
        }
      } else if (p.type === 'shootingStar'){
        const alpha = p.life / 60;
        ctx.globalAlpha = alpha * 0.9;
        
        // Shooting star trail
        const grad = ctx.createLinearGradient(p.x, p.y, p.x - p.vx * 5, p.y - p.vy * 5);
        grad.addColorStop(0, 'rgba(255,255,200,0.9)');
        grad.addColorStop(1, 'rgba(200,220,255,0)');
        ctx.strokeStyle = grad;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - p.vx * 5, p.y - p.vy * 5);
        ctx.stroke();
        
        // Star head
        ctx.fillStyle = '#ffffff';
        ctx.shadowColor = '#ffffff';
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  // Ice frost effect on screen edges
  function drawIceFrost(){
    if (currentLevelTheme().name !== "Ice Stick") return;
    
    ctx.save();
    
    // Top frost
    const topGrad = ctx.createLinearGradient(0, 0, 0, 40);
    topGrad.addColorStop(0, 'rgba(200,230,255,0.2)');
    topGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = topGrad;
    ctx.fillRect(0, 0, CANVAS_W, 40);
    
    // Bottom frost
    const botGrad = ctx.createLinearGradient(0, CANVAS_H - 40, 0, CANVAS_H);
    botGrad.addColorStop(0, 'rgba(200,230,255,0)');
    botGrad.addColorStop(1, 'rgba(200,230,255,0.2)');
    ctx.fillStyle = botGrad;
    ctx.fillRect(0, CANVAS_H - 40, CANVAS_W, 40);
    
    // Left frost
    const leftGrad = ctx.createLinearGradient(0, 0, 40, 0);
    leftGrad.addColorStop(0, 'rgba(200,230,255,0.15)');
    leftGrad.addColorStop(1, 'rgba(200,230,255,0)');
    ctx.fillStyle = leftGrad;
    ctx.fillRect(0, 0, 40, CANVAS_H);
    
    // Right frost
    const rightGrad = ctx.createLinearGradient(CANVAS_W - 40, 0, CANVAS_W, 0);
    rightGrad.addColorStop(0, 'rgba(200,230,255,0)');
    rightGrad.addColorStop(1, 'rgba(200,230,255,0.15)');
    ctx.fillStyle = rightGrad;
    ctx.fillRect(CANVAS_W - 40, 0, 40, CANVAS_H);
    
    ctx.restore();
  }



  



  // Draw a custom stick monster instead of emoji
  function drawStickMonster(x, y, anger){
    ctx.save();
    ctx.translate(x, y);
    
    // Monster is made of evil sticks!
    const shake = Math.sin(Date.now() / 100) * (anger * 2);
    
    // Body - jagged sticks forming a scary shape
    ctx.strokeStyle = '#ff1f3a';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.shadowColor = '#ff1f3a';
    ctx.shadowBlur = 8;
    
    // Main body sticks (X shape)
    ctx.beginPath();
    ctx.moveTo(-12 + shake, -12);
    ctx.lineTo(12 - shake, 12);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(12 - shake, -12);
    ctx.lineTo(-12 + shake, 12);
    ctx.stroke();
    
    // Extra angry sticks pointing out
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-15, 0);
    ctx.lineTo(-22 + shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(22 - shake, -3);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(3, -22 - shake);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(0, 15);
    ctx.lineTo(-3, 22 + shake);
    ctx.stroke();
    
    // Glowing evil eyes
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#ff5a6a';
    ctx.beginPath();
    ctx.arc(-5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Evil eye pupils
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#1a0005';
    ctx.beginPath();
    ctx.arc(-5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -5, 1.5, 0, Math.PI * 2);
    ctx.fill();
    
    // Angry mouth (jagged)
    ctx.strokeStyle = '#ff5a6a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-6, 4);
    ctx.lineTo(-3, 7);
    ctx.lineTo(0, 4);
    ctx.lineTo(3, 7);
    ctx.lineTo(6, 4);
    ctx.stroke();
    
    ctx.restore();
  }

  // Hole fading for higher levels (7+)
  let holeFadeTimer = 0;
  let holeFadeInterval = 200;
  let holeVisible = true;

  const LOG_MAX_LINES = 12;

  /* ---- Max life bonus points (when a life reward is blocked) ---- */
  const MAX_LIVES = 5;
  const LIFE_TILE_MAX_POINTS = 12;
  const TREE_FEED_MAX_POINTS = 8;

  /* ---- Music ---- */
  const MUSIC_STEP_MS = 245;
  let musicOn = true; // Start with music ON
  let musicTimer = null;
  let musicStep = 0;

  let celebrationUntil = 0;
  let celebrationStep = 0;

  let doomUntil = 0;
  let doomStep = 0;

  const MUSIC_A = [
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.040 },
    { lead:330, bass:98, dur:0.16, gain:0.038 },
    { lead:294, bass:98, dur:0.16, gain:0.038 },
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:392, bass:110, dur:0.16, gain:0.038 },
    { lead:330, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_B = [
    { chord:[294,370,440], bass:110, dur:0.18, gain:0.040 },
    { lead:440, bass:110, dur:0.16, gain:0.040 },
    { lead:494, bass:110, dur:0.16, gain:0.038 },
    { lead:523, bass:110, dur:0.16, gain:0.038 },
    { chord:[330,392,494], bass:82, dur:0.20, gain:0.040 },
    { lead:494, bass:82, dur:0.16, gain:0.040 },
    { lead:440, bass:82, dur:0.16, gain:0.038 },
    { lead:392, bass:82, dur:0.16, gain:0.038 },
    { chord:[262,330,392], bass:98, dur:0.18, gain:0.040 },
    { lead:392, bass:98, dur:0.16, gain:0.038 },
    { lead:330, bass:98, dur:0.16, gain:0.036 },
    { lead:294, bass:98, dur:0.16, gain:0.036 },
    { chord:[247,311,370], bass:92, dur:0.18, gain:0.040 },
    { lead:370, bass:92, dur:0.16, gain:0.038 },
    { lead:330, bass:92, dur:0.16, gain:0.036 },
    { lead:0 }
  ];

  const MUSIC_CELEB = [
    { chord:[523,659,784], bass:131, dur:0.18, gain:0.052 },
    { lead:784, bass:131, dur:0.14, gain:0.050 },
    { lead:988, bass:131, dur:0.14, gain:0.050 },
    { chord:[659,784,988], bass:147, dur:0.18, gain:0.052 },
    { lead:1175, bass:147, dur:0.14, gain:0.050 },
    { lead:988, bass:147, dur:0.14, gain:0.048 },
    { chord:[587,740,880], bass:110, dur:0.18, gain:0.050 },
    { lead:880, bass:110, dur:0.14, gain:0.048 },
    { lead:988, bass:110, dur:0.14, gain:0.048 },
    { chord:[659,784,988], bass:131, dur:0.18, gain:0.052 },
    { lead:0 }
  ];

  const MUSIC_DOOM = [
    { lead:988, dur:0.14, gain:0.080, type:"square" },
    { lead:932, dur:0.14, gain:0.080, type:"square" },
    { lead:880, dur:0.14, gain:0.080, type:"square" },
    { lead:784, dur:0.16, gain:0.082, type:"square" },
    { lead:698, dur:0.18, gain:0.082, type:"square" },
    { lead:622, dur:0.20, gain:0.082, type:"square" },
    { lead:554, dur:0.22, gain:0.082, type:"square" },
    { lead:466, dur:0.24, gain:0.082, type:"square" },
    { lead:392, dur:0.28, gain:0.082, type:"square" },
    { lead:0 }
  ];

  function startCelebrationMusic(ms=6500){
    if (!musicOn) return;
    celebrationUntil = Date.now() + ms;
    celebrationStep = 0;
  }
  function startDoomMusic(ms=6500){
    if (!musicOn) return;
    doomUntil = Date.now() + ms;
    doomStep = 0;
  }

  function pickMusicStep(stepIdx){
    const block = Math.floor(stepIdx / 32);
    const useB = (block % 2 === 1);
    const seq = useB ? MUSIC_B : MUSIC_A;
    const s = seq[stepIdx % seq.length];
    if (s && s.lead && Math.random() < 0.10){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickCelebrationStep(){
    const s = MUSIC_CELEB[celebrationStep++ % MUSIC_CELEB.length];
    if (s && s.lead && Math.random() < 0.18){
      return { ...s, lead: s.lead * 2 };
    }
    return s;
  }
  function pickDoomStep(){
    const s = MUSIC_DOOM[doomStep++ % MUSIC_DOOM.length];
    return s;
  }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  canvas.width = CANVAS_W;
  canvas.height = CANVAS_H;

  const ui = {
    log: document.getElementById("log"),
    battleLog: document.getElementById("battleLog"),
    themeMini: document.getElementById("uiThemeMini"),
    controlsScroll: document.getElementById("controlsScroll"),
    scrollHint: document.getElementById("scrollHint"),

    player: document.getElementById("uiPlayer"),
    skin: document.getElementById("uiSkin"),

    lives: document.getElementById("uiLives"),
    level: document.getElementById("uiLevel"),
    score: document.getElementById("uiScore"),
    actions: document.getElementById("uiActions"),
    mode: document.getElementById("uiMode"),
    die: document.getElementById("uiDie"),
    carry: document.getElementById("uiCarry"),
    left: document.getElementById("uiLeft"),

    diceBox: document.getElementById("diceBox"),
    diceFace: document.getElementById("diceFace"),
    diceLabel: document.getElementById("diceLabel"),

    btnRoll: document.getElementById("btnRoll"),
    btnUse: document.getElementById("btnUse"),
    btnNew: document.getElementById("btnNew"),
    btnPause: document.getElementById("btnPause"),
    btnMusic: document.getElementById("btnMusic"),

    btnUp: document.getElementById("btnUp"),
    btnDown: document.getElementById("btnDown"),
    btnLeft: document.getElementById("btnLeft"),
    btnRight: document.getElementById("btnRight"),

    btnSave: document.getElementById("btnSave"),
    btnLoad: document.getElementById("btnLoad"),

    infoOverlay: document.getElementById("infoOverlay"),
    btnInfo: document.getElementById("btnInfo"),
    btnInfoClose: document.getElementById("btnInfoClose"),

    nameOverlay: document.getElementById("nameOverlay"),
    nameInput: document.getElementById("nameInput"),
    nameStartBtn: document.getElementById("nameStartBtn"),
    nameUseSavedBtn: document.getElementById("nameUseSavedBtn"),
    nameUseP1Btn: document.getElementById("nameUseP1Btn"),
    savedNameHint: document.getElementById("savedNameHint"),

    pauseOverlay: document.getElementById("pauseOverlay"),
    btnPauseClose: document.getElementById("btnPauseClose"),

    gameOverOverlay: document.getElementById("gameOverOverlay"),
    gameOverText: document.getElementById("gameOverText"),
    btnRestart: document.getElementById("btnRestart"),
    btnGameOverClose: document.getElementById("btnGameOverClose"),

    winOverlay: document.getElementById("winOverlay"),
    winText: document.getElementById("winText"),
    btnWinRestart: document.getElementById("btnWinRestart"),
    btnWinClose: document.getElementById("btnWinClose"),

    leaderboard: document.getElementById("leaderboard"),

    monsterEvent: document.getElementById("monsterEvent"),
    monsterEventText: document.getElementById("monsterEventText"),

    winFx: document.getElementById("winFx"),
    loseFx: document.getElementById("loseFx"),
  };

  const LOG_STYLE = {
    neutral: { color:"#e5e7eb", icon:"" },
    roll:    { color:"#e5e7eb", icon:"üé≤ " },
    place:   { color:"#e5e7eb", icon:"üìç " },
    pickup:  { color:"#e5e7eb", icon:"ü™µ " },
    deposit: { color:"#39ff95", icon:"‚ú® " },
    bonus:   { color:"#c27bff", icon:"üí• " },
    level:   { color:"#ffd166", icon:"üèÜ " },
    warn:    { color:"#ffb347", icon:"‚ö†Ô∏è " },
    bad:     { color:"#ff5a6a", icon:"üíÄ " },
    monster: { color:"#ff1f3a", icon:"üëπ " },
    save:    { color:"#ffd166", icon:"üíæ " },
    load:    { color:"#a8dadc", icon:"üìÇ " },
    win:     { color:"#f3f4f6", icon:"üåü " },
  };

  function prependToLog(el, line){
    if (!el) return;
    el.prepend(line);
    while (el.children.length > LOG_MAX_LINES) el.removeChild(el.lastChild);
  }

  function logEvent(kind, msg){
    const st = LOG_STYLE[kind] || LOG_STYLE.neutral;

    const line1 = document.createElement("div");
    line1.className = "line";
    line1.style.color = st.color;
    line1.textContent = (st.icon || "") + msg;

    const line2 = line1.cloneNode(true);

    prependToLog(ui.log, line1);
    prependToLog(ui.battleLog, line2);
  }

  function loadLeaderboard(){
    try{
      const raw = localStorage.getItem(LS_LEADERBOARD);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveLeaderboard(arr){
    localStorage.setItem(LS_LEADERBOARD, JSON.stringify(arr));
  }
  function upsertLeaderboardEntry(name, score, level){
    const n = (name || "PLAYER1").toUpperCase();
    const lb = loadLeaderboard();
    const filtered = lb.filter(e => (e?.name || "").toUpperCase() !== n);
    filtered.push({ name:n, score: Number(score)||0, level: Number(level)||1 });
    filtered.sort((x,y) => {
      if (y.score !== x.score) return y.score - x.score;
      return y.level - x.level;
    });
    const top3 = filtered.slice(0,3);
    saveLeaderboard(top3);
    renderLeaderboard(top3);
  }
  function renderLeaderboard(lb){
    const rows = (lb && lb.length) ? lb : loadLeaderboard();
    ui.leaderboard.innerHTML = "";
    if (!rows.length){
      ui.leaderboard.innerHTML = `<div style="color:#9fb1c6;">No scores yet. Play a game.</div>`;
      return;
    }
    const medals = ["gold","silver","bronze"];
    rows.forEach((e, idx) => {
      const wrap = document.createElement("div");
      wrap.className = "leaderRow";
      const medalClass = medals[idx] || "";
      wrap.innerHTML = `
        <div>
          <div class="leaderName ${medalClass}">${escapeHtml(e.name || "PLAYER1")}</div>
          <div class="leaderMeta">Lvl ${Number(e.level)||1}</div>
        </div>
        <div class="big">${Number(e.score)||0}</div>
      `;
      ui.leaderboard.appendChild(wrap);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function isPhone(){
    return window.matchMedia && window.matchMedia("(max-width:720px)").matches;
  }
  function updateScrollHint(){
    if (!ui.scrollHint || !ui.controlsScroll) return;
    if (!isPhone()){ ui.scrollHint.style.display = "none"; return; }
    if (sessionStorage.getItem(SS_SCROLLED) === "1"){ ui.scrollHint.style.display = "none"; return; }
    const canScroll = ui.controlsScroll.scrollHeight > (ui.controlsScroll.clientHeight + 6);
    const atTop = ui.controlsScroll.scrollTop <= 2;
    ui.scrollHint.style.display = (canScroll && atTop) ? "block" : "none";
  }
  ui.controlsScroll?.addEventListener("scroll", () => {
    if (!isPhone()) return;
    if (ui.controlsScroll.scrollTop > 20){
      sessionStorage.setItem(SS_SCROLLED, "1");
      updateScrollHint();
    }
  }, { passive:true });
  window.addEventListener("resize", () => setTimeout(updateScrollHint, 60), { passive:true });

  /* ---------- AUDIO ---------- */
  let audioCtx = null;
  let audioUnlocked = false;

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  async function unlockAudio(){
    try{
      ensureAudio();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      g.gain.value = 0.00001;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + 0.01);
      audioUnlocked = true;
    }catch(_){}
  }
  const unlockOnce = async () => {
    if (audioUnlocked) return;
    await unlockAudio();
  };
  document.addEventListener("touchstart", unlockOnce, { passive:true });
  document.addEventListener("pointerdown", unlockOnce, { passive:true });

  function beep(freq=440, dur=0.08, type="sine", gain=0.08){
    try{
      ensureAudio();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);

      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.linearRampToValueAtTime(0, t0 + dur);

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }catch(e){}
  }
  function chord(freqs=[440,550], dur=0.12, gain=0.05, type="triangle"){
    freqs.forEach((f)=>beep(f, dur, type, gain));
  }

  function startMusic(){
    ensureAudio();
    if (musicTimer) return;
    musicStep = 0;
    musicTimer = setInterval(() => {
      if (!musicOn) return;
      if (game.pendingMonster) return;

      const now = Date.now();
      const inDoom = now < doomUntil;
      const inCelebration = (!inDoom) && (now < celebrationUntil);

      const step = inDoom ? pickDoomStep() : (inCelebration ? pickCelebrationStep() : pickMusicStep(musicStep++));
      if (!step) return;

      const hasChord = Array.isArray(step.chord) && step.chord.length;
      const hasLead  = step.lead && !hasChord;
      const hasBass  = step.bass;

      if (!hasChord && !hasLead && !hasBass) return;

      const dur  = step.dur  ?? 0.16;
      const gain = step.gain ?? 0.040;
      const oscType = step.type || "triangle";

      if (hasChord){
        chord(step.chord, dur, gain, oscType);
      } else if (hasLead){
        beep(step.lead, dur, oscType, gain);
      }
      if (hasBass){
        beep(step.bass, dur * 1.2, "sine", gain * 0.70);
      }
    }, MUSIC_STEP_MS);
  }
  function stopMusic(){
    if (musicTimer){ clearInterval(musicTimer); musicTimer = null; }
  }

  /* ---- Pause (true pause: stops loop, stops music, freezes timeouts) ---- */
  let paused = false;
  let rafId = null;
  let pauseStartedAt = 0;
  let pausePrevInputLocked = false;
  let pausePrevMusicOn = false;

  const activeTimeouts = new Map();
  let pausedTimeouts = [];

  function gameSetTimeout(fn, ms){
    const due = Date.now() + ms;
    const id = setTimeout(() => {
      activeTimeouts.delete(id);
      fn();
    }, ms);
    activeTimeouts.set(id, { fn, due });
    return id;
  }
  function pauseAllGameTimeouts(){
    const now = Date.now();
    pausedTimeouts = [];
    for (const [id, meta] of activeTimeouts.entries()){
      clearTimeout(id);
      pausedTimeouts.push({ fn: meta.fn, ms: Math.max(0, meta.due - now) });
    }
    activeTimeouts.clear();
  }
  function resumeAllGameTimeouts(){
    const list = pausedTimeouts.slice();
    pausedTimeouts = [];
    list.forEach(t => gameSetTimeout(t.fn, t.ms));
  }

  function startLoop(){
    if (rafId) return;
    rafId = requestAnimationFrame(loop);
  }

  function stopMonsterDoom(){
    if (monsterDoomStingTimer){
      clearTimeout(monsterDoomStingTimer);
      monsterDoomStingTimer = null;
    }
  }

  function pauseGame(){
    if (paused) return;
    if (ui.nameOverlay.style.display === "flex") return;

    paused = true;
    pauseStartedAt = Date.now();

    pausePrevInputLocked = game.inputLocked;
    game.inputLocked = true;

    pausePrevMusicOn = musicOn;
    if (musicOn) stopMusic();
    stopMonsterDoom();

    pauseAllGameTimeouts();

    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
    }

    ui.pauseOverlay.style.display = "flex";
    ui.btnPause.textContent = "‚ñ∂ Resume";
  }

  function resumeGame(){
    if (!paused) return;

    const now = Date.now();
    const delta = Math.max(0, now - pauseStartedAt);

    if (celebrationUntil) celebrationUntil += delta;
    if (doomUntil) doomUntil += delta;

    paused = false;

    ui.pauseOverlay.style.display = "none";
    ui.btnPause.textContent = "‚è∏ Pause";

    game.inputLocked = pausePrevInputLocked;

    resumeAllGameTimeouts();
    startLoop();

    if (pausePrevMusicOn && musicOn){
      startMusic();
      if (game.pendingMonster) playMonsterDoomSting();
    }
  }

  function togglePause(){
    if (paused) resumeGame();
    else pauseGame();
  }

  /* ---- Stick Monster: doom sting (battle intro) ---- */
  let monsterDoomStingTimer = null;

  function playMonsterDoomSting(){
    if (!musicOn) return;
    ensureAudio();
    stopMonsterDoom();

    const seq = [
      () => { beep(55, 0.22, "sawtooth", 0.10); beep(73.4, 0.20, "sawtooth", 0.08); chord([110,131,165], 0.14, 0.055, "triangle"); },
      () => { beep(49, 0.22, "sawtooth", 0.10); chord([98,117,147], 0.16, 0.055, "triangle"); },
      () => { beep(55, 0.26, "sawtooth", 0.10); chord([110,147,165], 0.14, 0.055, "triangle"); },
      () => { beep(41.2, 0.28, "sawtooth", 0.10); chord([82,98,123], 0.18, 0.055, "triangle"); },
      () => { beep(55, 0.30, "sawtooth", 0.10); chord([110,131,165], 0.18, 0.055, "triangle"); }
    ];

    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (!game.pendingMonster) return;
      if (i >= seq.length) return;
      seq[i++]();
      monsterDoomStingTimer = gameSetTimeout(step, 480);
    };
    step();
  }

  function playPacmanDeathSting(){
    if (!musicOn) return;
    ensureAudio();
    const notes = [988, 932, 880, 784, 698, 622, 554, 466, 392];
    let i = 0;
    const step = () => {
      if (!musicOn) return;
      if (i >= notes.length) return;
      beep(notes[i++], 0.11 + i*0.01, "square", 0.095);
      gameSetTimeout(step, 90);
    };
    step();
  }

  /* ---- SFX ---- */
  function sfxRoll(){ beep(320,0.06,"square",0.06); beep(420,0.07,"square",0.05); }
  function sfxPickup(){ beep(740,0.06,"triangle",0.07); }
  function sfxPlace(){ beep(420,0.07,"triangle",0.05); }
  function sfxDeposit(){ chord([520,660,780],0.14,0.06,"triangle"); }
  function sfxError(){ beep(160,0.08,"sawtooth",0.06); }
  function sfxZeroBad(){ beep(120,0.10,"sawtooth",0.07); beep(90,0.12,"sawtooth",0.06); }
  function sfxBonus(){ chord([660,880],0.16,0.06,"triangle"); }
  // Special power-up stick sounds
  function playSpeedStickSound(){
    // Fast ascending notes
    setTimeout(() => beep(440, 0.08, "square", 0.12), 0);
    setTimeout(() => beep(554, 0.08, "square", 0.12), 80);
    setTimeout(() => beep(659, 0.08, "square", 0.12), 160);
    setTimeout(() => beep(880, 0.12, "square", 0.15), 240);
  }
  
  function playShieldStickSound(){
    // Power-up ascending chord
    setTimeout(() => chord([330, 440, 554], 0.15, 0.1, "triangle"), 0);
    setTimeout(() => chord([440, 554, 659], 0.15, 0.1, "triangle"), 150);
    setTimeout(() => chord([554, 659, 880], 0.2, 0.12, "triangle"), 300);
  }
  
  function playVisionStickSound(){
    // Mystical sparkle sound
    setTimeout(() => beep(659, 0.08, "sine", 0.1), 0);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 70);
    setTimeout(() => beep(1047, 0.08, "sine", 0.1), 140);
    setTimeout(() => beep(880, 0.08, "sine", 0.1), 210);
    setTimeout(() => beep(1175, 0.15, "sine", 0.12), 280);
  }

  function sfxExtraLife(){ chord([523,659,784],0.20,0.06,"triangle"); chord([659,784,988],0.22,0.06,"triangle"); }
  function sfxMonsterHit(){ beep(70,0.16,"sawtooth",0.08); beep(55,0.18,"sawtooth",0.08); }
  function sfxLevelUp(){
    chord([440,660,880],0.18,0.06,"triangle");
    chord([494,740,988],0.18,0.06,"triangle");
    chord([523,784,1046],0.22,0.06,"triangle");
  }
  function sfxWin(){
    // Pac-Man style victory fanfare
    setTimeout(() => beep(523,0.12,"square",0.15), 0);      // C5
    setTimeout(() => beep(659,0.12,"square",0.15), 150);    // E5
    setTimeout(() => beep(784,0.12,"square",0.15), 300);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 450);   // C6
    setTimeout(() => beep(784,0.12,"square",0.15), 600);    // G5
    setTimeout(() => beep(1047,0.12,"square",0.15), 750);   // C6
    setTimeout(() => beep(1047,0.12,"square",0.15), 900);   // C6
    setTimeout(() => beep(1047,0.18,"square",0.15), 1050);  // C6 final
  }

  const player = { name: "PLAYER1" };

  function sanitizeName(s){
    return (s || "").trim().replace(/\s+/g," ").slice(0,16);
  }
  function getSavedName(){
    const saved = localStorage.getItem(LS_PLAYER_NAME);
    const name = saved ? sanitizeName(saved).toUpperCase() : "";
    return name || "";
  }
  function setAndStoreName(name){
    const n = (sanitizeName(name) || "PLAYER1").toUpperCase();
    player.name = n;
    localStorage.setItem(LS_PLAYER_NAME, n);
    ui.player.textContent = n;
  }

  function getSavedSkin(){
    const raw = (localStorage.getItem(LS_PLAYER_SKIN) || "").toLowerCase();
    if (raw === "bighead" || raw === "alien") return "alien";
    if (raw === "runner" || raw === "sally") return "sally";
    if (raw === "rick") return "rick";
    if (raw === "robot") return "robot";
    return "classic";
  }
  function setAndStoreSkin(s){
    let val = (s || "classic").toLowerCase();
    if (val === "bighead") val = "alien";
    if (val === "runner") val = "sally";
    const allowed = ["classic","alien","sally","rick","robot","rex"];
    const skin = allowed.includes(val) ? val : "classic";
    game.playerSkin = skin;
    localStorage.setItem(LS_PLAYER_SKIN, skin);
    if (ui.skin) ui.skin.value = skin;
  }

  const game = {
    level: 1,
    lives: 3,
    score: 0,
    actions: 0,

    bonusActive: false,
    bonusExtraRollReady: false,
    bonusPendingRoll: false,
    bonusMovesDoubled: false,

    playerSkin: "classic",

    playerX: 2,
    playerY: 2,
    carry: [],
    sticks: [],
    holeX: 12,
    holeY: 12,

    lifeTileX: -1,
    lifeTileY: -1,
    lifeTileUsed: false,

    treeX: -1,
    treeY: -1,
    treeActive: false,
    treePhase: "hidden",
    treePhaseTimer: 0,
    treeSpawnDelay: 0,
    treeSpawnedThisLevel: false,

    pendingMonster: null,
    monsterWinStreak: 0,

    hudMsg: "",
    hudTimer: 0,
    holePulse: 0,
    holeFlash: 0,
    sparks: [],

    inputLocked: false,
    
    // Mountain Stick: track traversal progress
    mountainTraversal: null // {x, y, total, remaining}
  };

  function carryCap(){
    const base = Math.min(6, 3 + Math.floor((game.level - 1) / 3));
    let cap = game.bonusActive ? (base + 2) : base;
    // BANANA BUNDLE - double capacity!
    if(bananaMode) cap *= 2;
    return cap;
  }
  function sticksToSpawnForLevel(level){
    return 6 + (level-1)*3;
  }
  function zeroChance(level){
    return Math.min(0.18, 0.00 + (level-1)*0.015);
  }
  function curseChance(level){
    return Math.min(0.16, 0.08 + (level-1)*0.015);
  }
  function bonusChance(level){
    return Math.min(0.22, 0.10 + (level-1)*0.01);
  }

  function setHud(msg){
    game.hudMsg = msg;
    game.hudTimer = 60;
  }

  function currentLevelTheme(){
    const idx = clamp(game.level - 1, 0, LEVELS.length - 1);
    return LEVELS[idx];
  }

  function applyThemeForLevel(){
    const t = currentLevelTheme();
    if (ui.themeMini) ui.themeMini.textContent = t.name;
    document.documentElement.style.setProperty("--lvlBg", t.bg);
    document.documentElement.style.setProperty("--lvlBorder", t.border);
    document.documentElement.style.setProperty("--lvlAccentGlow", t.accentGlow);
    document.documentElement.style.setProperty("--lvlAccentShadow", t.accentShadow);
  }

  function isOccupiedByStick(x,y){
    return game.sticks.some(s => s.x===x && s.y===y);
  }
  function isHole(x,y){ return x===game.holeX && y===game.holeY; }
  function isLifeTile(x,y){
    return !game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY;
  }
  function isTreeTile(x,y){
    return game.treeActive && x===game.treeX && y===game.treeY;
  }

  function randomEmptyTile(){
    for (let i=0;i<2000;i++){
      const x = randInt(0, GRID_W-1);
      const y = randInt(0, GRID_H-1);
      if ((x===game.playerX && y===game.playerY) || isHole(x,y) || isOccupiedByStick(x,y)) continue;
      if (!game.lifeTileUsed && x===game.lifeTileX && y===game.lifeTileY) continue;
      if (game.treeActive && x===game.treeX && y===game.treeY) continue;
      
      // Avoid hazard tiles
      if (fireTiles && fireTiles.some(f => f.x === x && f.y === y)) continue;
      if (windTiles && windTiles.some(w => w.x === x && w.y === y)) continue;
      if (freezeTiles && freezeTiles.some(f => f.x === x && f.y === y)) continue;
      
      return {x,y};
    }
    return {x:0,y:0};
  }

  function spawnHole(){
    if (game.level === 1){
      game.holeX = Math.floor(GRID_W/2);
      game.holeY = Math.floor(GRID_H/2);
      return;
    }
    game.holeX = randInt(6, GRID_W-7);
    game.holeY = randInt(6, GRID_H-7);
  }


  // Spawn special power-up sticks (rare)
  function maybeSpawnSpecialSticks(){
    const theme = currentLevelTheme().name;
    const level = game.level;
    
    // Special sticks only appear from level 3 onwards
    if (level < 3) return;
    
    // 20% chance per level to spawn ONE special stick
    if (Math.random() < 0.2){
      const p = randomEmptyTile();
      const types = ['speed', 'shield', 'vision'];
      const type = types[randInt(0, 2)];
      
      let color = '#3aa7ff'; // Speed = blue
      if (type === 'shield') color = '#39ff95'; // Shield = green
      if (type === 'vision') color = '#ffd400'; // Vision = yellow
      
      game.sticks.push({ 
        x: p.x, 
        y: p.y, 
        color: color, 
        cursed: false, 
        bonus: false,
        special: type
      });
    }
  }
  function spawnSticksForLevel(level){
    game.sticks = [];
    const n = sticksToSpawnForLevel(level);
    const cc = curseChance(level);
    const bc = bonusChance(level);

    for (let i=0;i<n;i++){
      const p = randomEmptyTile();
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      const cursed = Math.random() < cc;
      const bonus = !cursed && (Math.random() < bc);
      game.sticks.push({ x:p.x, y:p.y, color, cursed, bonus });
    }
    if (game.sticks.length > 0 && !game.sticks.some(s => s.cursed)){
      const idx = randInt(0, game.sticks.length - 1);
      game.sticks[idx].cursed = true;
      game.sticks[idx].bonus = false;
    }
  }

  function spawnLifeTile(){
    const p = randomEmptyTile();
    game.lifeTileX = p.x;
    game.lifeTileY = p.y;
    game.lifeTileUsed = false;
  }

  function clearTree(){
    game.treeActive = false;
    game.treePhase = "hidden";
    game.treePhaseTimer = 0;
    game.treeX = -1;
    game.treeY = -1;
  }

  function scheduleTreeForLevel(){
    clearTree();
    game.treeSpawnedThisLevel = false;
    game.treeSpawnDelay = 60 * randInt(30, 300); // 30 seconds ‚Äì 5 minutes
  }

  function spawnTreeNow(){
    const p = randomEmptyTile();
    game.treeX = p.x;
    game.treeY = p.y;
    game.treeActive = true;
    game.treePhase = "visible";
    game.treePhaseTimer = 60 * 15;
    game.treeSpawnedThisLevel = true;

    logEvent("bonus","A tree appears... (15s)");
    setHud("TREE APPEARS!");
    
    // Tree chime!
    setTimeout(() => beep(523, 0.12, "sine", 0.08), 0);
    setTimeout(() => beep(659, 0.12, "sine", 0.08), 120);
    setTimeout(() => beep(784, 0.15, "sine", 0.10), 240);
  }

  function startTreeBlinking(){
    game.treePhase = "blinking";
    game.treePhaseTimer = 60 * 15;
    logEvent("warn","Tree is blinking... hurry!");
    setHud("TREE BLINKING!");
  }

  function endTree(){
    clearTree();
    logEvent("warn","The tree fades away.");
    setHud("TREE GONE");
  }

  function showNameModal(){
    game.inputLocked = true;
    ui.nameOverlay.style.display = "flex";
    ui.nameInput.value = "";
    ui.nameInput.placeholder = "ENTER NAME";

    const saved = getSavedName();
    if (saved && saved !== "PLAYER1"){
      ui.savedNameHint.style.display = "block";
      ui.savedNameHint.textContent = `Saved on this device: ${saved}`;
      ui.nameUseSavedBtn.style.display = "inline-block";
      ui.nameUseSavedBtn.textContent = `Use ${saved}`;
    }else{
      ui.savedNameHint.style.display = "none";
      ui.nameUseSavedBtn.style.display = "none";
    }

    gameSetTimeout(()=>ui.nameInput.focus(), 50);
  }
  function closeNameModal(){
    ui.nameOverlay.style.display = "none";
    game.inputLocked = false;
  }
  function startFromNameInput(){
    const entered = sanitizeName(ui.nameInput.value);
    if (!entered) setAndStoreName("PLAYER1");
    else setAndStoreName(entered);
    closeNameModal();
    newGame(true);
  }

  function resetCoreState(){
    game.level = 1;
    game.lives = 3;
    game.score = 0;
    game.actions = 0;

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    game.carry = [];
    game.sticks = [];
    game.sparks = [];
    game.holePulse = 0;
    game.holeFlash = 0;
    game.hudMsg = "";
    game.hudTimer = 0;

    game.playerX = 2;
    game.playerY = 2;

    game.lifeTileX = -1;
    game.lifeTileY = -1;
    game.lifeTileUsed = false;

    scheduleTreeForLevel();

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    game.monsterWinStreak = 0;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();

    if (ui.log) ui.log.innerHTML = "";
    if (ui.battleLog) ui.battleLog.innerHTML = "";
    logEvent("neutral","Welcome to STICKS.");
    logEvent("neutral","Roll to begin.");

    setAndStoreSkin(getSavedSkin());
    
    // Init wind tiles for Sky Stick
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
    }
    
    // Init snakes for Snake Stick
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    // Init freeze zones for Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Init shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    // Init sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      bubbles = [];
    }
    
    // Init sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick"){
      initSunBursts();
    } else {
      sunBurstTiles = [];
      sunBurstWarningTimer = 0;
    }
    
    // Init star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
    } else {
      starGridTiles = [];
      playerGlowTimer = 0;
    }
    
    // Init Spell Stick - moving teleports + moving hole
    if (currentLevelTheme().name === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      teleportTiles = [];
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900);
      holeFlashTimer = 0;
    } else if (currentLevelTheme().name !== "Victory Stick") {
      teleportTiles = [];
      teleportMoveTimer = 0;
      holeMoveTimer = 0;
      holeFlashTimer = 0;
    }
    
    // Init Ice Stick wind sound and snowman
    if (currentLevelTheme().name === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      stopIceWindSound();
      snowman = null;
    }
    
    // Init Spider Stick
    if (currentLevelTheme().name === "Spider Stick"){
      initSpiderWebs();
      initSpiders();
    } else {
      spiderWebs = [];
      spiders = [];
    }
    
    // Init Banana Stick
    if (currentLevelTheme().name === "Banana Stick"){
      initBananas();
      initMonkeys();
    } else if (currentLevelTheme().name !== "Victory Stick") {
      bananas = [];
      monkeys = [];
    }
    
    // Init Mountain Stick
    if (currentLevelTheme().name === "Mountain Stick"){
      initMountains();
      initRams();
    } else if (currentLevelTheme().name !== "Victory Stick") {
      mountains = [];
      mountainClouds = [];
      rams = [];
    }
    
    // Init Cursed Stick
    if (currentLevelTheme().name === "Cursed Stick"){
      initCursedStick();
    } else if (currentLevelTheme().name !== "Victory Stick") {
      ghosts = [];
      skulls = [];
      smokeParticles = [];
      isSkeletonMode = false;
    }
    
    // Init Skunk Stick
    if (currentLevelTheme().name === "Skunk Stick"){
      initSkunks();
    } else {
      skunks = [];
      stinkClouds = [];
    }
    
    
    // Initialize snowflakes if starting on Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize mountains for Mountain Stick
    console.log("Current level theme:", currentLevelTheme().name);
    console.log("Checking for Mountain Stick...");
    if (currentLevelTheme().name === "Mountain Stick"){
      console.log("‚úì Mountain Stick detected! Calling initMountains()");
      initMountains();
      initRams();
    } else {
      mountains = [];
      mountainClouds = [];
      rams = [];
    }
    
    // Initialize bananas and monkey for Banana Stick
    console.log("Checking for Banana Stick...");
    if (currentLevelTheme().name === "Banana Stick"){
      console.log("‚úì Banana Stick detected! Calling init functions");
      initBananas();
      initMonkeys();
    } else {
      bananas = [];
      monkeys = [];
    }
    
    // Initialize fire tiles if starting on Fire Stick
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset all effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;// Reset hole visibility
    holeVisible = true;
    holeFadeTimer = 0;

    gameSetTimeout(updateScrollHint, 60);
  }

  function commitScoreToLeaderboard(){
    upsertLeaderboardEntry(player.name, game.score, game.level);
  }

  function burstFx(el, emoji, count=26){
    if (!el) return;
    el.innerHTML = "";
    const w = el.clientWidth || 680;
    for (let i=0;i<count;i++){
      const s = document.createElement("span");
      s.textContent = emoji;
      s.style.left = randInt(0, w) + "px";
      s.style.top  = randInt(-20, 30) + "px";
      s.style.animationDuration = (1.2 + Math.random()*0.9) + "s";
      s.style.transform = `translateY(0) rotate(${randInt(0,180)}deg)`;
      el.appendChild(s);
    }
  }

  function winGame(){
    commitScoreToLeaderboard();

    burstFx(ui.winFx, "‚ú®", 50); // More particles!

    ui.winText.textContent = `üèÜ ULTIMATE VICTORY! üèÜ\n${player.name}\nFinal Score: ${game.score}\n\n‚ú® ALL 15 LEVELS CONQUERED! ‚ú®\n\nYou've mastered every stick.\nThe hole is satisfied.\nThe monster retreats... for now.\n\nüéÆ LEGEND STATUS ACHIEVED! üéÆ`;
    ui.winOverlay.style.display = "flex";
    game.inputLocked = true;

    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    setHud("üèÜ VICTORY! üèÜ");
    logEvent("win","Victory Stick cleared. COMPLETE VICTORY!");

    spawnSparks(game.holeX, game.holeY, 60, false); // More sparks!
    spawnSparks(game.playerX, game.playerY, 40, false);

    sfxWin();
    startCelebrationMusic(12000); // Longer celebration!
  }

  function newLevel(){
    console.log("üéÆ newLevel() called! Current game.level:", game.level);
    if (game.level > 15){
      winGame();
      updateUI();
      return;
    }

    game.level++;
    console.log("üìà Level incremented to:", game.level);
    
    // Clear mountain traversal state
    game.mountainTraversal = null;
    
    applyThemeForLevel();
    console.log("üé® Theme applied:", currentLevelTheme().name);
    
    // Initialize star grid and UFO for Night Stick
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
      initUFO();
    } else {
      starGridTiles = [];
      playerGlowTimer = 0;
      ufo = null;
    }
    
    // Initialize Sparkle Stick features
    if (currentLevelTheme().name === "Sparkle Stick"){
      initSparkleStick();
    } else {
      rainbows = [];
      sparkleTrail = 0;
      flowerRain = false;
      flowerRainParticles = [];
      cupcakeMode = 0;
    }
    
    // Initialize snowflakes for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    // Initialize mountains for Mountain Stick
    console.log("Current level theme:", currentLevelTheme().name);
    console.log("Checking for Mountain Stick...");
    if (currentLevelTheme().name === "Mountain Stick"){
      console.log("‚úì Mountain Stick detected! Calling initMountains()");
      initMountains();
      initRams();
    } else {
      mountains = [];
      mountainClouds = [];
      rams = [];
    }
    
    // Initialize bananas and monkey for Banana Stick
    console.log("Checking for Banana Stick...");
    if (currentLevelTheme().name === "Banana Stick"){
      console.log("‚úì Banana Stick detected! Calling init functions");
      initBananas();
      initMonkeys();
    } else {
      bananas = [];
      monkeys = [];
      bananaMode = false; // Clear banana mode when leaving level
    }
    
    // Initialize wind tiles for Sky Stick
    if (currentLevelTheme().name === "Sky Stick"){
      initWindTiles();
      initSkyClouds();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
      skyClouds = [];
      cloudTrails = [];
      airplane.active = false;
    }
    
    // Initialize Cursed Stick features
    if (currentLevelTheme().name === "Cursed Stick"){
      initCursedStick();
    } else {
      ghosts = [];
      skulls = [];
      isSkeletonMode = false;
      smokeParticles = [];
    }
    
    // Initialize snakes for Snake Stick
    if (currentLevelTheme().name === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    // Initialize freeze zones for Ice Stick
    if (currentLevelTheme().name === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    // Initialize shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    if (currentLevelTheme().name === "Spider Stick"){
      initSpiderWebs();
      initSpiders();
    } else {
      spiderWebs = [];
      spiders = [];
    }
    
    if (currentLevelTheme().name === "Skunk Stick"){
      initSkunks();
    } else {
      skunks = [];
      stinkClouds = [];
    }
    
    // Initialize sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick"){
      initSharks();
    } else {
      sharks = [];
      bubbles = [];
      scubaDiver = null;
    }
    
    // Initialize sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick"){
      initSunBursts();
      initSunCharacter();
    } else {
      sunBurstTiles = [];
      sunBurstWarningTimer = 0;
      sunCharacter.active = false;
    }
    
    // Initialize star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
      initUFO();
    } else {
      starGridTiles = [];
      playerGlowTimer = 0;
      ufo = null;
    }
    
    // Initialize Spell Stick - moving teleports + moving hole
    if (currentLevelTheme().name === "Spell Stick"){
      const numTeleports = randInt(5, 8);
      teleportTiles = [];
      for (let i = 0; i < numTeleports; i++){
        teleportTiles.push({
          x: randInt(0, GRID_W - 1),
          y: randInt(0, GRID_H - 1),
          glow: Math.random() * Math.PI * 2,
          moveTimer: randInt(120, 300)
        });
      }
      teleportMoveTimer = 0;
      holeMoveTimer = randInt(600, 900);
      holeFlashTimer = 0;
    } else if (currentLevelTheme().name !== "Victory Stick") {
      teleportTiles = [];
      teleportMoveTimer = 0;
      holeMoveTimer = 0;
      holeFlashTimer = 0;
    }
    
    // Ice Stick wind sound and snowman
    if (currentLevelTheme().name === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      stopIceWindSound();
      snowman = null;
    }
    
    // Victory Stick - LASER GRID! Completely new design
    if (currentLevelTheme().name === "Victory Stick"){
      // Initialize laser system
      initVictoryLasers();
    }
    
    // Initialize fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    // Initialize level hazards
    initLevelHazards();
    
    // Initialize ambient particles
    initAmbientParticles();
    
    // Reset special effects
    activeSpeedBoost = 0;
    activeShield = 0;
    visionRevealed = false;
    visionTimer = 0;
    
    // Clear trails and particles// Reset hole visibility for new level
    holeVisible = true;
    holeFadeTimer = 0;
    spawnHole();
    spawnSticksForLevel(game.level);
    maybeSpawnSpecialSticks();
    spawnLifeTile();
    scheduleTreeForLevel();

    game.actions = 0;
    game.carry = [];

    game.bonusActive = false;
    game.bonusExtraRollReady = false;
    game.bonusPendingRoll = false;
    game.bonusMovesDoubled = false;

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    logEvent("level",`Level ${game.level}! (${currentLevelTheme().name})`);
    sfxLevelUp();
    setHud(`LEVEL ${game.level}!`);

    commitScoreToLeaderboard();
    updateUI();
  }

  function newGame(fresh=false){
    if (!fresh){
      showNameModal();
      return;
    }
    resetCoreState();
    applyThemeForLevel();
    
    // Initialize level-specific elements (after theme is set)
    if (currentLevelTheme().name === "Night Stick"){
      initStarGrid();
      initUFO();
    }
    
    // Start music automatically
    if(musicOn){
      startMusic();
    }
    
    updateUI();
    startLoop();
  }

  function canRoll(){
    if (game.inputLocked && !game.pendingMonster) return false;
    if (game.pendingMonster) return true;
    if (game.actions > 0) return false;
    return true;
  }

  function rollNormal(){
    const zc = zeroChance(game.level);
    if (Math.random() < zc) return 0;
    return randInt(1,5);
  }

  function rollBonus2d6(){
    const d1 = randInt(1,6);
    const d2 = randInt(1,6);
    return { total: d1 + d2, d1, d2 };
  }

  function doRoll(){
    if (!canRoll()){
      sfxError();
      setHud("Spend Actions first!");
      return;
    }

    ui.diceBox.classList.add("rolling");
    sfxRoll();

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      if (game.pendingMonster){
        resolveMonsterRoll();
        return;
      }

      if (game.bonusActive){
        const r = rollBonus2d6();
        ui.diceFace.textContent = String(r.total);
        ui.diceLabel.textContent = `BONUS üé≤üé≤ (${r.d1}+${r.d2})`;

        game.bonusPendingRoll = false;
        game.bonusMovesDoubled = false;

        game.actions = r.total;
        logEvent("bonus",`Bonus roll: ${r.total}`);
        if (r.total === 12){
          game.bonusExtraRollReady = true;
          logEvent("bonus","Jackpot 12! Extra Bonus roll earned.");
          setHud("12! Extra Bonus roll earned!");
        } else {
          game.bonusExtraRollReady = false;
        }
      } else {
        const r = rollNormal();
        ui.diceFace.textContent = String(r);
        ui.diceLabel.textContent = `Normal üé≤ (0‚Äì5)`;

        if (r === 0){
          logEvent("bad","Rolled 0!");
          sfxZeroBad();
          handleZeroPenalty();
          game.actions = 0;
        } else {
          game.actions = r;
          
          // Spider web effect - halve the roll
          if (game.webbed){
            const before = game.actions;
            game.actions = Math.floor(game.actions / 2);
            logEvent("bad", `WEB TRAPPED! Roll halved: ${before} ‚Üí ${game.actions}`);
            setHud("WEBBED!");
            beep(300, 0.15, "sawtooth", 0.08);
            game.webbed = false;
          }
          
          logEvent("roll",`Rolled ${r}.`);
        }
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
    }, 260);
  }

  function scatterPositionAround(x,y, radius){
    for (let i=0;i<200;i++){
      const nx = clamp(x + randInt(-radius, radius), 0, GRID_W-1);
      const ny = clamp(y + randInt(-radius, radius), 0, GRID_H-1);
      if (isHole(nx,ny)) continue;
      if (isOccupiedByStick(nx,ny)) continue;
      if (nx===game.playerX && ny===game.playerY) continue;
      if (isLifeTile(nx,ny)) continue;
      if (isTreeTile(nx,ny)) continue;
      return {x:nx,y:ny};
    }
    return randomEmptyTile();
  }

  function handleZeroPenalty(){
    // HOLE IS SACRED - bonus points if in hole!
    if (game.playerX === game.holeX && game.playerY === game.holeY){
      const bonus = 5;
      game.score += bonus;
      logEvent("bonus", `Zero in hole! +${bonus} bonus points!`);
      setHud(`HOLE BONUS +${bonus}!`);
      game.holePulse = 1.0;
      
      // Positive ascending C-E-G chord
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o1 = audioCtx.createOscillator();
      const g1 = audioCtx.createGain();
      o1.connect(g1); g1.connect(audioCtx.destination);
      o1.type = "sine"; o1.frequency.value = 523;
      g1.gain.setValueAtTime(0.15, audioCtx.currentTime);
      g1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      o1.start(); o1.stop(audioCtx.currentTime + 0.3);
      
      setTimeout(() => {
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.connect(g2); g2.connect(audioCtx.destination);
        o2.type = "sine"; o2.frequency.value = 659;
        g2.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
        o2.start(); o2.stop(audioCtx.currentTime + 0.3);
      }, 100);
      
      setTimeout(() => {
        const o3 = audioCtx.createOscillator();
        const g3 = audioCtx.createGain();
        o3.connect(g3); g3.connect(audioCtx.destination);
        o3.type = "sine"; o3.frequency.value = 784;
        g3.gain.setValueAtTime(0.2, audioCtx.currentTime);
        g3.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
        o3.start(); o3.stop(audioCtx.currentTime + 0.4);
      }, 200);
      
      spawnSparks(game.holeX, game.holeY, 25, false);
      commitScoreToLeaderboard();
      return;
    }
    
    if (game.carry.length > 0){
      const dropped = game.carry.splice(0, game.carry.length);
      dropped.forEach(st => {
        const p = scatterPositionAround(game.playerX, game.playerY, 3);
        game.sticks.push({ x:p.x, y:p.y, color: st.color, cursed:false, bonus:false });
      });
      logEvent("bad",`Zero! Dropped ${dropped.length} stick(s).`);
      setHud(`Zero! Dropped ${dropped.length}!`);
    } else {
      const p = scatterPositionAround(game.holeX, game.holeY, 3);
      const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
      game.sticks.push({ x:p.x, y:p.y, color, cursed:false, bonus:false });
      logEvent("bad","Zero! Hole spits out a stick.");
      setHud("Hole spits out a stick!");
    }
    game.holeFlash = 1.0;
  }

  function onBonusStickPickup(){
    game.bonusPendingRoll = true;

    if (game.actions > 0){
      const before = game.actions;
      game.actions *= 2;
      game.bonusMovesDoubled = true;

      logEvent("bonus",`BONUS STICK! Actions doubled: ${before} ‚Üí ${game.actions}.`);
      setHud(`BONUS! ${before}‚Üí${game.actions} (Roll later)`);
      sfxBonus();
      updateUI();
      return;
    }

    game.bonusMovesDoubled = false;
    game.bonusActive = true;

    logEvent("bonus","BONUS STICK! No Actions left ‚Äî Bonus roll now!");
    setHud("BONUS ROLL NOW!");
    sfxBonus();
    updateUI();

    doRoll();
  }

  function promptBonusRollReady(){
    game.bonusActive = true;
    game.bonusMovesDoubled = false;

    ui.diceFace.textContent = "‚Äî";
    ui.diceLabel.textContent = "BONUS READY (2‚Äì12)";
    ui.btnRoll.classList.add("flashRoll");

    logEvent("bonus","Bonus roll ready! Press ROLL.");
    setHud("BONUS ROLL READY!");
    sfxBonus();
    updateUI();
  }

  function exitBonusIfDone(){
    if (game.actions === 0 && !game.bonusExtraRollReady){
      if (game.bonusActive){
        game.bonusActive = false;
        ui.btnRoll.classList.remove("flashRoll");
        logEvent("neutral","Bonus ended.");
        setHud("Bonus ended.");
      }
    }
  }

  function spendAction(){
    if (game.pendingMonster){
      sfxError();
      setHud("Fight the monster first! Press ROLL.");
      return false;
    }
    if (game.actions <= 0){
      sfxError();
      setHud("No Actions. Roll!");
      return false;
    }
    if (activeSpeedBoost > 0){
          activeSpeedBoost--;
          logEvent("info", `Speed boost! ${activeSpeedBoost} free moves left`);
        } else {
          game.actions--;
        }

    if (game.actions === 0){
      if (game.bonusPendingRoll && !game.bonusActive){
        promptBonusRollReady();
      } else {
        exitBonusIfDone();
      }
    }

    updateUI();
    return true;
  }

  function monsterStickValueForStreak(streak){
    if (streak <= 3) return 2;
    return Math.min(12, (streak - 1));
  }

  function resolveMonsterRoll(){
    const pending = game.pendingMonster;
    if (!pending) return;
    const index = pending.index;
    game.pendingMonster = null;

    ui.diceBox.classList.add("rolling");
    sfxRoll();
    logEvent("monster","Monster Stick! Rolling (0‚Äì5)...");

    gameSetTimeout(() => {
      ui.diceBox.classList.remove("rolling");

      const roll = randInt(0,5);
      ui.diceFace.textContent = String(roll);
      ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";

      const s = game.sticks[index];
      stopMonsterDoom();

      if (roll <= 1){
        if (s && s.cursed){
          game.sticks.splice(index,1);
        }
        game.lives = Math.max(0, game.lives - 1);
        spawnSparks(game.playerX, game.playerY, 18, true);

        game.monsterWinStreak = 0;

        logEvent("monster","Monster wins! Lost 1 life. (Streak reset)");
        setHud("MONSTER WINS! -1 LIFE");

        playPacmanDeathSting();

        if (game.lives <= 0){
          ui.monsterEvent.style.display = "none";
          ui.btnRoll.classList.remove("flashRoll");
          updateUI();
          game.inputLocked = false;
          game.pendingMonster = null;
          gameOver();
          return;
        }
      } else {
        game.monsterWinStreak++;
        const streak = game.monsterWinStreak;
        const mult = monsterStickValueForStreak(streak);

        if (s){
          game.sticks.splice(index,1);
          // CUPCAKE MODE: Apply 2x to monster sticks too!
          const finalMult = cupcakeMode > 0 ? mult * 2 : mult;
          game.carry.push({ color: s.color, value: finalMult, fromMonster:true, streakAtWin: streak });
        }

        const cupcakeBonus = cupcakeMode > 0 ? " üßÅ√ó2" : "";
        const finalMult = cupcakeMode > 0 ? mult * 2 : mult;
        logEvent("bonus",`You beat the monster! Stick is worth ${finalMult}√ó. (Streak ${streak})`);
        setHud(`MONSTER BEATEN! ${finalMult}√ó STICK${cupcakeBonus}`);
        sfxPickup();
        startCelebrationMusic(6500);

        if (streak === 3){
          if (game.lives < MAX_LIVES){
            game.lives++;
            logEvent("bonus","3√ó Monster streak! +1 life.");
            setHud("+1 LIFE (3√ó STREAK)");
            sfxExtraLife();
            startCelebrationMusic(7500);
          } else {
            logEvent("bonus","3√ó Monster streak (already max lives).");
            setHud("3√ó STREAK (MAX LIVES)");
            startCelebrationMusic(6500);
          }
        }
      }

ui.monsterEvent.style.display = "none";
ui.btnRoll.classList.remove("flashRoll");
game.inputLocked = false;
updateUI();

/* ‚úÖ BUGFIX: if the monster removed the LAST stick and you‚Äôre carrying none,
   the field is cleared but the game never advances. */
if (game.sticks.length === 0 && game.carry.length === 0){
  logEvent("level","Cleared the field!");
  newLevel();
  return;
}

gameSetTimeout(updateScrollHint, 30);

    }, 260);
  }

  function move(dx,dy){
    if (game.inputLocked) return;
    
    // Calculate new position
    const newX = clamp(game.playerX + dx, 0, GRID_W-1);
    const newY = clamp(game.playerY + dy, 0, GRID_H-1);
    
    // Check if we're currently ON a mountain square
    const currentlyOnMountain = game.mountainTraversal && 
                                 game.mountainTraversal.x === game.playerX && 
                                 game.mountainTraversal.y === game.playerY;
    
    if (currentlyOnMountain){
      // We're on a mountain - any direction key press consumes an action for climbing
      
      // First, try to spend an action
      if (!spendAction()){
        // No actions left - player needs to roll
        return;
      }
      
      // Consume the action for climbing
      game.mountainTraversal.remaining--;
      
      if (game.mountainTraversal.remaining <= 0){
        // Finished climbing! Clear traversal so next move will work normally
        logEvent("climb", "‚úì Mountain traversed! Can move freely now.");
        setHud("MOUNTAIN CLEAR!");
        beep(600, 0.15, "sine", 0.18);
        game.mountainTraversal = null; // Clear the traversal
        // Don't move yet - player stays on mountain until next move
      } else {
        // Still climbing
        logEvent("climb", `Climbing... ${game.mountainTraversal.remaining} more action(s) needed`);
        setHud(`CLIMBING (${game.mountainTraversal.remaining} more)`);
        beep(450, 0.08, "sine", 0.12);
      }
      
      updateUI();
      return;
    }
    
    // Check if moving onto a mountain
    if(currentLevelTheme().name === "Mountain Stick"){
      const mountain = mountains.find(m => m.x === newX && m.y === newY);
      if(mountain){
        // Entering a mountain
        if (!spendAction()) return;
        
        game.playerX = newX;
        game.playerY = newY;
        
        game.mountainTraversal = {
          x: newX,
          y: newY,
          total: mountain.height,
          remaining: mountain.height - 1 // -1 because this move counts
        };
        
        logEvent("climb", `Entered height-${mountain.height} mountain. Need ${mountain.height - 1} more action(s) to leave.`);
        setHud(`ON MOUNTAIN (${mountain.height - 1} more)`);
        beep(400, 0.1, "sine", 0.15);
        beep(220,0.03,"triangle",0.02);
        updateUI();
        return;
      }
    }
    
    // Normal movement
    if (!spendAction()) return;
    
    game.playerX = newX;
    game.playerY = newY;
    beep(220,0.03,"triangle",0.02);
    
    // Check banana slip immediately after moving
    if(currentLevelTheme().name === "Banana Stick"){
      const banana = bananas.find(b => b.x === game.playerX && b.y === game.playerY);
      if(banana){
        // Relocate banana to a different position instead of removing it
        const newPos = randomEmptyTile();
        banana.x = newPos.x;
        banana.y = newPos.y;
        
        // Slip in random direction 2-4 squares
        const distance = randInt(2, 4);
        const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        const dir = dirs[randInt(0, 3)];
        
        let slipX = game.playerX;
        let slipY = game.playerY;
        
        for(let i = 0; i < distance; i++){
          slipX = clamp(slipX + dir.dx, 0, GRID_W - 1);
          slipY = clamp(slipY + dir.dy, 0, GRID_H - 1);
        }
        
        game.playerX = slipX;
        game.playerY = slipY;
        
        logEvent("slip", `üçå Slipped on banana! It moved elsewhere, and you slid ${distance} squares!`);
        setHud("BANANA SLIP!");
        beep(400, 0.15, "sine", 0.2);
        beep(300, 0.15, "sine", 0.15);
      }
    }
    
    // Check monkey collision immediately after moving
    if(currentLevelTheme().name === "Banana Stick" && monkey.active){
      if(monkey.x === game.playerX && monkey.y === game.playerY){
        if(game.carry.length > 0){
          // Drop all sticks - DRAMATIC SOUND
          game.carry.forEach(stick => {
            const pos = randomEmptyTile();
            stick.x = pos.x;
            stick.y = pos.y;
            game.sticks.push(stick);
          });
          const dropped = game.carry.length;
          game.carry = [];
          logEvent("monkey", `üêí MONKEY STOLE ${dropped} STICKS!`);
          setHud("MONKEY ATTACK!");
          // Dramatic descending sound
          beep(600, 0.15, "sawtooth", 0.35);
          setTimeout(() => beep(400, 0.15, "sawtooth", 0.35), 100);
          setTimeout(() => beep(200, 0.2, "sawtooth", 0.4), 200);
        } else {
          // No sticks = lose a life AND monkey dies too (easy level)
          game.lives--;
          monkeys = []; // Monkey dies
          logEvent("death", "üêí MONKEY ATTACKED! Both defeated!");
          setHud("MUTUAL DEFEAT!");
          // Dramatic death sound
          beep(800, 0.1, "sawtooth", 0.4);
          setTimeout(() => beep(600, 0.12, "sawtooth", 0.4), 80);
          setTimeout(() => beep(400, 0.15, "sawtooth", 0.45), 160);
          setTimeout(() => beep(200, 0.2, "sawtooth", 0.5), 260);
          setTimeout(() => beep(100, 0.25, "sawtooth", 0.5), 380);
          
          if (game.lives <= 0){
            gameOver();
          }
          // Player stays in same position, monkey is gone
        }
      }
    }
    
    updateUI();
  }

  function pickOrDrop(){
    if (game.inputLocked) return;
    if (!spendAction()) return;

    if (isTreeTile(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        const cap = carryCap();
        // CUPCAKE MODE: 2x value for tree magic sticks!
        const stickValue = cupcakeMode > 0 ? 2 : 1;
        for (let i=0;i<cap;i++){
          const color = STICK_COLORS[randInt(0, STICK_COLORS.length-1)];
          game.carry.push({ color, value:stickValue, fromMagic:true });
        }
        const cupcakeBonus = cupcakeMode > 0 ? " üßÅ√ó2" : "";
        logEvent("bonus",`Tree magic! Instantly filled to ${cap}.`);
        setHud(`TREE LOAD${cupcakeBonus} (${cap})`);
        sfxPickup();

        if (game.sticks.length === 0){
          endTree();
        }

        updateUI();
        return;
      }

      game.carry.pop();

      if (game.lives < MAX_LIVES){
        game.lives++;
        logEvent("bonus","Fed the tree. +1 life.");
        setHud("+1 LIFE (TREE)");
        sfxExtraLife();
        startCelebrationMusic(6500);
      } else {
        game.score += TREE_FEED_MAX_POINTS;
        logEvent("bonus",`Fed the tree (max lives). +${TREE_FEED_MAX_POINTS} points.`);
        setHud(`TREE FED (+${TREE_FEED_MAX_POINTS})`);
        sfxPickup();
        commitScoreToLeaderboard();
      }

      endTree();

      if (game.sticks.length === 0 && game.carry.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
        return;
      }

      updateUI();
      return;
    }

    if (isHole(game.playerX, game.playerY)){
      if (game.carry.length === 0){
        sfxError(); setHud("Nothing to deposit."); return;
      }
      const n = game.carry.length;
      let pts = 0;
      
      // SKELETON MODE: All sticks worth 0 points!
      if(isSkeletonMode){
        pts = 0;
        logEvent("cursed", "üíÄ Skeleton deposited sticks for 0 points!");
        setHud("üíÄ 0 POINTS! üíÄ");
      } else {
        for (const st of game.carry){
          let v = st.value || 1;
          if (game.bonusActive) v *= 2;
          pts += v;
        }
      }
      
      game.score += pts;
      game.carry = [];
      
      // End skeleton mode on deposit
      if(isSkeletonMode){
        isSkeletonMode = false;
        logEvent("info", "‚ú® You're back to normal!");
      }
      
      // Deactivate banana mode on deposit
      if(bananaMode){
        bananaMode = false;
        logEvent("info", "Banana boost ended.");
      }
      
      // Flower rain is constant on Sparkle Stick - no need to deactivate
      
      // Expire power-ups on deposit
      if (activeShield > 0){
        activeShield = 0;
        logEvent("info", "Shield expired.");
      }
      if (visionRevealed){
        visionRevealed = false;
        visionTimer = 0;
        logEvent("info", "Vision expired.");
      }

      logEvent("deposit",`Deposited ${n} stick(s) (+${pts}).`);
      sfxDeposit();
      setHud(`+${pts} deposited!`);

      game.holePulse = 1.0;
      spawnSparks(game.holeX, game.holeY, 28);

      commitScoreToLeaderboard();

      if (game.sticks.length === 0){
        logEvent("level","Cleared the field!");
        newLevel();
      } else {
        updateUI();
      }
      return;
    }

    const idx = game.sticks.findIndex(s => s.x===game.playerX && s.y===game.playerY);
    if (idx >= 0){
      if (game.carry.length >= carryCap()){
        sfxError();
        const cap = carryCap();
        setHud(`MAX STICKS (${cap})`);
        logEvent("warn",`MAX STICKS (${cap}).`);
        return;
      }

      const s = game.sticks[idx];

      if (s.cursed){
        game.pendingMonster = { index: idx };
        game.inputLocked = true;

        logEvent("monster","Monster Stick! Press ROLL (0‚Äì5) to fight.");
        setHud("MONSTER STICK! PRESS ROLL");

        ui.diceFace.textContent = "?";
        ui.diceLabel.textContent = "Monster Roll (0‚Äì5)";
        ui.monsterEventText.textContent =
          `Cursed stick! Press ROLL (0‚Äì5). Roll 2‚Äì5 to beat the monster and keep a powered stick. Roll 0‚Äì1 and you lose 1 life. (Win streak carries across levels; resets only on a loss.)`;
        ui.monsterEvent.style.display = "flex";
        ui.btnRoll.classList.add("flashRoll");

        sfxMonsterHit();
        playMonsterDoomSting();
        updateUI();
        gameSetTimeout(updateScrollHint, 30);
        return;
      }

      // Check if it's a special stick
      if (s.special){
        pickupSpecialStick(s.special);
        game.sticks.splice(idx,1);return;
      }game.sticks.splice(idx,1);
      
      // CUPCAKE MODE: 2x stick value!
      const stickValue = cupcakeMode > 0 ? 2 : 1;
      game.carry.push({ color:s.color, value:stickValue });
      
      if(cupcakeMode > 0 && stickValue === 2){
        logEvent("sparkle", "üßÅ Cupcake power! 2x stick value!");
      }

      sfxPickup();

      if (s.bonus){
        onBonusStickPickup();
      }

      const cap = carryCap();
      if (game.carry.length === cap){
        logEvent("warn",`MAX LOAD (${cap}).`);
        setHud(`MAX LOAD (${cap})`);
      } else {
        const cupcakeBonus = cupcakeMode > 0 ? " üßÅ√ó2" : "";
        logEvent("pickup",`Picked up a stick. (${game.carry.length}/${cap})`);
        setHud(`Picked up${cupcakeBonus} (${game.carry.length}/${cap})`);
      }

      updateUI();
      gameSetTimeout(updateScrollHint, 30);
      return;
    }

    if (game.carry.length > 0){
      if (isOccupiedByStick(game.playerX, game.playerY)){
        sfxError(); setHud("Tile already has a stick."); return;
      }

      if (isLifeTile(game.playerX, game.playerY)){
        game.carry.pop();
        game.lifeTileUsed = true;

        if (game.lives < MAX_LIVES){
          game.lives++;
          logEvent("bonus","Secret life tile! +1 life.");
          setHud("+1 LIFE");
          sfxExtraLife();
          startCelebrationMusic(6500);
        } else {
          game.score += LIFE_TILE_MAX_POINTS;
          logEvent("bonus",`Life tile found (max lives). +${LIFE_TILE_MAX_POINTS} points.`);
          setHud(`LIFE TILE (+${LIFE_TILE_MAX_POINTS})`);
          sfxPickup();
          commitScoreToLeaderboard();
        }

        spawnSparks(game.playerX, game.playerY, 18, false);
        updateUI();
        return;
      }

      const st = game.carry.pop();
      game.sticks.push({ x:game.playerX, y:game.playerY, color:st.color, cursed:false, bonus:false });
      sfxPlace();
      logEvent("place","Placed 1 stick.");
      setHud("Placed 1 stick.");
      updateUI();
      return;
    }

    sfxError();
    setHud("No stick here.");
  }

  function gameOver(){
    commitScoreToLeaderboard();

    burstFx(ui.loseFx, "ü™µ", 40);

    let message = "";
    
    if(game.level === 15){
      const finalTaunts = [
        "The Victory Stick laughs at your defeat.",
        "So close... yet the sticks claimed you.",
        "Level 15 proved fatal. Almost had it all.",
        "The final challenge crushed you. Better luck next time."
      ];
      const t = finalTaunts[randInt(0, finalTaunts.length-1)];
      message = `üíÄ DIED ON LEVEL 15! üíÄ\n${player.name} ‚Ä¢ Score: ${game.score}\n\n${t}`;
    } else {
      const taunts = [
        "The Stick Monster claps slowly. Loudly. Rudely.",
        "The sticks whisper: 'Skill issue.'",
        "The monster does a little dance. It's disrespectful.",
        "The hole sighs. The monster cackles."
      ];
      const t = taunts[randInt(0, taunts.length-1)];
      message = `${player.name} ‚Ä¢ Score: ${game.score} ‚Ä¢ Level ${game.level}/15\n\n${t}`;
    }

    ui.gameOverText.textContent = message;
    ui.gameOverOverlay.style.display = "flex";
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();
    game.inputLocked = true;

    logEvent("bad", `Game Over. ${t}`);
    setHud("GAME OVER");

    spawnSparks(game.playerX, game.playerY, 35, true);
    spawnSparks(game.holeX, game.holeY, 25, true);

    startDoomMusic(10000);
  }

  function spawnSparks(gx,gy,count=18, evil=false){
    const cx = gx*TILE + TILE/2;
    const cy = gy*TILE + TILE/2;
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      game.sparks.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 24 + Math.random()*20, evil });
    }
  }

  function updateRollButtonState(){
    const canRoll = !((game.inputLocked && !game.pendingMonster) || (game.actions !== 0 && !game.pendingMonster));
    ui.btnRoll.disabled = !canRoll;
    
    // Add visual highlight when ready to roll
    if (canRoll){
      ui.btnRoll.classList.add('ready-to-roll');
    } else {
      ui.btnRoll.classList.remove('ready-to-roll');
    }
  }

  function updateUI(){
    ui.player.textContent = player.name;
    ui.lives.textContent = String(game.lives);
    ui.level.textContent = String(game.level);
    ui.score.textContent = String(game.score);
    ui.actions.textContent = String(game.actions);

    const cap = carryCap();
    ui.carry.textContent = `${game.carry.length}/${cap}`;
    ui.left.textContent = String(game.sticks.length);

    let mode = "NORMAL";
    if (game.bonusActive) mode = game.bonusExtraRollReady ? "BONUS+" : "BONUS";
    else if (game.bonusPendingRoll) mode = "BONUS (PENDING)";
    ui.mode.textContent = mode;

    ui.die.textContent = game.bonusActive ? "2‚Äì12" : "0‚Äì5";

    updateRollButtonState();
  }

  function canSaveLoad(){
    if (ui.infoOverlay.style.display === "flex") return false;
    if (ui.nameOverlay.style.display === "flex") return false;
    if (ui.gameOverOverlay.style.display === "flex") return false;
    if (ui.winOverlay.style.display === "flex") return false;
    if (ui.pauseOverlay.style.display === "flex") return false;
    if (game.pendingMonster) return false;
    return true;
  }

  function serializeGame(){
    return {
      v: 2,
      when: Date.now(),
      playerName: player.name,
      playerSkin: game.playerSkin,
      game: {
        level: game.level,
        lives: game.lives,
        score: game.score,
        actions: game.actions,

        bonusActive: game.bonusActive,
        bonusExtraRollReady: game.bonusExtraRollReady,
        bonusPendingRoll: game.bonusPendingRoll,
        bonusMovesDoubled: game.bonusMovesDoubled,

        playerX: game.playerX,
        playerY: game.playerY,
        carry: game.carry,
        sticks: game.sticks,
        holeX: game.holeX,
        holeY: game.holeY,
        lifeTileX: game.lifeTileX,
        lifeTileY: game.lifeTileY,
        lifeTileUsed: game.lifeTileUsed,

        treeX: game.treeX,
        treeY: game.treeY,
        treeActive: game.treeActive,
        treePhase: game.treePhase,
        treePhaseTimer: game.treePhaseTimer,
        treeSpawnDelay: game.treeSpawnDelay,
        treeSpawnedThisLevel: game.treeSpawnedThisLevel,

        monsterWinStreak: game.monsterWinStreak,

        hudMsg: "",
        hudTimer: 0,
        holePulse: 0,
        holeFlash: 0
      }
    };
  }

  function applySerialized(obj){
    if (!obj || !obj.game) return false;

    setAndStoreName(obj.playerName || "PLAYER1");
    setAndStoreSkin(obj.playerSkin || getSavedSkin());

    const g = obj.game;
    game.level = clamp(Number(g.level)||1, 1, 9);
    game.lives = clamp(Number(g.lives)||3, 0, MAX_LIVES);
    game.score = Math.max(0, Number(g.score)||0);
    game.actions = Math.max(0, Number(g.actions)||0);

    game.bonusActive = !!g.bonusActive;
    game.bonusExtraRollReady = !!g.bonusExtraRollReady;
    game.bonusPendingRoll = !!g.bonusPendingRoll;
    game.bonusMovesDoubled = !!g.bonusMovesDoubled;

    game.playerX = clamp(Number(g.playerX)||2, 0, GRID_W-1);
    game.playerY = clamp(Number(g.playerY)||2, 0, GRID_H-1);

    game.carry = Array.isArray(g.carry) ? g.carry.slice(0, 12) : [];
    game.sticks = Array.isArray(g.sticks) ? g.sticks.map(s => ({
      x: clamp(Number(s.x)||0, 0, GRID_W-1),
      y: clamp(Number(s.y)||0, 0, GRID_H-1),
      color: String(s.color || "#f3f4f6"),
      cursed: !!s.cursed,
      bonus: !!s.bonus
    })) : [];

    game.holeX = clamp(Number(g.holeX)||12, 0, GRID_W-1);
    game.holeY = clamp(Number(g.holeY)||12, 0, GRID_H-1);

    game.lifeTileX = clamp(Number(g.lifeTileX)||-1, -1, GRID_W-1);
    game.lifeTileY = clamp(Number(g.lifeTileY)||-1, -1, GRID_W-1);
    game.lifeTileUsed = !!g.lifeTileUsed;

    game.treeX = clamp(Number(g.treeX)||-1, -1, GRID_W-1);
    game.treeY = clamp(Number(g.treeY)||-1, -1, GRID_W-1);
    game.treeActive = !!g.treeActive;
    game.treePhase = String(g.treePhase || (game.treeActive ? "visible" : "hidden"));
    game.treePhaseTimer = Math.max(0, Number(g.treePhaseTimer)||0);
    game.treeSpawnDelay = Math.max(0, Number(g.treeSpawnDelay)||0);
    game.treeSpawnedThisLevel = !!g.treeSpawnedThisLevel;

    game.monsterWinStreak = Math.max(0, Number(g.monsterWinStreak)||0);

    celebrationUntil = 0;
    celebrationStep = 0;
    doomUntil = 0;
    doomStep = 0;

    game.pendingMonster = null;
    ui.monsterEvent.style.display = "none";
    ui.btnRoll.classList.remove("flashRoll");
    stopMonsterDoom();

    game.inputLocked = false;
    applyThemeForLevel();
    
    // Re-initialize hazards for loaded level
    const loadedTheme = currentLevelTheme().name;
    
    if (loadedTheme === "Ice Stick"){
      initSnowflakes();
    } else {
      snowflakes = [];
    }
    
    if (loadedTheme === "Fire Stick"){
      initFireTiles();
    } else {
      fireTiles = [];
      fireWarningTimer = 0;
    }
    
    if (loadedTheme === "Sky Stick"){
      initWindTiles();
      windGustTimer = 0;
    } else {
      windTiles = [];
      windWarningTimer = 0;
      windGustTimer = 0;
    }
    
    if (loadedTheme === "Snake Stick"){
      initSnakes();
    } else {
      snakes = [];
      snakeAttacking = false;
      snakeMoveTimer = 0;
    }
    
    if (loadedTheme === "Ice Stick"){
      initFreezeTiles();
    } else {
      freezeTiles = [];
      freezeWarningTimer = 0;
    }
    
    if (loadedTheme === "Glow Stick"){
      initShadowMonsters();
    } else {
      shadowMonsters = [];
    }
    
    if (loadedTheme === "Victory Stick"){
      windTiles = [];
      for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
      fireTiles = [];
      for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
      initSnakes(); snakes = snakes.slice(0,1);
      initFreezeTiles(); freezeTiles = freezeTiles.slice(0,4);
      initShadowMonsters(); shadowMonsters = shadowMonsters.slice(0,1);
      initSharks(); sharks = sharks.slice(0,2);
      initSunBursts(); sunBurstTiles = sunBurstTiles.slice(0,3);
      teleportTiles = [];
      for(let i=0;i<4;i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
      holeMoveTimer = randInt(600,900);
    }
    
    if (loadedTheme === "Sea Stick"){
      initSharks();
    } else if (loadedTheme !== "Victory Stick"){
      sharks = [];
    }
    
    if (loadedTheme === "Sun Stick"){
      initSunBursts();
    } else if (loadedTheme !== "Victory Stick"){
      sunBurstTiles = [];
    }
    
    if (loadedTheme === "Night Stick"){
      initStarGrid();
    } else {
      starGridTiles = [];
    }
    
    if (loadedTheme === "Ice Stick"){
      startIceWindSound();
      initSnowman();
    } else {
      snowman = null;
    }
    
    updateUI();
    setHud("Game loaded!");
    return true;
  }

  function saveGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't save right now.");
      logEvent("warn","Can't save during overlays or monster encounter.");
      return;
    }
    try{
      localStorage.setItem(LS_SAVEGAME, JSON.stringify(serializeGame()));
      logEvent("save","Game saved (this device).");
      setHud("GAME SAVED");
      chord([262,330,392],0.16,0.05,"triangle");
    }catch(_){
      sfxError();
      setHud("Save failed.");
    }
  }

  function loadGame(){
    if (!canSaveLoad()){
      sfxError();
      setHud("Can't load right now.");
      logEvent("warn","Can't load during overlays or monster encounter.");
      return;
    }
    try{
      const raw = localStorage.getItem(LS_SAVEGAME);
      if (!raw){
        sfxError();
        setHud("No saved game.");
        logEvent("load","No saved game found.");
        return;
      }
      const obj = JSON.parse(raw);
      const ok = applySerialized(obj);
      if (ok){
        logEvent("load","Game loaded.");
        chord([294,370,440],0.16,0.05,"triangle");
      } else {
        sfxError();
        setHud("Load failed.");
      }
    }catch(_){
      sfxError();
      setHud("Load failed.");
    }
  }

  /* ---- Drawing ---- */

  /* ‚úÖ Casey changes requested:
     - Glow Stick grid: softened + pulses
     - Victory Stick grid: softened (and pulses a bit too)
     - Ice Stick: aesthetically nicer but still consistent (icy gradient + soft sheen + gentle pulse)
  */
  function drawGrid(theme){
    // background
    if (theme.name === "Ice Stick"){
      const g = ctx.createLinearGradient(0,0,CANVAS_W,CANVAS_H);
      g.addColorStop(0, "#f5fbff");
      g.addColorStop(0.55, theme.bg);
      g.addColorStop(1, "#dbeafe");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);

      // subtle frost sheen diagonals (static look, very faint)
      ctx.save();
      ctx.globalAlpha = 0.06;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.moveTo(-40 + i*90, 40);
        ctx.lineTo(CANVAS_W, CANVAS_H - 80 + i*40);
        ctx.stroke();
      }
      ctx.restore();
    } else {
      ctx.fillStyle = theme.bg;
      ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
    }

    // time for pulse
    const t = ((performance.now ? performance.now() : Date.now()) / 1000);
    const osc = (Math.sin(t*2.8) + 1) / 2; // 0..1

    // base softness per theme
    const isGlow = theme.name === "Glow Stick";
    const isVic  = theme.name === "Victory Stick";
    const isIce  = theme.name === "Ice Stick";
    const isBanana = theme.name === "Banana Stick";

    let baseAlpha = 0.55;
    let pulseAdd  = 0.00;
    let glowAlpha = 0.00;
    let glowBlur  = 0;

    if (isGlow){
      baseAlpha = 0.22;
      pulseAdd  = 0.22;   // noticeable pulse
      glowAlpha = 0.08 + osc*0.06;
      glowBlur  = 12 + osc*8;
    } else if (isVic){
      baseAlpha = 0.26;
      pulseAdd  = 0.16;   // softer pulse than Glow
      glowAlpha = 0.07 + osc*0.05;
      glowBlur  = 10 + osc*6;
    } else if (isIce){
      baseAlpha = 0.18;
      pulseAdd  = 0.14;   // gentle pulse
      glowAlpha = 0.05 + osc*0.04;
      glowBlur  = 8 + osc*5;
    } else if (isBanana){
      baseAlpha = 0.85;   // More visible grid
      pulseAdd  = 0.00;
      glowAlpha = 0.00;
      glowBlur  = 0;
    } else {
      baseAlpha = 0.55;
      pulseAdd  = 0.00;
      glowAlpha = 0.00;
      glowBlur  = 0;
    }

    // neon blur pass (softens the grid + gives the pulse)
    if (isGlow || isVic || isIce){
      ctx.save();
      ctx.strokeStyle = theme.grid;
      ctx.shadowColor = theme.grid;
      ctx.shadowBlur = glowBlur;
      ctx.globalAlpha = glowAlpha;
      ctx.lineWidth = 2;

      for (let x=0;x<=GRID_W;x++){
        ctx.beginPath();
        ctx.moveTo(x*TILE + 0.5, 0);
        ctx.lineTo(x*TILE + 0.5, CANVAS_H);
        ctx.stroke();
      }
      for (let y=0;y<=GRID_H;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*TILE + 0.5);
        ctx.lineTo(CANVAS_W, y*TILE + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    // crisp pass (but softened via alpha + pulse)
    ctx.strokeStyle = theme.grid;
    ctx.lineWidth = 1; // Normal thickness for all themes
    ctx.globalAlpha = clamp(baseAlpha + (osc*pulseAdd), 0.06, 0.72);

    for (let x=0;x<=GRID_W;x++){
      ctx.beginPath();
      ctx.moveTo(x*TILE + 0.5, 0);
      ctx.lineTo(x*TILE + 0.5, CANVAS_H);
      ctx.stroke();
    }
    for (let y=0;y<=GRID_H;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*TILE + 0.5);
      ctx.lineTo(CANVAS_W, y*TILE + 0.5);
      ctx.stroke();
    }

    ctx.globalAlpha = 1;
  }

  function drawHole(theme){
    if (!holeVisible) return; // Support for hole fading on higher levels
    
    const cx = game.holeX*TILE + TILE/2;
    const cy = game.holeY*TILE + TILE/2;

    if (game.holePulse > 0) game.holePulse = Math.max(0, game.holePulse - 0.03);
    if (game.holeFlash > 0) game.holeFlash = Math.max(0, game.holeFlash - 0.04);

    const pulse = game.holePulse;
    const flash = game.holeFlash;

    // Theme-specific hole colors with vibrant accents
    let holeColor = "#000000";
    let holeStroke = "#f3f4f6";
    let glowColor = "rgba(243,244,246,0.4)";
    
    if (theme.name === "Sparkle Stick") {
      holeColor = "#ffc0e0";
      holeStroke = "#ff1493";
      glowColor = "rgba(255,20,147,0.6)";
    } else if (theme.name === "Sun Stick") {
      holeColor = "#2a1a00";
      holeStroke = "#ffd400";
      glowColor = "rgba(255,212,0,0.6)";
    } else if (theme.name === "Cursed Stick") {
      holeColor = "#1a0a2a";
      holeStroke = "#8b00ff";
      glowColor = "rgba(139,0,255,0.6)";
    } else if (theme.name === "Sea Stick") {
      holeColor = "#001a33";
      holeStroke = "#00bfff";
      glowColor = "rgba(0,191,255,0.6)";
    } else if (theme.name === "Sky Stick") {
      holeColor = "#051a3a";
      holeStroke = "#3aa7ff";
      glowColor = "rgba(58,167,255,0.6)";
    } else if (theme.name === "Fire Stick") {
      holeColor = "#1a0005";
      holeStroke = "#ff5a6a";
      glowColor = "rgba(255,31,58,0.6)";
    } else if (theme.name === "Mountain Stick") {
      holeColor = "#2b1f1a";
      holeStroke = "#8b7355";
      glowColor = "rgba(139,115,85,0.6)";
    } else if (theme.name === "Banana Stick") {
      holeColor = "#1a2e0a"; // Dark green background
      holeStroke = "#ffd700"; // Yellow border
      glowColor = "rgba(255,215,0,0.7)";
    } else if (theme.name === "Snake Stick") {
      holeColor = "#001a0a";
      holeStroke = "#39ff95";
      glowColor = "rgba(57,255,149,0.6)";
    } else if (theme.name === "Spell Stick") {
      holeColor = "#1a0020";
      holeStroke = "#ff69ff";
      glowColor = "rgba(255,105,255,0.6)";
    } else if (theme.name === "Ice Stick") {
      holeColor = "#a0e8ff";
      holeStroke = "#ffffff";
      glowColor = "rgba(255,255,255,0.7)";
    } else if (theme.name === "Glow Stick") {
      holeColor = "#2a1500";
      holeStroke = "#ffb347";
      glowColor = "rgba(255,179,71,0.6)";
    } else if (theme.name === "Spider Stick") {
      holeColor = "#0d0a12";
      holeStroke = "#8b5cf6";
      glowColor = "rgba(139,92,246,0.6)";
    } else if (theme.name === "Victory Stick") {
      holeColor = "#0a1f0a"; // Dark green
      holeStroke = "#27ae60"; // Bright green
      glowColor = "rgba(39,174,96,0.6)"; // Green glow
    }

    ctx.save();

    if (pulse > 0){
      ctx.globalAlpha = 0.20 + pulse*0.55;
      ctx.fillStyle = theme.accent;
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + pulse*12, 0, Math.PI*2);
      ctx.fill();
    }

    if (flash > 0){
      ctx.globalAlpha = 0.25 + flash*0.55;
      ctx.fillStyle = "#ff1f3a";
      ctx.beginPath();
      ctx.arc(cx, cy, 18 + flash*10, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;
    
    // Pulsating glow effect
    const pulsePhase = (Date.now() % 1500) / 1500; // 1.5 second pulse cycle
    const pulseIntensity = 0.5 + Math.sin(pulsePhase * Math.PI * 2) * 0.5; // oscillates 0-1
    
    // Outer glow (pulsating)
    const glowRadius = 18 + pulseIntensity * 4;
    const gradient = ctx.createRadialGradient(cx, cy, 6, cx, cy, glowRadius);
    gradient.addColorStop(0, holeColor);
    gradient.addColorStop(0.6, holeColor);
    const glowAlpha = pulseIntensity * 0.3;
    const finalGlow = glowColor.replace(/[\d.]+\)$/, glowAlpha + ')');
    gradient.addColorStop(1, finalGlow);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, glowRadius, 0, Math.PI*2);
    ctx.fill();

    // Main hole body
    ctx.shadowBlur = 0;
    ctx.fillStyle = holeColor;
    ctx.globalAlpha = 0.92;
    ctx.beginPath();
    ctx.arc(cx, cy, 8 + pulse*2, 0, Math.PI*2);
    ctx.fill();
    
    // Refined subtle pulsating outline
    ctx.globalAlpha = 0.85 + pulseIntensity * 0.15;
    ctx.lineWidth = 1.2 + pulseIntensity * 0.3;
    ctx.strokeStyle = holeStroke;
    ctx.shadowColor = holeStroke;
    ctx.shadowBlur = 6 + pulseIntensity * 4;
    ctx.beginPath();
    ctx.arc(cx, cy, 16 + pulse*6, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawLifeHint(theme){
    if (game.lifeTileUsed) return;
    if (game.carry.length <= 0) return;
    if (game.playerX !== game.lifeTileX || game.playerY !== game.lifeTileY) return;

    const x = game.lifeTileX*TILE;
    const y = game.lifeTileY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*4) + 1) / 2;

    ctx.save();
    ctx.globalAlpha = 0.15 + osc*0.25;
    ctx.strokeStyle = theme.accent;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(x+3, y+3, TILE-6, TILE-6);
    ctx.stroke();
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawTree(theme){
    if (!game.treeActive) return;

    if (game.treePhase === "blinking"){
      const blinkOn = (Math.floor(game.treePhaseTimer / 10) % 2) === 0;
      if (!blinkOn) return;
    }

    const x = game.treeX*TILE;
    const y = game.treeY*TILE;

    const t = (performance.now ? performance.now() : Date.now()) / 1000;
    const osc = (Math.sin(t*5) + 1) / 2;

    ctx.save();

    ctx.globalAlpha = 0.10 + osc*0.18;
    ctx.strokeStyle = "#39ff95";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x + TILE/2, y + TILE/2, 10 + osc*3, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#a16207";
    ctx.fillRect(x + 11, y + 12, 2, 7);
    ctx.fillRect(x + 10, y + 14, 4, 5);

    ctx.fillStyle = "#22c55e";
    ctx.fillRect(x + 8,  y + 8,  8, 2);
    ctx.fillRect(x + 7,  y + 10, 10, 2);
    ctx.fillRect(x + 8,  y + 12, 8, 2);

    ctx.globalAlpha = 0.35 + osc*0.35;
    ctx.fillStyle = theme.accent;
    ctx.fillRect(x + 6, y + 6, 1, 1);
    ctx.fillRect(x + 17, y + 7, 1, 1);

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawStick(s){
    const x = s.x*TILE;
    const y = s.y*TILE;
    ctx.save();
    ctx.translate(x + TILE/2, y + TILE/2);

    const theme = currentLevelTheme();
    if (theme.name === "Ice Stick" || theme.name === "Glow Stick" || theme.name === "Victory Stick"){
      ctx.shadowColor = "rgba(0,0,0,0.18)";
      ctx.shadowBlur = 6;
    }

    ctx.strokeStyle = s.color;
    ctx.lineWidth = 3;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(-6, -8);
    ctx.lineTo(7, 9);
    ctx.stroke();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-4, -6);
    ctx.lineTo(5, 7);
    ctx.stroke();
    ctx.globalAlpha = 1;

    if (s.bonus){
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "#ffd166";
      ctx.beginPath();
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawPlayer(){
    const cx = game.playerX*TILE + TILE/2;
    const cy = game.playerY*TILE + TILE/2;

    ctx.save();
    ctx.translate(cx, cy);
    
    // Sun glow effect - VIBRANT!
    if (playerSunGlow > 0){
      const glowAlpha = (playerSunGlow / 180) * 0.9; // Much stronger alpha
      const pulse = Math.sin(Date.now() / 80) * 0.3 + 0.7; // Faster, bigger pulse
      
      // Outer bright glow
      ctx.globalAlpha = glowAlpha * pulse * 0.6;
      const outerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
      outerGrad.addColorStop(0, 'rgba(255,235,59,0.9)'); // Bright yellow
      outerGrad.addColorStop(0.5, 'rgba(255,193,7,0.7)'); // Golden
      outerGrad.addColorStop(1, 'rgba(255,152,0,0)'); // Orange fade
      ctx.fillStyle = outerGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 30, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner bright core
      ctx.globalAlpha = glowAlpha * pulse;
      const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
      coreGrad.addColorStop(0, 'rgba(255,255,224,1)'); // Almost white center
      coreGrad.addColorStop(0.6, 'rgba(255,235,59,0.8)'); // Bright yellow
      coreGrad.addColorStop(1, 'rgba(255,193,7,0)'); // Golden fade
      ctx.fillStyle = coreGrad;
      ctx.beginPath();
      ctx.arc(0, 0, 15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }
    
    // Cloud effect on player
    if (playerCloudEffect > 0){
      const cloudAlpha = (playerCloudEffect / 180) * 0.7;
      
      ctx.globalAlpha = cloudAlpha;
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      
      // Multiple wispy cloud puffs around player
      ctx.beginPath();
      ctx.arc(-8, -3, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(8, -3, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(0, -8, 7, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(0, 5, 5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
    }

    const theme = currentLevelTheme();
    
    // CUPCAKE MODE: Cupcake emoji with stick figure arms and legs and PINK GLOW!
    if(theme.name === "Sparkle Stick" && cupcakeMode > 0){
      const time = Date.now();
      const bounce = Math.sin(time * 0.005) * 2; // Gentle bounce
      
      // PINK GLOW OUTLINE - bright and visible!
      const glowPulse = Math.sin(time * 0.004) * 0.3 + 0.7;
      const alpha = (cupcakeMode / 600) * glowPulse;
      
      // Multiple layers for bright outline effect
      // Outer bright pink ring
      ctx.globalAlpha = alpha * 0.8;
      ctx.strokeStyle = '#ff69b4'; // Theme border color
      ctx.lineWidth = 8;
      ctx.shadowColor = '#ff69b4';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(0, -5 + bounce, 28, 0, Math.PI * 2);
      ctx.stroke();
      
      // Middle pink ring
      ctx.globalAlpha = alpha * 0.9;
      ctx.lineWidth = 5;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = '#ffc0e0'; // Grid color
      ctx.beginPath();
      ctx.arc(0, -5 + bounce, 23, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner bright core ring
      ctx.globalAlpha = alpha * 1;
      ctx.lineWidth = 3;
      ctx.shadowBlur = 10;
      ctx.strokeStyle = '#ffb6d9'; // Lighter pink
      ctx.beginPath();
      ctx.arc(0, -5 + bounce, 18, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
      
      // Draw cupcake emoji
      ctx.font = "32px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("üßÅ", 0, -5 + bounce);
      
      // Stick figure arms with pink glow
      ctx.strokeStyle = "#ff1493"; // Hot pink
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      ctx.shadowColor = '#ff69b4';
      ctx.shadowBlur = 6;
      
      const armSwing = Math.sin(time * 0.003) * 0.2;
      ctx.beginPath();
      ctx.moveTo(-8, 0 + bounce);
      ctx.lineTo(-14, 4 + bounce + armSwing * 3);
      ctx.moveTo(8, 0 + bounce);
      ctx.lineTo(14, 4 + bounce - armSwing * 3);
      ctx.stroke();
      
      // Stick figure legs with pink glow
      ctx.beginPath();
      ctx.moveTo(-3, 10 + bounce);
      ctx.lineTo(-6, 16 + bounce);
      ctx.moveTo(3, 10 + bounce);
      ctx.lineTo(6, 16 + bounce);
      ctx.stroke();
      
      ctx.shadowBlur = 0;
      
      // Carry dots for cupcake
      const cap = carryCap();
      const carried = game.carry.length;
      const slots = Math.min(6, cap);
      const startX = -((slots-1)*4)/2;
      const isFull = carried >= cap;
      
      for (let i=0;i<slots;i++){
        ctx.beginPath();
        const filled = i < carried;
        if (isFull){
          ctx.fillStyle = filled ? "#ff1f3a" : "rgba(255,31,58,0.25)";
        } else {
          ctx.fillStyle = filled ? "#ffd166" : "rgba(243,244,246,0.18)";
        }
        ctx.arc(startX + i*4, 18 + bounce, 1.5, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
      return; // Don't draw normal stick figure
    }
    
    // Normal stick figure drawing
    let strokeBase = (theme.name === "Ice Stick") ? "#0b0f14" : 
                     (theme.name === "Sparkle Stick") ? "#ff1493" : // Hot pink for visibility
                     (theme.name === "Banana Stick") ? "#ffffff" : // White for banana
                     "#f3f4f6";
    
    ctx.strokeStyle = strokeBase;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";

    const skin = game.playerSkin || "classic";

    const drawCarryDots = () => {
      const cap = carryCap();
      const carried = game.carry.length;
      const slots = Math.min(6, cap);
      const startX = -((slots-1)*4)/2;
      const isFull = carried >= cap;

      for (let i=0;i<slots;i++){
        ctx.beginPath();
        const filled = i < carried;
        if (isFull){
          ctx.fillStyle = filled ? "#ff1f3a" : "rgba(255,31,58,0.25)";
        } else {
          ctx.fillStyle = filled ? "#ffd166" : "rgba(243,244,246,0.18)";
        }
        ctx.arc(startX + i*4, 17, 1.5, 0, Math.PI*2);
        ctx.fill();
      }
    };

    const drawClassicBody = () => {
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    };
    
    const drawBananaBody = () => {
      // Classic front-facing banana - simple and recognizable!
      
      // Main banana body - tapered at bottom like real banana
      ctx.fillStyle = "#FFD700"; // Golden yellow
      ctx.strokeStyle = "#DAA520"; // Darker gold outline
      ctx.lineWidth = 2.5;
      
      // Banana shape - tapers to a point at bottom
      ctx.beginPath();
      ctx.moveTo(-4, -16);
      ctx.lineTo(-4, 8);
      ctx.quadraticCurveTo(-4, 11, -2, 12); // Start tapering
      ctx.lineTo(0, 14); // Point at bottom
      ctx.lineTo(2, 12); // Taper from other side
      ctx.quadraticCurveTo(4, 11, 4, 8);
      ctx.lineTo(4, -16);
      ctx.quadraticCurveTo(4, -18, 0, -18);
      ctx.quadraticCurveTo(-4, -18, -4, -16);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Brown spots
      ctx.fillStyle = "rgba(139, 69, 19, 0.5)";
      ctx.beginPath();
      ctx.ellipse(-2, -8, 1.5, 2, 0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(1, -2, 1.2, 1.6, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(-1, 5, 1.3, 1.7, 0.1, 0, Math.PI * 2);
      ctx.fill();
      
      // Green tip at top
      ctx.fillStyle = "#9ACD32";
      ctx.strokeStyle = "#7CB342";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-3, -18);
      ctx.quadraticCurveTo(0, -21, 3, -18);
      ctx.lineTo(0, -16);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Stick figure arms
      ctx.strokeStyle = strokeBase;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-4, 0);
      ctx.lineTo(-8, 3);
      ctx.moveTo(4, 0);
      ctx.lineTo(8, 3);
      ctx.stroke();
      
      // Stick figure legs - from sides of tapered bottom
      ctx.beginPath();
      ctx.moveTo(-2, 12);
      ctx.lineTo(-5, 19);
      ctx.moveTo(2, 12);
      ctx.lineTo(5, 19);
      ctx.stroke();
      
      // Happy face
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(-1.5, -10, 1.2, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(1.5, -10, 1.2, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, -7, 2, 0.2, Math.PI - 0.2);
      ctx.stroke();
      
      drawCarryDots();
    };

    // SKELETON MODE - cursed stick figure!
    if (isSkeletonMode){
      // Skull head
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#8b00ff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, -6, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      
      // Eye sockets
      ctx.fillStyle = "#000000";
      ctx.beginPath();
      ctx.arc(-2, -7, 1.5, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(2, -7, 1.5, 0, Math.PI*2);
      ctx.fill();
      
      // Nose hole (triangle)
      ctx.beginPath();
      ctx.moveTo(0, -5);
      ctx.lineTo(-1, -3);
      ctx.lineTo(1, -3);
      ctx.closePath();
      ctx.fill();
      
      // Bone body
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();
      
      // Rib cage lines
      ctx.lineWidth = 1.5;
      for(let i = 0; i < 3; i++){
        ctx.beginPath();
        ctx.moveTo(-4, 2 + i * 3);
        ctx.lineTo(4, 2 + i * 3);
        ctx.stroke();
      }
      
      // Bone arms
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();
      
      // Bone legs
      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();
      
      drawCarryDots();
    }
    else if (bananaMode){
      drawBananaBody();
    }
    else if (skin === "alien"){
      ctx.beginPath();
      ctx.arc(0, -7, 7, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, -14);
      ctx.lineTo(-6, -19);
      ctx.moveTo(3, -14);
      ctx.lineTo(6, -19);
      ctx.stroke();

      ctx.beginPath();
      ctx.fillStyle = "#ffd166";
      ctx.arc(-6, -20, 1.6, 0, Math.PI*2);
      ctx.arc(6, -20, 1.6, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = strokeBase;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 3);
      ctx.lineTo(7, 1);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "sally"){
      ctx.beginPath();
      ctx.arc(0, -8, 4.5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(-7, 9);
      ctx.lineTo(7, 9);
      ctx.closePath();
      ctx.fillStyle = strokeBase;
      ctx.globalAlpha = 0.16;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.strokeStyle = strokeBase;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(-11, 4);
      ctx.moveTo(7, 2);
      ctx.lineTo(11, 4);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-3, 9);
      ctx.lineTo(-6, 13);
      ctx.moveTo(3, 9);
      ctx.lineTo(6, 13);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rick"){
      ctx.beginPath();
      ctx.arc(0, -6, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-4, -11);
      ctx.lineTo(-2, -14);
      ctx.moveTo(-1, -11);
      ctx.lineTo(1, -15);
      ctx.moveTo(2, -11);
      ctx.lineTo(4, -14);
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(-4, -9, 3, 3);
      ctx.rect(1, -9, 3, 3);
      ctx.moveTo(-1, -7.5);
      ctx.lineTo(1, -7.5);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -1);
      ctx.lineTo(0, 9);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-6, 2);
      ctx.lineTo(6, 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "robot"){
      // Pulsating value for eyes and antenna
      const eyePulse = Math.sin(Date.now() / 200) * 0.5 + 0.5;
      const eyeGlow = 0.4 + eyePulse * 0.6;
      
      // head
      ctx.beginPath();
      ctx.rect(-6, -13, 12, 10);
      ctx.stroke();

      // antenna
      ctx.beginPath();
      ctx.moveTo(0, -13);
      ctx.lineTo(0, -18);
      ctx.stroke();
      
      // antenna tip (RED pulsating to match eyes!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 3 + eyePulse * 5;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.beginPath();
      ctx.arc(0, -19, 1.8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.strokeStyle = strokeBase;

      // eyes (RED pulsating glow!)
      ctx.save();
      ctx.shadowColor = "#ff1f3a";
      ctx.shadowBlur = 4 + eyePulse * 6;
      ctx.fillStyle = "rgba(255,31,58," + eyeGlow + ")";
      ctx.fillRect(-4, -10, 3, 2);
      ctx.fillRect(1, -10, 3, 2);
      ctx.restore();
      
      // Eye outlines
      ctx.beginPath();
      ctx.rect(-4, -10, 3, 2);
      ctx.rect(1, -10, 3, 2);
      ctx.stroke();

      // body
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(0, 9);
      ctx.stroke();

      // arms
      ctx.beginPath();
      ctx.moveTo(-7, 2);
      ctx.lineTo(7, 2);
      ctx.stroke();

      // legs
      ctx.beginPath();
      ctx.moveTo(0, 9);
      ctx.lineTo(-6, 15);
      ctx.moveTo(0, 9);
      ctx.lineTo(6, 15);
      ctx.stroke();

      drawCarryDots();
    }
    else if (skin === "rex"){
      // Rex Stick - pure simple stick dog!
      // Uses strokeBase (dark on Ice Stick, white elsewhere)
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      
      // BIG Head (circle outline)
      ctx.beginPath();
      ctx.arc(0, -10, 6, 0, Math.PI * 2);
      ctx.stroke();
      
      // BIG Ears (longer lines sticking up)
      ctx.beginPath();
      ctx.moveTo(-4, -14);
      ctx.lineTo(-5, -18);
      ctx.moveTo(4, -14);
      ctx.lineTo(5, -18);
      ctx.stroke();
      
      // Short body
      ctx.beginPath();
      ctx.moveTo(0, -4);
      ctx.lineTo(0, 2);
      ctx.stroke();
      
      // Minimal cute legs (just little stubs)
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-2, 2);
      ctx.lineTo(-2, 6);
      ctx.moveTo(2, 2);
      ctx.lineTo(2, 6);
      ctx.stroke();
      
      // Wagging tail! (wags left and right like a real dog!)
      const waggle = Math.sin(Date.now() / 150) * 0.8; // swings from -0.8 to +0.8
      ctx.save();
      ctx.translate(0, -1);
      ctx.rotate(waggle);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(3, -1, 6, -4);
      ctx.stroke();
      ctx.restore();
      
      drawCarryDots();
    }
    else {
      drawClassicBody();
    }

    // Santa hat on Ice Stick (floppy style)
    if (theme.name === "Ice Stick"){
      ctx.save();
      
      // Main hat body (flopped to the side)
      ctx.fillStyle = "#dc2626";
      ctx.strokeStyle = "#991b1b";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(-6, -12); // base left
      ctx.lineTo(6, -12);  // base right
      ctx.quadraticCurveTo(8, -16, 6, -19); // curve up and right
      ctx.lineTo(-2, -19); // top edge
      ctx.quadraticCurveTo(-4, -16, -6, -12); // curve back to base
      ctx.fill();
      ctx.stroke();
      
      // White fur trim at base
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(0, -12, 6, 1.5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // White pom-pom at tip (flopped over to the right)
      ctx.beginPath();
      ctx.arc(7, -19, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#e5e5e5";
      ctx.lineWidth = 0.5;
      ctx.stroke();
      
      ctx.restore();
    }

    ctx.restore();
  }

  function drawSparks(){
    if (!game.sparks.length) return;
    ctx.save();
    for (let i=game.sparks.length-1;i>=0;i--){
      const s = game.sparks[i];
      s.x += s.vx;
      s.y += s.vy;
      s.vx *= 0.96;
      s.vy *= 0.96;
      s.life -= 1;

      const a = clamp(s.life / 40, 0, 1);
      ctx.globalAlpha = 0.15 + a*0.75;
      ctx.fillStyle = s.evil ? "#ff1f3a" : "#f3f4f6";
      ctx.fillRect(s.x, s.y, 2, 2);

      if (s.life <= 0) game.sparks.splice(i,1);
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawHudText(){
    if (game.hudTimer > 0 && game.hudMsg){
      game.hudTimer--;
      const t = currentLevelTheme();
      ctx.save();
      ctx.globalAlpha = clamp(game.hudTimer / 60, 0, 1);
      ctx.font = "bold 16px ui-monospace, Menlo, Consolas, monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(game.hudMsg, CANVAS_W/2 + 1, 20 + 1);

      ctx.fillStyle = t.name === "Ice Stick" ? "#0b0f14" : "#f3f4f6";
      ctx.fillText(game.hudMsg, CANVAS_W/2, 20);
      ctx.restore();
    }
  }

  function updateTreeTimers(){
    // freeze during monster battles (as promised in info)
    if (game.pendingMonster) return;

    if (!game.treeSpawnedThisLevel){
      if (game.treeSpawnDelay > 0){
        game.treeSpawnDelay--;
        if (game.treeSpawnDelay <= 0) spawnTreeNow();
      }
      return;
    }

    if (game.treeActive){
      if (game.treePhaseTimer > 0){
        game.treePhaseTimer--;
        if (game.treePhaseTimer <= 0){
          if (game.treePhase === "visible") startTreeBlinking();
          else if (game.treePhase === "blinking") endTree();
        }
      }
    }
  }

  function updateRollButton(){
    ui.btnRoll.disabled = !canRoll() && !game.pendingMonster;
  }

  /* ---- Main loop ---- */
  function loop(){
    rafId = requestAnimationFrame(loop);

    // Stop updating game logic if game over or victory overlay is showing
    const isGameEnded = ui.gameOverOverlay.style.display === "flex" || 
                        ui.winOverlay.style.display === "flex";
    
    if (!isGameEnded) {
      // update
      updateTreeTimers();
      updateRollButton();
    
    // Update fire tiles for Fire Stick theme
    if (currentLevelTheme().name === "Fire Stick" && fireTiles.length > 0){
      updateFireTiles();
    }
    
    // Update Sparkle Stick features
    if (currentLevelTheme().name === "Sparkle Stick"){
      updateSparkleStick();
    }
    
    // Update wind tiles for Sky Stick theme
    if (currentLevelTheme().name === "Sky Stick" && windTiles.length > 0){
      updateWindTiles();
      updateSkyClouds();
    }
    
    // Update snakes for Snake Stick theme
    if (currentLevelTheme().name === "Snake Stick" && snakes.length > 0){
      updateSnakes();
    }
    
    // Update Banana Stick features
    if (currentLevelTheme().name === "Banana Stick"){
      updateMonkeys();
    }
    
    // Update Mountain Stick features
    if (currentLevelTheme().name === "Mountain Stick"){
      updateRams();
    }
    
    // Update Cursed Stick features
    if (currentLevelTheme().name === "Cursed Stick"){
      updateCursedStick();
    }
    
    // Update freeze zones for Ice Stick theme
    if (currentLevelTheme().name === "Ice Stick" && freezeTiles.length > 0){
      updateFreezeTiles();
    }
    
    // Update shadow monsters for Glow Stick
    if (currentLevelTheme().name === "Glow Stick" && shadowMonsters.length > 0){
      updateShadowMonsters();
    }
    
    // Update ambient particles (shooting stars, etc)
    updateAmbientParticles();
    
    // Update sharks for Sea Stick
    if (currentLevelTheme().name === "Sea Stick" && sharks.length > 0){
      updateSharks();
    }
    
    // Update sun bursts for Sun Stick
    if (currentLevelTheme().name === "Sun Stick" && sunBurstTiles.length > 0){
      updateSunBursts();
      updateSunCharacter();
    }
    
    // Update star grid for Night Stick
    if (currentLevelTheme().name === "Night Stick" && starGridTiles.length > 0){
      updateStarGrid();
    }
    if (currentLevelTheme().name === "Night Stick" && ufo){
      updateUFO();
    }
    
    // Update sun glow effect
    if (playerSunGlow > 0){
      playerSunGlow--;
    }
    
    // Update cloud effect
    if (playerCloudEffect > 0){
      playerCloudEffect--;
    }
    
    // Update Spell Stick hazards (moving teleports + hole)
    if (currentLevelTheme().name === "Spell Stick"){
      updateLevelHazards();
    }
    
    // Update snowman for Ice Stick
    if (currentLevelTheme().name === "Ice Stick" && snowman){
      updateSnowman();
    }
    
    if (currentLevelTheme().name === "Spider Stick"){
      if (spiderWebs.length > 0) updateSpiderWebs();
      if (spiders.length > 0) updateSpiders();
    }
    
    // Victory Stick - LASER GRID update
    if (currentLevelTheme().name === "Victory Stick"){
      updateVictoryLasers();
    }
    } // End of !isGameEnded check

    // draw (continue drawing even when game is ended)
    const theme = currentLevelTheme();
    drawGrid(theme);
    drawLifeHint(theme);
    drawTree(theme);

    // Star grid (draw BEFORE sticks for layering)
    if (theme.name === "Night Stick" && starGridTiles.length > 0){
      drawStarGrid();
    }
    if (theme.name === "Night Stick" && ufo){
      drawUFO();
    }
    
    // Draw Sparkle Stick features (behind sticks)
    if (theme.name === "Sparkle Stick"){
      drawSparkleStick();
    }

    // sticks
    for (const s of game.sticks) drawStick(s);

    // hole + player glow (behind player)
    drawHole(theme);
    if (theme.name === "Night Stick"){
      drawPlayerGlow();
    }
    drawPlayer();
    
    // Draw wind tiles
    if (theme.name === "Sky Stick" && windTiles.length > 0){
      drawWindTiles();
    }
    
    // Draw snakes
    if (theme.name === "Snake Stick" && snakes.length > 0){
      drawSnakes();
    }
    
    // Draw mountains (Mountain Stick)
    drawMountains();
    drawMountainClouds();
    drawRams();
    
    // Draw Sky Stick clouds and airplane
    if (theme.name === "Sky Stick"){
      drawSkyClouds();
    }
    
    // Draw bananas and monkey (Banana Stick)
    drawBananas();
    drawMonkeys();
    
    // Draw freeze zones
    if (theme.name === "Ice Stick" && freezeTiles.length > 0){
      drawFreezeTiles();
    }
    
    // Draw shadow monsters
    if (theme.name === "Glow Stick" && shadowMonsters.length > 0){
      drawShadowMonsters();
    }
    
    // Draw Cursed Stick features
    if (theme.name === "Cursed Stick"){
      drawCursedStick();
    }
    
    // Draw sharks for Sea Stick
    if (theme.name === "Sea Stick" && sharks.length > 0){
      drawSharks();
    }
    
    // Draw sun bursts for Sun Stick
    if (theme.name === "Sun Stick" && sunBurstTiles.length > 0){
      drawSunBursts();
      drawSunCharacter();
    }
    
    // Draw Spell Stick teleports and hole flash
    if (theme.name === "Spell Stick" && teleportTiles.length > 0){
      drawLevelHazards();
    }
    
    // Draw snowman for Ice Stick
    if (theme.name === "Ice Stick" && snowman){
      drawSnowman();
    }
    
    if (theme.name === "Spider Stick"){
      if (spiderWebs.length > 0) drawSpiderWebs();
      if (spiders.length > 0) drawSpiders();
    }
    
    // Victory Stick - LASER GRID drawing
    if (theme.name === "Victory Stick"){
      drawVictoryLasers();
    }

    drawSparks();
    
    // Draw ambient particles (background)
    drawAmbientParticles();
    
    // Draw ice frost on edges
    drawIceFrost();
    
    // Draw level hazards (dark tiles, teleport tiles)
    drawLevelHazards();
    
    // Draw fire tiles for Fire Stick theme
    if (theme.name === "Fire Stick" && fireTiles.length > 0){
      drawFireTiles();
    }
    

    // Draw stick pickup particles// Draw special effects (shield, vision)
    drawSpecialEffects();
    
    // Draw snowflakes for Ice Stick theme (foreground)
    if (theme.name === "Ice Stick" && snowflakes.length > 0){
      drawSnowflakes();
    }
    
    drawHudText();
  }

  /* ---- UI + Controls ---- */
  function openInfo(){
    ui.infoOverlay.style.display = "flex";
    game.inputLocked = true;
    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
    window.infoMusicWas = musicOn;
    if (musicOn) stopMusic();
  }
  function closeInfo(){
    ui.infoOverlay.style.display = "none";
    if (!paused && ui.nameOverlay.style.display !== "flex" &&
        ui.gameOverOverlay.style.display !== "flex" &&
        ui.winOverlay.style.display !== "flex"){
      game.inputLocked = false;
    }
    if (!rafId) startLoop();
    if (window.infoMusicWas) { musicOn = true; ui.btnMusic.textContent = "Music: ON"; startMusic(); }
  }

  // Skip to Level functionality
  const levelNames = ["Night", "Sparkle", "Sun", "Sky", "Fire", "Mountain", "Cursed", "Banana", "Ice", "Glow", "Spell", "Sea", "Spider", "Snake", "Victory"];
  const levelEmojis = ["üåô", "‚ú®", "‚òÄÔ∏è", "‚òÅÔ∏è", "üî•", "‚õ∞Ô∏è", "üíÄ", "üçå", "‚ùÑÔ∏è", "üí´", "üîÆ", "üåä", "üï∑Ô∏è", "üêç", "üëë"];

  function showSkipLevelMenu(){
    const modal = document.getElementById('skipLevelPanel');
    const grid = document.getElementById('levelGrid');
    
    if(!modal || !grid){
      console.error('Skip level modal not found');
      return;
    }
    
    grid.innerHTML = '';
    
    for(let i = 0; i < levelNames.length; i++){
      const btn = document.createElement('button');
      
      // Get theme colors for this level
      const level = LEVELS[i];
      const baseColor = level.border; // Use border color as the base
      const accentColor = level.accent;
      
      // Create colored button matching the level theme
      const defaultBg = `linear-gradient(135deg, ${baseColor}22 0%, ${baseColor}44 100%)`;
      const hoverBg = `linear-gradient(135deg, ${baseColor} 0%, ${accentColor} 100%)`;
      
      btn.style.cssText = `padding:12px; background:${defaultBg}; border:2px solid ${baseColor}; border-radius:8px; color:#fff; cursor:pointer; font-size:13px; font-weight:600; transition:all 0.2s; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);`;
      btn.innerHTML = `${levelEmojis[i]}<br>Level ${i + 1}<br><span style="font-size:10px; opacity:0.9;">${levelNames[i]}</span>`;
      btn.onmouseover = () => btn.style.background = hoverBg;
      btn.onmouseout = () => btn.style.background = defaultBg;
      btn.onclick = () => skipToLevel(i + 1);
      grid.appendChild(btn);
    }
    
    modal.style.display = 'flex';
  }

  function skipToLevel(levelNum){
    const modal = document.getElementById('skipLevelPanel');
    if(modal) modal.style.display = 'none';
    
    game.level = levelNum - 1;
    newLevel();
  }

  btnInfo.addEventListener("click", openInfo);
  ui.btnInfoClose.addEventListener("click", closeInfo);

  ui.btnRoll.addEventListener("click", doRoll);
  ui.btnUse.addEventListener("click", pickOrDrop);
  ui.btnNew.addEventListener("click", () => newGame(false));
  ui.btnPause.addEventListener("click", togglePause);
  ui.btnPauseClose.addEventListener("click", togglePause);

  ui.btnSave.addEventListener("click", saveGame);
  ui.btnLoad.addEventListener("click", loadGame);

  ui.btnUp.addEventListener("click", () => move(0,-1));
  ui.btnDown.addEventListener("click", () => move(0,1));
  ui.btnLeft.addEventListener("click", () => move(-1,0));
  ui.btnRight.addEventListener("click", () => move(1,0));

  ui.skin.addEventListener("change", (e) => setAndStoreSkin(e.target.value));

  ui.btnGameOverClose.addEventListener("click", () => {
    window.close(); // Close the browser tab/window
  });
  document.getElementById('btnSkipLevel').addEventListener('click', showSkipLevelMenu);
  document.getElementById('closeSkipLevel')?.addEventListener('click', () => {
    document.getElementById('skipLevelPanel').style.display = 'none';
  });

  ui.btnRestart.addEventListener("click", () => {
    ui.gameOverOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnWinRestart.addEventListener("click", () => {
    ui.winOverlay.style.display = "none";
    game.inputLocked = false;
    newGame(false);
  });

  ui.btnWinClose.addEventListener("click", () => {
    window.close(); // Close the browser tab/window
  });

  ui.btnMusic.addEventListener("click", async () => {
    await unlockOnce();
    musicOn = !musicOn;
    ui.btnMusic.textContent = musicOn ? "Music: ON" : "Music: OFF";
    if (musicOn){
      startMusic();
      logEvent("neutral","Music ON.");
    } else {
      stopMusic();
      logEvent("neutral","Music OFF.");
    }
  });

  ui.nameStartBtn.addEventListener("click", startFromNameInput);
  ui.nameUseP1Btn.addEventListener("click", () => { setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); });
  ui.nameUseSavedBtn.addEventListener("click", () => {
    const s = getSavedName();
    setAndStoreName(s || "PLAYER1");
    closeNameModal();
    newGame(true);
  });

  ui.nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){ e.preventDefault(); startFromNameInput(); }
    if (e.key === "Escape"){ e.preventDefault(); setAndStoreName("PLAYER1"); closeNameModal(); newGame(true); }
  });

  document.addEventListener("keydown", (e) => {
    // Check overlays FIRST - don't allow level skip during modals
    if (ui.nameOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        setAndStoreName("PLAYER1");
        closeNameModal();
        newGame(true);
      }
      return;
    }
    if (ui.infoOverlay.style.display === "flex"){
      if (e.key === "Escape"){ e.preventDefault(); closeInfo(); }
      return;
    }
    if (ui.gameOverOverlay.style.display === "flex" || ui.winOverlay.style.display === "flex"){
      if (e.key === "Escape"){
        e.preventDefault();
        ui.gameOverOverlay.style.display = "none";
        ui.winOverlay.style.display = "none";
        game.inputLocked = false;
        newGame(false);
      }
      return;
    }

    if (e.key === "p" || e.key === "P" || e.key === "Escape"){
      e.preventDefault();
      togglePause();
      return;
    }
    if (paused) return;

    // save/load hotkeys (only when allowed)
    if ((e.key === "s" || e.key === "S") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      saveGame();
      return;
    }
    if ((e.key === "l" || e.key === "L") && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      loadGame();
      return;
    }
    
    // SECRET LEVEL SKIP: Shift + L (only during gameplay, not during modals)
    if (e.shiftKey && (e.key === 'L' || e.key === 'l')){
      e.preventDefault();
      const input = prompt("Skip to level (1-11):");
      if (input){
        const num = parseInt(input);
        if (!isNaN(num) && num >= 1 && num <= 11){
          game.level = num;
          applyThemeForLevel();
          game.sticks = [];
          game.carry = [];
          spawnHole();
          spawnSticksForLevel(game.level);
          spawnLifeTile();
          scheduleTreeForLevel();
          
          const theme = currentLevelTheme().name;
          
          // Clear all hazards first
          windTiles = [];
          fireTiles = [];
          freezeTiles = [];
          snakes = [];
          shadowMonsters = [];
          sharks = [];
          sunBurstTiles = [];
          starGridTiles = [];
          teleportTiles = [];
          spiderWebs = [];
          spiders = [];
          skunks = [];
          stinkClouds = [];
          snowman = null;
          stopIceWindSound();
          
          // Initialize for specific level
          if (theme === "Sky Stick") initWindTiles();
          if (theme === "Fire Stick") initFireTiles();
          if (theme === "Ice Stick"){ initFreezeTiles(); startIceWindSound(); initSnowman(); }
          if (theme === "Snake Stick") initSnakes();
          if (theme === "Spell Stick"){
            teleportTiles = [];
            for(let i=0;i<randInt(5,8);i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
            holeMoveTimer = randInt(600,900);
          }
          if (theme === "Glow Stick") initShadowMonsters();
          if (theme === "Sea Stick") initSharks();
          if (theme === "Sun Stick") initSunBursts();
          if (theme === "Night Stick"){ initStarGrid(); initUFO(); }
          if (theme === "Spider Stick"){ initSpiderWebs(); initSpiders(); }
          if (theme === "Victory Stick"){
            windTiles = []; for(let i=0;i<2;i++) windTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()*Math.PI*2});
            fireTiles = []; for(let i=0;i<2;i++) fireTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),intensity:Math.random()});
            initSnakes(); snakes = snakes.slice(0,1);
            initFreezeTiles(); freezeTiles = freezeTiles.slice(0,4);
            initShadowMonsters(); shadowMonsters = shadowMonsters.slice(0,1);
            initSharks(); sharks = sharks.slice(0,2);
            initSunBursts(); sunBurstTiles = sunBurstTiles.slice(0,3);
            initSnowman();
            initSpiderWebs(); spiderWebs = spiderWebs.slice(0,3);
            initSpiders(); spiders = spiders.slice(0,2);
            teleportTiles = []; for(let i=0;i<4;i++) teleportTiles.push({x:randInt(0,GRID_W-1),y:randInt(0,GRID_H-1),glow:Math.random()*Math.PI*2,moveTimer:randInt(120,300)});
            holeMoveTimer = randInt(600,900);
          }
          
          initLevelHazards();
          initAmbientParticles();
          
          logEvent("level", "Skipped to Level " + num + " (" + theme + ")");
          setHud("LEVEL " + num + "!");
          updateUI();
        }
      }
      return;
    }

    if (game.inputLocked && !game.pendingMonster) return;

    if (e.key === "ArrowUp"){ e.preventDefault(); move(0,-1); }
    else if (e.key === "ArrowDown"){ e.preventDefault(); move(0,1); }
    else if (e.key === "ArrowLeft"){ e.preventDefault(); move(-1,0); }
    else if (e.key === "ArrowRight"){ e.preventDefault(); move(1,0); }
    else if (e.key === " "){ e.preventDefault(); pickOrDrop(); }
    else if (e.key === "r" || e.key === "R"){ e.preventDefault(); doRoll(); }
    else if (e.key === "s" || e.key === "S"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); saveGame(); } }
    else if (e.key === "l" || e.key === "L"){ if (!e.ctrlKey && !e.metaKey){ e.preventDefault(); loadGame(); } }
  });

  // init
  renderLeaderboard(loadLeaderboard());
  setAndStoreSkin(getSavedSkin());
  const savedName = getSavedName();
  if (savedName) setAndStoreName(savedName);
  applyThemeForLevel();
  updateUI();
  updateScrollHint();

  // always start on name prompt
  showNameModal();
})();
</script>
</body>
</html>
